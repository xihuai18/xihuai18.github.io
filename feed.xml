<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://xihuai18.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://xihuai18.github.io/" rel="alternate" type="text/html" hreflang="en" /><updated>2026-01-01T06:55:43+00:00</updated><id>https://xihuai18.github.io/feed.xml</id><title type="html">Xihuai Wang’s Page</title><subtitle>Xihuai&apos;s personal page.
</subtitle><entry xml:lang="en"><title type="html">Taming Stale Data: Off-Policy Reinforcement Learning for LLMs with Monotonic Improvement Guarantees</title><link href="https://xihuai18.github.io/reinforcement-learning/2025/12/17/offpolicy-en.html" rel="alternate" type="text/html" title="Taming Stale Data: Off-Policy Reinforcement Learning for LLMs with Monotonic Improvement Guarantees" /><published>2025-12-17T00:00:00+00:00</published><updated>2025-12-17T00:00:00+00:00</updated><id>https://xihuai18.github.io/reinforcement-learning/2025/12/17/offpolicy-en</id><content type="html" xml:base="https://xihuai18.github.io/reinforcement-learning/2025/12/17/offpolicy-en.html"><![CDATA[<h2 id="introduction-why-should-we-care-about-off-policy">Introduction: Why Should We Care About “Off-Policy”?</h2>

<p>Consider the following scenario: you are training a large language model with reinforcement learning to improve its question-answering capabilities. Ideally, each time the model generates a batch of responses, you would immediately update the model with this data, then use the updated model to generate new data, and so on. This approach of “updating with data from the same policy that generated it” is called <strong>on-policy</strong> training.</p>

<p>Reality, however, is not so simple. In large-scale distributed training, hundreds of GPUs generate data in parallel, while model updates take time. When a new model is deployed, much data generated by “older versions” of the model remains unused—discarding it seems wasteful, yet using it raises concerns about whether “stale data” might harm training effectiveness.</p>

<p>This is the core problem faced by <strong>off-policy</strong> training: <strong>Can we guarantee continued performance improvement when using data collected by older policies to update newer policies?</strong></p>

<p>This article systematically addresses this question. Starting from foundational theory, we progressively derive actionable conditions that specify when mixing data from multiple policy versions can still guarantee monotonic training improvement.</p>

<h2 id="part-i-theoretical-foundations">Part I: Theoretical Foundations</h2>

<h3 id="11-basic-setup">1.1 Basic Setup</h3>

<p>We consider a standard Markov Decision Process (MDP) comprising a state space ⟦INLMATH27MATHEND⟧, action space ⟦INLMATH28MATHEND⟧, transition probability ⟦INLMATH29MATHEND⟧, reward function ⟦INLMATH30MATHEND⟧, initial distribution ⟦INLMATH31MATHEND⟧, and discount factor ⟦INLMATH32MATHEND⟧.</p>

<p>The <strong>expected cumulative discounted return</strong> of policy ⟦INLMATH33MATHEND⟧ is:</p>

<p>⟦DISPMATH9MATHEND⟧</p>

<p>The <strong>discounted state visitation distribution</strong> represents the weighted frequency of visiting each state during long-term policy execution:</p>

<p>⟦DISPMATH10MATHEND⟧</p>

<p>The <strong>advantage function</strong> measures how much better action ⟦INLMATH34MATHEND⟧ is compared to the policy’s average:</p>

<p>⟦DISPMATH11MATHEND⟧</p>

<p>The <strong>total variation distance</strong> (TV distance) measures the difference between two policies’ action distributions at state ⟦INLMATH35MATHEND⟧:</p>

<p>⟦DISPMATH12MATHEND⟧</p>

<h3 id="12-core-tool-policy-performance-difference-lemma">1.2 Core Tool: Policy Performance Difference Lemma</h3>

<p>The cornerstone of the entire theory is this elegant result:</p>

<blockquote>
  <p><strong>Lemma 1.1 (Policy Performance Difference Lemma)</strong></p>

  <p>For any policies ⟦INLMATH36MATHEND⟧ (old) and ⟦INLMATH37MATHEND⟧ (new), the performance difference can be expressed as:</p>

  <p>⟦DISPMATH1MATHEND⟧</p>
</blockquote>

<p><strong>Intuitive understanding</strong>: How much better the new policy is than the old equals the “average advantage” obtained by selecting actions according to the new policy under the state distribution visited by the new policy.</p>

<h2 id="part-ii-performance-improvement-bounds-for-single-policy-sampling">Part II: Performance Improvement Bounds for Single-Policy Sampling</h2>

<h3 id="21-the-distribution-mismatch-problem">2.1 The Distribution Mismatch Problem</h3>

<p>The Policy Performance Difference Lemma has a practical issue: the expectation on the right-hand side is computed under ⟦INLMATH38MATHEND⟧ (the new policy’s state distribution), while we can only sample from ⟦INLMATH39MATHEND⟧ (the old policy).</p>

<p>The solution is to decompose the expectation into “expectation under the old distribution + bias term,” then control the bias. The key question is: <strong>What is the quantitative relationship between the difference in state distributions and the difference in policies?</strong></p>

<h3 id="22-controlling-state-distribution-differences">2.2 Controlling State Distribution Differences</h3>

<blockquote>
  <p><strong>Lemma 1.2 (Relationship Between State Distribution Difference and Policy TV Distance)</strong></p>

  <p>⟦DISPMATH2MATHEND⟧</p>
</blockquote>

<p><strong>Physical interpretation</strong>: Small differences in policies in action space are “amplified” through environment dynamics into differences in state visitation distributions. The coefficient ⟦INLMATH40MATHEND⟧ reflects the <strong>temporal accumulation effect</strong>—in long-horizon tasks (⟦INLMATH41MATHEND⟧ close to 1), the amplification is stronger.</p>

<p><strong>Proof sketch</strong>: By deriving the fixed-point equation for discounted visitation distributions and exploiting the ⟦INLMATH42MATHEND⟧ non-expansiveness of stochastic matrices, one can show that state distribution differences are amplified by policy differences through transition dynamics, with the amplification factor being precisely ⟦INLMATH43MATHEND⟧.</p>

<h3 id="23-policy-performance-improvement-lower-bound">2.3 Policy Performance Improvement Lower Bound</h3>

<blockquote>
  <p><strong>Theorem 1.1 (Policy Performance Improvement Lower Bound)</strong></p>

  <p>Define the expected advantage upper bound constant ⟦INLMATH44MATHEND⟧. Then:</p>

  <p>⟦DISPMATH3MATHEND⟧</p>

  <p>where the <strong>surrogate objective</strong> is:</p>

  <p>⟦DISPMATH4MATHEND⟧</p>
</blockquote>

<p>This lower bound consists of two parts:</p>

<ol>
  <li>
    <p><strong>Surrogate objective</strong> ⟦INLMATH45MATHEND⟧: Can be directly estimated from old policy data via importance sampling; this is the optimization objective of TRPO/PPO.</p>
  </li>
  <li>
    <p><strong>Policy shift penalty</strong>: Increases with the TV distance between new and old policies, explaining why PPO needs to constrain update magnitude.</p>
  </li>
</ol>

<p><strong>Core conclusion</strong>: Maximizing the surrogate objective while controlling policy shift guarantees performance improvement.</p>

<h2 id="part-iii-multi-policy-static-mixture-sampling">Part III: Multi-Policy Static Mixture Sampling</h2>

<h3 id="31-practical-scenarios">3.1 Practical Scenarios</h3>

<p>In practice, a batch of data may come from multiple policy versions ⟦INLMATH46MATHEND⟧, with respective proportions ⟦INLMATH47MATHEND⟧. How do we extend Theorem 1.1 to this setting?</p>

<h3 id="32-core-idea-augmented-state-space">3.2 Core Idea: Augmented State Space</h3>

<p>The solution is an elegant modeling technique: <strong>treat the policy version index as part of the state</strong>.</p>

<p>Define the augmented state space ⟦INLMATH48MATHEND⟧, where ⟦INLMATH49MATHEND⟧ is the policy index set. Under augmented state ⟦INLMATH50MATHEND⟧, the <strong>mixture behavior policy</strong> is defined as ⟦INLMATH51MATHEND⟧.</p>

<p>The evolution of indices is characterized by the <strong>index transition kernel</strong> ⟦INLMATH52MATHEND⟧. The augmented MDP inherits the original MDP’s rewards and environment transitions, with indices evolving independently according to ⟦INLMATH53MATHEND⟧.</p>

<p>This technique works because the new policy ⟦INLMATH54MATHEND⟧’s return in the augmented MDP equals its return in the original MDP, allowing direct application of Theorem 1.1.</p>

<h3 id="33-structural-simplification-for-trajectory-level-mixture">3.3 Structural Simplification for Trajectory-Level Mixture</h3>

<p>The most common scenario is <strong>using a single old policy per trajectory</strong>: at trajectory start, sample index ⟦INLMATH55MATHEND⟧, and use ⟦INLMATH56MATHEND⟧ throughout. In this case, the index transition kernel is the identity: ⟦INLMATH57MATHEND⟧.</p>

<p>From an engineering perspective, in many <strong>actor-learner asynchronous training</strong> setups (when sampling and training organize data by “entire trajectories/complete episodes belonging to a certain policy version”), this approximately corresponds to what we call <strong>trajectory-level mixture</strong>: actors use a fixed policy snapshot within a sampling unit to generate data, while learners mix trajectories from different versions for updates. We say “approximately” because different systems may not have identical boundaries for “trajectory/sampling unit.”</p>

<blockquote>
  <p><strong>Lemma 2.1 (Structural Simplification for Trajectory-Level Mixture)</strong></p>

  <p>(a) The augmented state visitation distribution decomposes as: ⟦INLMATH58MATHEND⟧</p>

  <p>(b) The advantage function reduces to: ⟦INLMATH59MATHEND⟧</p>
</blockquote>

<p><strong>Intuition for (b)</strong>: Since the index never changes, <strong>all future trajectories</strong> starting from augmented state ⟦INLMATH60MATHEND⟧ are generated by the same policy ⟦INLMATH61MATHEND⟧. Therefore, future cumulative returns are entirely determined by ⟦INLMATH62MATHEND⟧, and value functions and advantage functions naturally reduce to their ⟦INLMATH63MATHEND⟧ counterparts.</p>

<p>Consequently, the mixture policy’s return is the weighted average of individual old policies’ returns: ⟦INLMATH64MATHEND⟧.</p>

<h3 id="34-performance-improvement-lower-bound-for-trajectory-level-mixture">3.4 Performance Improvement Lower Bound for Trajectory-Level Mixture</h3>

<blockquote>
  <p><strong>Corollary 2.1 (Performance Improvement Lower Bound for Trajectory-Level Mixture)</strong></p>

  <p>⟦DISPMATH5MATHEND⟧</p>
</blockquote>

<p>This result shows that when mixing trajectories from multiple old policy versions for training, if we construct the loss using importance ratios corresponding to each trajectory’s source policy while controlling the new policy’s deviation from each old policy, the new policy’s performance has a clear improvement lower bound.</p>

<h2 id="part-iv-dynamic-mixture-sampling-and-monotonic-improvement-conditions">Part IV: Dynamic Mixture Sampling and Monotonic Improvement Conditions</h2>

<h3 id="41-the-core-challenge">4.1 The Core Challenge</h3>

<p>Part III discussed <strong>static mixture</strong>—where mixture weights ⟦INLMATH65MATHEND⟧ remain fixed. This section considers the more general <strong>dynamic mixture</strong>—where sampling gradually transitions to the new policy after it is released.</p>

<p>The previous results characterize improvement of “the new policy relative to the mixture behavior policy.” However, in actual training, what we truly care about is: <strong>Does the latest policy ⟦INLMATH66MATHEND⟧ after each update monotonically improve over the previous latest policy ⟦INLMATH67MATHEND⟧?</strong></p>

<p>⟦DISPMATH13MATHEND⟧</p>

<h3 id="42-unified-modeling-framework">4.2 Unified Modeling Framework</h3>

<p>Two typical forms of dynamic mixture sampling can be uniformly characterized by the index transition kernel ⟦INLMATH68MATHEND⟧:</p>

<p><strong>Trajectory-level mixture</strong> (can be viewed as an abstraction of conventional asynchronous training; identity index transition): ⟦INLMATH69MATHEND⟧</p>

<p><strong>Step/segment-level mixture</strong> (an abstraction of partial rollout / segment-based sampling; allows switching): ⟦INLMATH70MATHEND⟧</p>

<p>where ⟦INLMATH71MATHEND⟧ is the switching probability and ⟦INLMATH72MATHEND⟧ is the target index distribution.</p>

<h3 id="43-core-decomposition">4.3 Core Decomposition</h3>

<p>By introducing the mixture return ⟦INLMATH73MATHEND⟧ as an intermediate bridge, the performance difference decomposes as:</p>

<p>⟦DISPMATH14MATHEND⟧</p>

<p>The first term can be handled using Theorem 1.1. The second term is the <strong>mixture bias term</strong>, which can be shown to satisfy:</p>

<p>⟦DISPMATH15MATHEND⟧</p>

<h3 id="44-monotonic-improvement-lower-bound">4.4 Monotonic Improvement Lower Bound</h3>

<p>Combining the above results yields the core theorem:</p>

<blockquote>
  <p><strong>Theorem 3.1 (Monotonic Improvement Lower Bound Under Dynamic Mixture Sampling)</strong></p>

  <p>⟦DISPMATH6MATHEND⟧</p>
</blockquote>

<p>This lower bound reveals the necessity of <strong>dual control</strong>:</p>
<ul>
  <li><strong>Update shift penalty</strong>: Deviation of the new policy ⟦INLMATH74MATHEND⟧ from the sampling source policy ⟦INLMATH75MATHEND⟧</li>
  <li><strong>Sampling staleness penalty</strong>: Staleness of the sampling source policy ⟦INLMATH76MATHEND⟧ relative to the current policy ⟦INLMATH77MATHEND⟧</li>
</ul>

<h3 id="45-infeasibility-of-direct-constraints">4.5 Infeasibility of Direct Constraints</h3>

<p>The update shift penalty term in Theorem 3.1 might appear controllable by constraining ⟦INLMATH78MATHEND⟧, but this is actually <strong>infeasible</strong>:</p>

<blockquote>
  <p><strong>Observation 3.1 (Infeasibility of Update Shift Constraints)</strong></p>

  <p>Suppose the mixture sampling includes two old policies ⟦INLMATH79MATHEND⟧ and ⟦INLMATH80MATHEND⟧. If there exists some state ⟦INLMATH81MATHEND⟧ such that ⟦INLMATH82MATHEND⟧, then no policy ⟦INLMATH83MATHEND⟧ can simultaneously satisfy ⟦INLMATH84MATHEND⟧ and ⟦INLMATH85MATHEND⟧.</p>
</blockquote>

<p><strong>Proof</strong>: By the triangle inequality, if both constraints were satisfied, then ⟦INLMATH86MATHEND⟧, a contradiction.</p>

<p><strong>Root cause</strong>: The update shift penalty directly couples ⟦INLMATH87MATHEND⟧ with the historical policy family ⟦INLMATH88MATHEND⟧, whose internal structure is a product of historical training and not controllable by the current update.</p>

<h3 id="46-triangle-inequality-decomposition">4.6 Triangle Inequality Decomposition</h3>

<p>The solution leverages the triangle inequality of TV distance:</p>

<p>⟦DISPMATH16MATHEND⟧</p>

<p>This decomposes the coupled constraint into two independent parts:</p>

<ul>
  <li><strong>Update increment shift</strong> ⟦INLMATH89MATHEND⟧: Deviation of the new policy from the current policy, <strong>controllable by the optimization side</strong></li>
  <li><strong>Sampling staleness</strong> ⟦INLMATH90MATHEND⟧: Deviation of the current policy from each old policy, <strong>must be controlled by the sampling side</strong></li>
</ul>

<p>Define:</p>

<p>⟦DISPMATH17MATHEND⟧</p>

<blockquote>
  <p><strong>Corollary 3.2 (Decomposed Monotonic Improvement Lower Bound)</strong></p>

  <p>⟦DISPMATH7MATHEND⟧</p>
</blockquote>

<p><strong>Why does decomposition solve the problem?</strong> The key is that after decomposition, ⟦INLMATH91MATHEND⟧ only involves the new policy ⟦INLMATH92MATHEND⟧ and the current policy ⟦INLMATH93MATHEND⟧, <strong>completely independent of the structure of the old policy family ⟦INLMATH94MATHEND⟧</strong>. Therefore, regardless of how different the old policies are from each other, constraining ⟦INLMATH95MATHEND⟧ is always feasible—this is precisely the resolution to the infeasibility issue revealed in Observation 3.1.</p>

<p>This reveals an important engineering principle—<strong>separation of concerns</strong>:</p>

<table>
  <thead>
    <tr>
      <th>Control Term</th>
      <th>Responsible Party</th>
      <th>Control Mechanism</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>⟦INLMATH96MATHEND⟧ (update increment shift)</td>
      <td>Optimization algorithm</td>
      <td>Policy clipping</td>
    </tr>
    <tr>
      <td>⟦INLMATH97MATHEND⟧ (sampling staleness)</td>
      <td>Sampling system</td>
      <td>Data filtering, version window</td>
    </tr>
  </tbody>
</table>

<h2 id="part-v-theoretical-foundations-of-clipping-mechanisms">Part V: Theoretical Foundations of Clipping Mechanisms</h2>

<h3 id="51-from-tv-distance-to-computable-quantities">5.1 From TV Distance to Computable Quantities</h3>

<p>Corollary 3.2 tells us that to guarantee monotonic improvement, we need to control the update increment shift ⟦INLMATH98MATHEND⟧. However, TV distance is a distribution-level quantity—how can we control it using samples?</p>

<p>The key bridge is the following identity:</p>

<blockquote>
  <p><strong>Lemma 3.3 (Ratio Difference Representation of TV Distance)</strong></p>

  <p>Suppose policy ⟦INLMATH99MATHEND⟧’s support covers the supports of ⟦INLMATH100MATHEND⟧ and ⟦INLMATH101MATHEND⟧. Then for any state distribution ⟦INLMATH102MATHEND⟧:</p>

  <p>⟦DISPMATH8MATHEND⟧</p>
</blockquote>

<p><strong>Intuitive understanding</strong>: The left side is the TV distance between two distributions (requiring enumeration over all actions), while the right side is the absolute difference of two importance ratios when sampling under ⟦INLMATH103MATHEND⟧. This enables us to estimate and control TV distance using samples.</p>

<h3 id="52-sample-representation-of-inlmath104mathend">5.2 Sample Representation of ⟦INLMATH104MATHEND⟧</h3>

<p>Using Lemma 3.3, setting ⟦INLMATH105MATHEND⟧, ⟦INLMATH106MATHEND⟧, ⟦INLMATH107MATHEND⟧ (the sampling source policy), we obtain:</p>

<p>⟦DISPMATH18MATHEND⟧</p>

<p>Denoting ⟦INLMATH108MATHEND⟧ and ⟦INLMATH109MATHEND⟧, we have:</p>

<p>⟦DISPMATH19MATHEND⟧</p>

<p>This means: <strong>If we can ensure ⟦INLMATH110MATHEND⟧ for each sample, we can guarantee ⟦INLMATH111MATHEND⟧</strong>.</p>

<h3 id="53-two-methods-for-constraining-inlmath112mathend">5.3 Two Methods for Constraining ⟦INLMATH112MATHEND⟧</h3>

<p><strong>Method 1: Direct Constraint on Ratio Difference</strong></p>

<p>For each sample ⟦INLMATH113MATHEND⟧, require:</p>

<p>⟦DISPMATH20MATHEND⟧</p>

<p>The clipping interval is ⟦INLMATH114MATHEND⟧, with <strong>clipping center at ⟦INLMATH115MATHEND⟧ rather than 1</strong>.</p>

<p><strong>Method 2: Constraint on Incremental Ratio</strong></p>

<p>Noting that ⟦INLMATH116MATHEND⟧, we have:</p>

<p>⟦DISPMATH21MATHEND⟧</p>

<p>If we constrain ⟦INLMATH117MATHEND⟧, since ⟦INLMATH118MATHEND⟧, one can show ⟦INLMATH119MATHEND⟧.</p>

<p>This method clips ⟦INLMATH120MATHEND⟧ with center at 1, <strong>completely independent of the old policy ⟦INLMATH121MATHEND⟧</strong>.</p>

<h3 id="54-complete-objective-functions-for-three-clipping-mechanisms">5.4 Complete Objective Functions for Three Clipping Mechanisms</h3>

<p>For comparison, we present the complete objective functions for three clipping mechanisms. Suppose the current sample comes from old policy ⟦INLMATH122MATHEND⟧, and denote:</p>
<ul>
  <li>⟦INLMATH123MATHEND⟧ (new policy’s ratio relative to sampling policy)</li>
  <li>⟦INLMATH124MATHEND⟧ (current policy’s ratio relative to sampling policy)</li>
  <li>⟦INLMATH125MATHEND⟧ (new policy’s incremental ratio relative to current policy)</li>
</ul>

<p><strong>Standard PPO</strong>: Clip ⟦INLMATH126MATHEND⟧ with center at 1</p>

<p>⟦DISPMATH22MATHEND⟧</p>

<p><strong>Method 1</strong>: Clip ⟦INLMATH127MATHEND⟧ with center at ⟦INLMATH128MATHEND⟧</p>

<p>⟦DISPMATH23MATHEND⟧</p>

<p><strong>Method 2</strong>: Clip incremental ratio ⟦INLMATH129MATHEND⟧ with center at 1</p>

<p>⟦DISPMATH24MATHEND⟧</p>

<p>where ⟦INLMATH130MATHEND⟧ is the importance-weighted advantage estimate.</p>

<h3 id="55-comparison-of-three-methods">5.5 Comparison of Three Methods</h3>

<p><strong>Table 5.1　Comparison of Three Clipping Mechanisms</strong></p>

<table>
  <thead>
    <tr>
      <th>Method</th>
      <th>Clipped Variable</th>
      <th>Clipping Center</th>
      <th>Clipping Interval</th>
      <th>Constrained TV Distance</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Standard PPO</td>
      <td>⟦INLMATH131MATHEND⟧</td>
      <td>⟦INLMATH132MATHEND⟧</td>
      <td>⟦INLMATH133MATHEND⟧</td>
      <td>⟦INLMATH134MATHEND⟧</td>
    </tr>
    <tr>
      <td>Method 1</td>
      <td>⟦INLMATH135MATHEND⟧</td>
      <td>⟦INLMATH136MATHEND⟧</td>
      <td>⟦INLMATH137MATHEND⟧</td>
      <td>⟦INLMATH138MATHEND⟧</td>
    </tr>
    <tr>
      <td>Method 2</td>
      <td>⟦INLMATH139MATHEND⟧</td>
      <td>⟦INLMATH140MATHEND⟧</td>
      <td>⟦INLMATH141MATHEND⟧</td>
      <td>⟦INLMATH142MATHEND⟧</td>
    </tr>
  </tbody>
</table>

<p><strong>The Fundamental Problem with Standard PPO Under Multi-Policy Mixture</strong></p>

<p>Standard PPO constrains ⟦INLMATH143MATHEND⟧, requiring the new policy to be simultaneously close to all sampling source policies. By Observation 3.1, when the old policies ⟦INLMATH144MATHEND⟧ differ significantly from each other, <strong>no ⟦INLMATH145MATHEND⟧ can simultaneously satisfy all constraints</strong>. This causes the trust region intersection to shrink or even become empty, with updates being limited by the most stale policy.</p>

<p><strong>Common Advantages of Methods 1 and 2</strong></p>

<p>Both methods constrain ⟦INLMATH146MATHEND⟧—the deviation of the new policy from the <strong>current policy</strong> (rather than the sampling policy). Since ⟦INLMATH147MATHEND⟧ is uniquely determined, this constraint is consistent across all sample sources, completely avoiding the infeasibility problem.</p>

<p><strong>Method 1 vs Method 2</strong></p>

<table>
  <thead>
    <tr>
      <th>Comparison Dimension</th>
      <th>Method 1 (Adaptive Clipping)</th>
      <th>Method 2 (Incremental Clipping)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Stale samples (⟦INLMATH148MATHEND⟧)</td>
      <td>Automatically tightens constraints, more conservative</td>
      <td>May produce large gradient variance</td>
    </tr>
    <tr>
      <td>LLM large vocabulary low-probability tokens</td>
      <td>Allows larger absolute changes (additive)</td>
      <td>Absolute changes are limited (multiplicative)</td>
    </tr>
    <tr>
      <td>Implementation complexity</td>
      <td>Requires storing ⟦INLMATH149MATHEND⟧ and ⟦INLMATH150MATHEND⟧</td>
      <td>Only requires ⟦INLMATH151MATHEND⟧</td>
    </tr>
    <tr>
      <td>Advantage function</td>
      <td>Uses ⟦INLMATH152MATHEND⟧</td>
      <td>Uses weighted advantage ⟦INLMATH153MATHEND⟧</td>
    </tr>
  </tbody>
</table>

<p><strong>Detailed Explanations</strong>:</p>

<p><strong>(1) Handling Stale Samples</strong></p>

<p>When samples come from very old policies, ⟦INLMATH154MATHEND⟧ can be large.</p>

<ul>
  <li>Method 2’s integrand is ⟦INLMATH155MATHEND⟧; even if ⟦INLMATH156MATHEND⟧, the integrand can reach ⟦INLMATH157MATHEND⟧, producing spikes.</li>
  <li>Method 1 directly constrains ⟦INLMATH158MATHEND⟧; the integrand’s upper bound is always ⟦INLMATH159MATHEND⟧, unaffected by ⟦INLMATH160MATHEND⟧ amplification.</li>
</ul>

<p><strong>(2) LLM Large Vocabulary Issue</strong></p>

<p>Large language models have many tokens having very small probabilities.</p>

<ul>
  <li>Method 2 constrains ⟦INLMATH161MATHEND⟧, which is a <strong>multiplicative constraint</strong>: if ⟦INLMATH162MATHEND⟧, the allowed absolute change is only ⟦INLMATH163MATHEND⟧.</li>
  <li>Method 1 constrains ⟦INLMATH164MATHEND⟧, which is an <strong>additive constraint</strong>: if that token has higher probability under the old policy (e.g., ⟦INLMATH165MATHEND⟧), even if the current probability is very low, faster improvement is allowed.</li>
</ul>

<h3 id="56-controlling-sampling-staleness">5.6 Controlling Sampling Staleness</h3>

<p>Corollary 3.2 shows that ⟦INLMATH166MATHEND⟧ also affects the monotonic improvement lower bound, but it <strong>cannot be controlled through optimization-side clipping</strong> and must be implemented by the sampling system:</p>

<p><strong>(1) Discarding Stale Data</strong></p>

<p>Set a threshold ⟦INLMATH167MATHEND⟧. For each sample, compute ⟦INLMATH168MATHEND⟧, and discard samples exceeding the threshold.</p>

<p><strong>(2) Controlling Policy Version Window</strong></p>

<p>Limit the number of old policy versions in the mixture sampling, e.g., using only data from the most recent ⟦INLMATH169MATHEND⟧ versions.</p>

<h3 id="57-operational-meaning-of-clipping">5.7 Operational Meaning of Clipping</h3>

<p>Finally, we clarify the relationship between clipping and the theoretical lower bound.</p>

<p>In Corollary 3.2, the coefficient of ⟦INLMATH170MATHEND⟧, namely ⟦INLMATH171MATHEND⟧, depends on the new policy ⟦INLMATH172MATHEND⟧, so the penalty term <strong>cannot be simply replaced by a constant</strong>. The correct operational meaning is:</p>

<blockquote>
  <p><strong>Maximize the surrogate objective ⟦INLMATH173MATHEND⟧ subject to the constraint ⟦INLMATH174MATHEND⟧</strong></p>
</blockquote>

<p>The clipping objective function is precisely an implementation of this constrained optimization—clipping <strong>hard limits</strong> the update magnitude to ensure ⟦INLMATH175MATHEND⟧ is controllable; under this premise, gradient ascent improves the surrogate objective, thereby providing guarantees for monotonic policy improvement.</p>

<h3 id="58-section-summary">5.8 Section Summary</h3>

<p>This section established the theoretical foundations of clipping mechanisms:</p>

<ol>
  <li><strong>Lemma 3.3</strong> converts TV distance to sample-level ratio differences, serving as the bridge between theory and implementation</li>
  <li><strong>Two constraint methods</strong>: Method 1 (adaptive clipping center) and Method 2 (fixed incremental clipping), both guaranteeing ⟦INLMATH176MATHEND⟧</li>
  <li><strong>Comparison with standard PPO</strong>: Standard PPO constrains ⟦INLMATH177MATHEND⟧, which is infeasible under multi-policy mixture; Methods 1/2 constrain ⟦INLMATH178MATHEND⟧, avoiding this issue</li>
  <li><strong>Method selection</strong>: Method 1 (adaptive) is recommended for high staleness or LLM large vocabulary scenarios; Method 2 (incremental) is recommended when implementation simplicity is prioritized</li>
  <li><strong>⟦INLMATH179MATHEND⟧ control</strong> is the sampling side’s responsibility, implemented through data filtering and version windows</li>
  <li><strong>Clipping is constrained optimization</strong>: Maximize the surrogate objective subject to ⟦INLMATH180MATHEND⟧ constraints</li>
</ol>

<h2 id="part-vi-comparison-of-trajectory-level-and-stepsegment-level-mixture">Part VI: Comparison of Trajectory-Level and Step/Segment-Level Mixture</h2>

<h3 id="61-core-differences-between-the-two-mechanisms">6.1 Core Differences Between the Two Mechanisms</h3>

<p>The essential difference between the two mixture mechanisms lies in the structure of the index transition kernel:</p>

<ul>
  <li><strong>Trajectory-level mixture</strong>: ⟦INLMATH181MATHEND⟧, index never changes</li>
  <li><strong>Step/segment-level mixture</strong>: ⟦INLMATH182MATHEND⟧, allows within-trajectory switching</li>
</ul>

<p>The correspondence with common engineering terminology is:</p>

<ul>
  <li><strong>Trajectory-level mixture</strong> here can be roughly understood as an idealized abstraction of “<strong>conventional asynchronous training</strong>”: data is organized by entire trajectories/episodes belonging to a certain policy version;</li>
  <li><strong>Step/segment-level mixture</strong> here can be roughly understood as an abstraction of “<strong>partial rollout</strong>”: due to asynchrony between actors and learners, and possible refresh to new policy versions at segment boundaries, using an index transition kernel that allows “within-trajectory version switching” can better approximate this phenomenon.</li>
</ul>

<p>The key watershed is <strong>whether Lemma 2.1’s structural simplification holds</strong>: trajectory-level mixture satisfies advantage function reduction; step/segment-level mixture generally does not, because future returns are affected by the index transition kernel.</p>

<h3 id="62-differences-in-sampling-staleness-inlmath183mathend">6.2 Differences in Sampling Staleness ⟦INLMATH183MATHEND⟧</h3>

<p><strong>Trajectory-level mixture</strong>’s staleness arises from: mixture weights ⟦INLMATH184MATHEND⟧ retaining probability mass on old policies after new policy release.</p>

<p><strong>Step/segment-level mixture</strong> has an <strong>exponential compression effect</strong>: Consider a simplified model with switching probability ⟦INLMATH185MATHEND⟧ from old to new. The marginal probability mass on old indices under the discounted visitation distribution is ⟦INLMATH186MATHEND⟧. As long as ⟦INLMATH187MATHEND⟧, the old policy weight can be significantly compressed.</p>

<h3 id="63-differences-in-surrogate-objective-estimation">6.3 Differences in Surrogate Objective Estimation</h3>

<p><strong>Trajectory-level mixture</strong>: The advantage function reduces to ⟦INLMATH188MATHEND⟧, with a clear estimation path.</p>

<p><strong>Advantage substitution bias in step/segment-level mixture</strong>: If single-policy advantage estimates are used, systematic bias will arise. The reason is that ⟦INLMATH189MATHEND⟧ requires taking expectations over future index switching, while ⟦INLMATH190MATHEND⟧ implicitly assumes “the future always follows ⟦INLMATH191MATHEND⟧.”</p>

<p><strong>Unification under bandit setting</strong>: In single-step episode LLM training, with no subsequent state transitions, the estimation problems of both mechanisms unify, with no such bias.</p>

<h3 id="64-variance-amplification-risk">6.4 Variance Amplification Risk</h3>

<p>Step/segment-level mixture has another hidden concern: even if single-step importance ratios are clipped, multi-step noise accumulation over long trajectories can still amplify gradient estimation variance. When policy changes per update are large, “behavioral discontinuities” within trajectories may induce heavier-tailed ratio distributions. This is why trajectory-level mixture is recommended for “large policy change per update” scenarios in the table below.</p>

<h3 id="65-applicable-scenarios">6.5 Applicable Scenarios</h3>

<p><strong>Table 6.1　Applicable Scenarios for Two Mixture Mechanisms</strong></p>

<table>
  <thead>
    <tr>
      <th>Scenario Characteristics</th>
      <th>Recommended Mechanism</th>
      <th>Rationale</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Long trajectories, high-frequency updates, strong asynchrony</td>
      <td>Step/segment-level</td>
      <td>Can significantly compress ⟦INLMATH192MATHEND⟧</td>
    </tr>
    <tr>
      <td>Short trajectories (non-bandit)</td>
      <td>Trajectory-level</td>
      <td>⟦INLMATH193MATHEND⟧ is naturally low</td>
    </tr>
    <tr>
      <td>Large policy change per update</td>
      <td>Trajectory-level</td>
      <td>Avoids variance amplification</td>
    </tr>
    <tr>
      <td>Single-step episode (bandit)</td>
      <td>Either</td>
      <td>Choose based on implementation convenience</td>
    </tr>
    <tr>
      <td>Need for compromise</td>
      <td>Segment-level</td>
      <td>Switch at natural boundaries</td>
    </tr>
  </tbody>
</table>

<p><strong>Core trade-off</strong>: Step/segment-level mixture is stronger on the sampling side (fast staleness removal), while trajectory-level mixture is more stable on the estimation side (easier surrogate objective estimation).</p>

<h2 id="part-vii-handling-training-inference-inconsistency">Part VII: Handling Training-Inference Inconsistency</h2>

<h3 id="71-background">7.1 Background</h3>

<p>In large-scale distributed training, policies on the inference side and training side may be inconsistent:</p>

<ul>
  <li><strong>Numerical implementation differences</strong>: softmax normalization, quantization, kernel fusion</li>
  <li><strong>Decoding rule differences</strong>: temperature scaling, top-p/top-k sampling</li>
</ul>

<p>Let the behavior policy modeled on the training side be ⟦INLMATH194MATHEND⟧, while the policy actually sampling on the inference side is ⟦INLMATH195MATHEND⟧.</p>

<h3 id="72-effective-staleness">7.2 Effective Staleness</h3>

<p>Define <strong>effective staleness</strong>:</p>

<p>⟦DISPMATH25MATHEND⟧</p>

<p>This definition simultaneously covers version staleness and training-inference implementation differences.</p>

<h3 id="73-actionable-control">7.3 Actionable Control</h3>

<p>By Lemma 3.3, ⟦INLMATH196MATHEND⟧ can be expressed in sample-level computable form. Given threshold ⟦INLMATH197MATHEND⟧, if training only uses samples satisfying ⟦INLMATH198MATHEND⟧, then ⟦INLMATH199MATHEND⟧.</p>

<p><strong>Key implementation points</strong>:</p>

<ol>
  <li><strong>Behavior denominator alignment</strong>: The behavior probability in the loss should use the inference-side recorded ⟦INLMATH200MATHEND⟧</li>
  <li><strong>Probability smoothing</strong>: If the inference side has truncation (e.g., top-k), ensure ratios are valid</li>
</ol>

<h2 id="summary-practical-guidelines">Summary: Practical Guidelines</h2>

<h3 id="core-theoretical-framework">Core Theoretical Framework</h3>

<p>The structure of the monotonic improvement lower bound is:</p>

<p>⟦DISPMATH26MATHEND⟧</p>

<h3 id="separation-of-concerns-principle">Separation of Concerns Principle</h3>

<table>
  <thead>
    <tr>
      <th>Control Term</th>
      <th>Responsible Party</th>
      <th>Control Mechanism</th>
      <th>Specific Operation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>⟦INLMATH201MATHEND⟧</td>
      <td>Optimization algorithm</td>
      <td>Policy clipping</td>
      <td>Clip ⟦INLMATH202MATHEND⟧</td>
    </tr>
    <tr>
      <td>⟦INLMATH203MATHEND⟧</td>
      <td>Sampling system</td>
      <td>Data filtering</td>
      <td>Discard stale samples</td>
    </tr>
    <tr>
      <td>⟦INLMATH204MATHEND⟧</td>
      <td>Sampling system</td>
      <td>Version window</td>
      <td>Use only most recent ⟦INLMATH205MATHEND⟧ versions</td>
    </tr>
  </tbody>
</table>

<h3 id="clipping-method-selection">Clipping Method Selection</h3>

<table>
  <thead>
    <tr>
      <th>Scenario</th>
      <th>Recommended Method</th>
      <th>Rationale</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>High staleness</td>
      <td>Method 1 (adaptive)</td>
      <td>Automatically tightens constraints for stale samples</td>
    </tr>
    <tr>
      <td>Implementation simplicity prioritized</td>
      <td>Method 2 (incremental)</td>
      <td>No need to store old policy information</td>
    </tr>
    <tr>
      <td>LLM large vocabulary</td>
      <td>Method 1</td>
      <td>Avoids slow updates for low-probability tokens</td>
    </tr>
  </tbody>
</table>

<h3 id="handling-training-inference-inconsistency">Handling Training-Inference Inconsistency</h3>

<ul>
  <li>Use inference-side recorded ⟦INLMATH206MATHEND⟧ as the behavior denominator</li>
  <li>Compress effective staleness through sample filtering</li>
</ul>

<h2 id="appendix-quick-reference-for-key-symbols">Appendix: Quick Reference for Key Symbols</h2>

<table>
  <thead>
    <tr>
      <th>Symbol</th>
      <th>Meaning</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>⟦INLMATH207MATHEND⟧, ⟦INLMATH208MATHEND⟧</td>
      <td>Latest policy at round ⟦INLMATH209MATHEND⟧, ⟦INLMATH210MATHEND⟧-th old policy</td>
    </tr>
    <tr>
      <td>⟦INLMATH211MATHEND⟧, ⟦INLMATH212MATHEND⟧</td>
      <td>Discounted state visitation distribution, advantage function</td>
    </tr>
    <tr>
      <td>⟦INLMATH213MATHEND⟧</td>
      <td>TV distance between two policies at state ⟦INLMATH214MATHEND⟧</td>
    </tr>
    <tr>
      <td>⟦INLMATH215MATHEND⟧</td>
      <td>Mixture behavior policy at round ⟦INLMATH216MATHEND⟧</td>
    </tr>
    <tr>
      <td>⟦INLMATH217MATHEND⟧, ⟦INLMATH218MATHEND⟧</td>
      <td>Index transition kernel, initial index distribution</td>
    </tr>
    <tr>
      <td>⟦INLMATH219MATHEND⟧, ⟦INLMATH220MATHEND⟧</td>
      <td>Update increment shift, sampling staleness</td>
    </tr>
    <tr>
      <td>⟦INLMATH221MATHEND⟧, ⟦INLMATH222MATHEND⟧, ⟦INLMATH223MATHEND⟧</td>
      <td>Clipping radius, staleness threshold, version window</td>
    </tr>
    <tr>
      <td>⟦INLMATH224MATHEND⟧</td>
      <td>Expected advantage upper bound constant</td>
    </tr>
  </tbody>
</table>

<h2 id="references">References</h2>

<ol>
  <li>
    <p>John Schulman, Sergey Levine, Philipp Moritz, Michael I. Jordan, Pieter Abbeel. “Trust Region Policy Optimization” (TRPO). arXiv:1502.05477. <a href="https://arxiv.org/abs/1502.05477">https://arxiv.org/abs/1502.05477</a></p>
  </li>
  <li>
    <p>Joshua Achiam, David Held, Aviv Tamar, Pieter Abbeel. “Constrained Policy Optimization” (CPO). arXiv:1705.10528. <a href="https://arxiv.org/abs/1705.10528">https://arxiv.org/abs/1705.10528</a></p>
  </li>
  <li>
    <p>John Schulman, Filip Wolski, Prafulla Dhariwal, Alec Radford, Oleg Klimov. “Proximal Policy Optimization Algorithms” (PPO). arXiv:1707.06347. <a href="https://arxiv.org/abs/1707.06347">https://arxiv.org/abs/1707.06347</a></p>
  </li>
  <li>
    <p>James Queeney, Ioannis Ch. Paschalidis, Christos G. Cassandras. “Generalized Proximal Policy Optimization with Sample Reuse” (GePPO). arXiv:2111.00072. <a href="https://arxiv.org/abs/2111.00072">https://arxiv.org/abs/2111.00072</a></p>
  </li>
  <li>
    <p>Yuzhen Zhou, Jiajun Li, Yusheng Su, et al. “APRIL: Active Partial Rollouts in Reinforcement Learning to Tame Long-tail Generation” (APRIL; partial rollout). arXiv:2509.18521. <a href="https://arxiv.org/abs/2509.18521">https://arxiv.org/abs/2509.18521</a></p>
  </li>
  <li>
    <p>Jacob Hilton, Karl Cobbe, John Schulman. “Batch size-invariance for policy optimization” (Decoupled PPO). arXiv:2110.00641. <a href="https://arxiv.org/abs/2110.00641">https://arxiv.org/abs/2110.00641</a></p>
  </li>
</ol>

<div class="language-bibtex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">@misc</span><span class="p">{</span><span class="nl">WangZhang2025OffPolicyLLMRL</span><span class="p">,</span>
	<span class="na">author</span>       <span class="p">=</span> <span class="s">{Wang, Xihuai and Zhang, Shao}</span><span class="p">,</span>
	<span class="na">title</span>        <span class="p">=</span> <span class="s">{Off-Policy Training in LLM Reinforcement Learning: From Theory to Practice}</span><span class="p">,</span>
	<span class="na">year</span>         <span class="p">=</span> <span class="s">{2025}</span><span class="p">,</span>
	<span class="na">month</span>        <span class="p">=</span> <span class="nv">dec</span><span class="p">,</span>
	<span class="na">day</span>          <span class="p">=</span> <span class="s">{17}</span><span class="p">,</span>
	<span class="na">url</span>          <span class="p">=</span> <span class="s">{https://xihuai18.github.io/reinforcement-learning/2025/12/17/offpolicy-en.html}</span><span class="p">,</span>
	<span class="na">urldate</span>      <span class="p">=</span> <span class="s">{2025-12-17}</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="reinforcement-learning" /><summary type="html"><![CDATA[A systematic derivation of off-policy training theory for LLM reinforcement learning: starting from single-policy sampling performance improvement bounds, extending to multi-policy static/dynamic mixture sampling, establishing sufficient conditions for monotonic improvement, decomposing constraints via the triangle inequality into update increment shift (controllable by optimization) and sampling staleness (controllable by sampling), and ultimately translating these into actionable clipping mechanisms and data filtering strategies.]]></summary></entry><entry xml:lang="zh"><title type="html">驯服陈旧数据：LLM 强化学习的异策略训练与单调改进保证</title><link href="https://xihuai18.github.io/reinforcement-learning/2025/12/17/offpolicy-zh.html" rel="alternate" type="text/html" title="驯服陈旧数据：LLM 强化学习的异策略训练与单调改进保证" /><published>2025-12-17T00:00:00+00:00</published><updated>2025-12-17T00:00:00+00:00</updated><id>https://xihuai18.github.io/reinforcement-learning/2025/12/17/offpolicy-zh</id><content type="html" xml:base="https://xihuai18.github.io/reinforcement-learning/2025/12/17/offpolicy-zh.html"><![CDATA[<h2 id="引言为什么我们需要关心异策略">引言：为什么我们需要关心”异策略”？</h2>

<p>想象这样一个场景：你正在用强化学习训练一个大语言模型，让它学会更好地回答问题。理想情况下，每次模型生成一批回答后，你会立即用这些数据更新模型，然后用更新后的模型生成新数据，如此循环往复。这种”用谁的数据就更新谁”的方式叫做<strong>同策略</strong>（on-policy）训练。</p>

<p>但现实没这么简单。在大规模分布式训练中，数百个GPU并行生成数据，而模型更新需要时间。当新模型发布时，很多”旧版本”模型生成的数据还没用完——扔掉太浪费，用起来又担心”数据过时”会影响训练效果。</p>

<p>这就是<strong>异策略</strong>（off-policy）训练面临的核心问题：<strong>用旧策略采集的数据来更新新策略，能保证性能持续提升吗？</strong></p>

<p>本文将系统回答这个问题。我们从基础理论出发，逐步推导出可操作的条件，告诉你：在什么情况下，混合使用多个版本策略的数据仍然能保证训练单调改进。</p>

<h2 id="第一部分理论基础">第一部分：理论基础</h2>

<h3 id="11-基本设定">1.1 基本设定</h3>

<p>我们考虑标准的马尔可夫决策过程（MDP），包含状态空间 ⟦INLMATH27MATHEND⟧、动作空间 ⟦INLMATH28MATHEND⟧、转移概率 ⟦INLMATH29MATHEND⟧、奖励函数 ⟦INLMATH30MATHEND⟧、初始分布 ⟦INLMATH31MATHEND⟧ 和折扣因子 ⟦INLMATH32MATHEND⟧。</p>

<p>策略 ⟦INLMATH33MATHEND⟧ 的<strong>期望累计折扣回报</strong>为：</p>

<p>⟦DISPMATH9MATHEND⟧</p>

<p><strong>折扣状态访问分布</strong>定义为策略长期运行中访问各状态的加权频率：</p>

<p>⟦DISPMATH10MATHEND⟧</p>

<p><strong>优势函数</strong>衡量动作 ⟦INLMATH34MATHEND⟧ 相对于策略平均水平的优劣：</p>

<p>⟦DISPMATH11MATHEND⟧</p>

<p><strong>全变差距离</strong>（TV距离）衡量两个策略在状态 ⟦INLMATH35MATHEND⟧ 上动作分布的差异：</p>

<p>⟦DISPMATH12MATHEND⟧</p>

<h3 id="12-核心工具策略性能差异引理">1.2 核心工具：策略性能差异引理</h3>

<p>整个理论的基石是这个简洁的结论：</p>

<blockquote>
  <p><strong>引理1.1（策略性能差异引理）</strong></p>

  <p>对任意策略 ⟦INLMATH36MATHEND⟧（旧）和 ⟦INLMATH37MATHEND⟧（新），性能差异可表示为：</p>

  <p>⟦DISPMATH1MATHEND⟧</p>
</blockquote>

<p><strong>直观理解</strong>：新策略比旧策略好多少，等于在新策略访问的状态分布下，用新策略选动作能获得的”平均优势”。</p>

<h2 id="第二部分单策略采样的性能改进下界">第二部分：单策略采样的性能改进下界</h2>

<h3 id="21-分布不匹配问题">2.1 分布不匹配问题</h3>

<p>策略性能差异引理有个实际问题：右侧期望在 ⟦INLMATH38MATHEND⟧（新策略的状态分布）下计算，而我们只能从 ⟦INLMATH39MATHEND⟧（旧策略）采样。</p>

<p>解决思路是：把期望拆成”旧分布下的期望 + 偏差项”，然后控制偏差。关键问题是：<strong>状态分布的差异与策略的差异有什么定量关系？</strong></p>

<h3 id="22-状态分布差异的控制">2.2 状态分布差异的控制</h3>

<blockquote>
  <p><strong>引理1.2（状态分布差异与策略TV距离的关系）</strong></p>

  <p>⟦DISPMATH2MATHEND⟧</p>
</blockquote>

<p><strong>物理意义</strong>：策略在动作空间上的小差异，会通过环境动力学”放大”成状态访问分布的差异。系数 ⟦INLMATH40MATHEND⟧ 反映了<strong>时间累积效应</strong>——长时域任务（⟦INLMATH41MATHEND⟧ 接近1）中，放大效应更强。</p>

<p><strong>证明思路</strong>：推导折扣访问分布的不动点方程，利用随机矩阵的 ⟦INLMATH42MATHEND⟧ 非扩张性，可以证明状态分布差异被策略差异通过转移动力学放大，放大系数正是 ⟦INLMATH43MATHEND⟧。</p>

<h3 id="23-策略性能改进下界">2.3 策略性能改进下界</h3>

<blockquote>
  <p><strong>定理1.1（策略性能改进下界）</strong></p>

  <p>定义期望优势上界常数 ⟦INLMATH44MATHEND⟧，则：</p>

  <p>⟦DISPMATH3MATHEND⟧</p>

  <p>其中<strong>代理目标</strong>为：</p>

  <p>⟦DISPMATH4MATHEND⟧</p>
</blockquote>

<p>这个下界由两部分组成：</p>

<ol>
  <li>
    <p><strong>代理目标</strong> ⟦INLMATH45MATHEND⟧：可用旧策略数据通过重要性采样直接估计，是TRPO/PPO的优化目标。</p>
  </li>
  <li>
    <p><strong>策略偏移惩罚</strong>：随新旧策略的TV距离增大而增大，这解释了为何PPO需要限制更新幅度。</p>
  </li>
</ol>

<p><strong>核心结论</strong>：最大化代理目标的同时控制策略偏移，即可保证性能改进。</p>

<h2 id="第三部分多策略静态混合采样">第三部分：多策略静态混合采样</h2>

<h3 id="31-实际场景">3.1 实际场景</h3>

<p>在实际训练中，一个batch的数据可能来自多个策略版本 ⟦INLMATH46MATHEND⟧，各版本占比为 ⟦INLMATH47MATHEND⟧。如何将定理1.1扩展到这种情形？</p>

<h3 id="32-核心思想扩展状态空间">3.2 核心思想：扩展状态空间</h3>

<p>解决方案是一个优雅的建模技巧：<strong>把策略版本索引当作状态的一部分</strong>。</p>

<p>定义扩展状态空间 ⟦INLMATH48MATHEND⟧，其中 ⟦INLMATH49MATHEND⟧ 是策略索引集合。在扩展状态 ⟦INLMATH50MATHEND⟧ 下，<strong>混合行为策略</strong>定义为 ⟦INLMATH51MATHEND⟧。</p>

<p>索引的演化由<strong>索引转移核</strong> ⟦INLMATH52MATHEND⟧ 刻画。扩展MDP继承原始MDP的奖励和环境转移，索引按 ⟦INLMATH53MATHEND⟧ 独立演化。</p>

<p>这个技巧之所以有效，是因为新策略 ⟦INLMATH54MATHEND⟧ 在扩展MDP上的回报等于原始MDP中的回报，从而可以直接应用定理1.1。</p>

<h3 id="33-轨迹级混合的结构简化">3.3 轨迹级混合的结构简化</h3>

<p>最常见的情形是<strong>每条轨迹只用一个旧策略</strong>：轨迹开始时采样索引 ⟦INLMATH55MATHEND⟧，整条轨迹使用 ⟦INLMATH56MATHEND⟧。此时索引转移核为恒等转移：⟦INLMATH57MATHEND⟧。</p>

<p>从工程实现角度看，在很多 <strong>actor-learner 的异步训练</strong>里（如果采样与训练侧把数据按”整条轨迹/完整 episode 归属某个策略版本”来组织），这可以近似对应这里的<strong>轨迹级混合</strong>：actor 在一个采样单元内固定使用某个策略快照生成数据，learner 再混合使用来自不同版本的整轨迹数据做更新。这里用”近似”是因为不同系统对”轨迹/采样单元”的切分边界并不完全一致。</p>

<blockquote>
  <p><strong>引理2.1（轨迹级混合的结构简化）</strong></p>

  <p>(a) 扩展状态访问分布分解为：⟦INLMATH58MATHEND⟧</p>

  <p>(b) 优势函数还原为：⟦INLMATH59MATHEND⟧</p>
</blockquote>

<p><strong>(b)的直觉</strong>：由于索引永不改变，从扩展状态 ⟦INLMATH60MATHEND⟧ 出发的<strong>所有未来轨迹</strong>都由同一个策略 ⟦INLMATH61MATHEND⟧ 生成。因此，未来的累计回报完全由 ⟦INLMATH62MATHEND⟧ 决定，价值函数和优势函数自然还原为 ⟦INLMATH63MATHEND⟧ 的对应量。</p>

<p>由此，混合策略的回报为各旧策略回报的加权平均：⟦INLMATH64MATHEND⟧。</p>

<h3 id="34-轨迹级混合的性能改进下界">3.4 轨迹级混合的性能改进下界</h3>

<blockquote>
  <p><strong>推论2.1（轨迹级混合的性能改进下界）</strong></p>

  <p>⟦DISPMATH5MATHEND⟧</p>
</blockquote>

<p>该结论表明：将多个旧策略版本的轨迹混合训练时，若对每条轨迹用对应旧策略的重要性比率构造损失，同时控制新策略与各旧策略的偏移，则新策略性能有明确的改进下界。</p>

<h2 id="第四部分动态混合采样与单调提升条件">第四部分：动态混合采样与单调提升条件</h2>

<h3 id="41-问题的核心挑战">4.1 问题的核心挑战</h3>

<p>第三部分讨论的是<strong>静态混合</strong>——混合权重 ⟦INLMATH65MATHEND⟧ 固定不变。本节考虑更一般的<strong>动态混合</strong>——新策略发布后，采样逐步由新策略接管。</p>

<p>前面的结论刻画了”新策略相对于混合行为策略”的改进。但在实际训练中，我们真正关心的是：<strong>每轮更新后的最新策略 ⟦INLMATH66MATHEND⟧ 相对于上一轮最新策略 ⟦INLMATH67MATHEND⟧ 是否单调提升？</strong></p>

<p>⟦DISPMATH13MATHEND⟧</p>

<h3 id="42-统一建模框架">4.2 统一建模框架</h3>

<p>动态混合采样的两种典型形式都可以用索引转移核 ⟦INLMATH68MATHEND⟧ 统一刻画：</p>

<p><strong>轨迹级混合</strong>（可类比为常规异步训练的一个抽象；索引恒等转移）：⟦INLMATH69MATHEND⟧</p>

<p><strong>步/段级混合</strong>（partial rollout / 段式采样的一个抽象；允许切换）：⟦INLMATH70MATHEND⟧</p>

<p>其中 ⟦INLMATH71MATHEND⟧ 为切换概率，⟦INLMATH72MATHEND⟧ 为目标索引分布。</p>

<h3 id="43-核心分解">4.3 核心分解</h3>

<p>通过引入混合回报 ⟦INLMATH73MATHEND⟧ 作为中间桥梁，性能差异分解为：</p>

<p>⟦DISPMATH14MATHEND⟧</p>

<p>第一项可用定理1.1处理。第二项是<strong>混合偏差项</strong>，可以证明它满足：</p>

<p>⟦DISPMATH15MATHEND⟧</p>

<h3 id="44-单调提升下界">4.4 单调提升下界</h3>

<p>合并上述结果，得到核心定理：</p>

<blockquote>
  <p><strong>定理3.1（动态混合采样下的单调提升下界）</strong></p>

  <p>⟦DISPMATH6MATHEND⟧</p>
</blockquote>

<p>该下界揭示了<strong>双重控制</strong>的必要性：</p>
<ul>
  <li><strong>更新偏移惩罚</strong>：新策略 ⟦INLMATH74MATHEND⟧ 相对采样来源策略 ⟦INLMATH75MATHEND⟧ 的偏移</li>
  <li><strong>采样陈旧性惩罚</strong>：采样来源策略 ⟦INLMATH76MATHEND⟧ 相对当前策略 ⟦INLMATH77MATHEND⟧ 的陈旧性</li>
</ul>

<h3 id="45-直接约束的不可行性">4.5 直接约束的不可行性</h3>

<p>定理3.1中的更新偏移惩罚项看似可以通过约束 ⟦INLMATH78MATHEND⟧ 来控制，但这实际上<strong>不可行</strong>：</p>

<blockquote>
  <p><strong>观察3.1（更新偏移约束的不可行性）</strong></p>

  <p>设混合采样包含两个旧策略 ⟦INLMATH79MATHEND⟧ 和 ⟦INLMATH80MATHEND⟧，若存在某状态 ⟦INLMATH81MATHEND⟧ 使 ⟦INLMATH82MATHEND⟧，则不存在策略 ⟦INLMATH83MATHEND⟧ 同时满足 ⟦INLMATH84MATHEND⟧ 与 ⟦INLMATH85MATHEND⟧。</p>
</blockquote>

<p><strong>证明</strong>：由三角不等式，若同时满足两约束，则 ⟦INLMATH86MATHEND⟧，矛盾。</p>

<p><strong>问题根源</strong>：更新偏移惩罚项将 ⟦INLMATH87MATHEND⟧ 与历史策略族 ⟦INLMATH88MATHEND⟧ 直接耦合，而后者的内部结构是历史训练的产物，不受当前更新控制。</p>

<h3 id="46-三角不等式分解">4.6 三角不等式分解</h3>

<p>解决方案是利用TV距离的三角不等式：</p>

<p>⟦DISPMATH16MATHEND⟧</p>

<p>这将耦合约束拆分为两个独立部分：</p>

<ul>
  <li><strong>更新增量偏移</strong> ⟦INLMATH89MATHEND⟧：新策略相对当前策略的偏离，<strong>可由优化侧控制</strong></li>
  <li><strong>采样陈旧性</strong> ⟦INLMATH90MATHEND⟧：当前策略相对各旧策略的偏离，<strong>需由采样侧控制</strong></li>
</ul>

<p>定义：</p>

<p>⟦DISPMATH17MATHEND⟧</p>

<blockquote>
  <p><strong>推论3.2（分解后的单调提升下界）</strong></p>

  <p>⟦DISPMATH7MATHEND⟧</p>
</blockquote>

<p><strong>为何分解能解决问题？</strong> 关键在于：分解后的 ⟦INLMATH91MATHEND⟧ 只涉及新策略 ⟦INLMATH92MATHEND⟧ 和当前策略 ⟦INLMATH93MATHEND⟧，<strong>与旧策略族 ⟦INLMATH94MATHEND⟧ 的结构完全无关</strong>。因此，无论旧策略之间差异多大，约束 ⟦INLMATH95MATHEND⟧ 都是可行的——这正是观察3.1揭示的不可行性问题的解决之道。</p>

<p>这揭示了重要的工程原则——<strong>职责分离</strong>：</p>

<table>
  <thead>
    <tr>
      <th>控制项</th>
      <th>负责方</th>
      <th>控制手段</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>⟦INLMATH96MATHEND⟧（更新增量偏移）</td>
      <td>优化算法</td>
      <td>策略裁剪</td>
    </tr>
    <tr>
      <td>⟦INLMATH97MATHEND⟧（采样陈旧性）</td>
      <td>采样系统</td>
      <td>数据过滤、版本窗口</td>
    </tr>
  </tbody>
</table>

<h2 id="第五部分裁剪机制的理论基础">第五部分：裁剪机制的理论基础</h2>

<h3 id="51-从tv距离到可计算量">5.1 从TV距离到可计算量</h3>

<p>推论3.2告诉我们，要保证单调提升，需要控制更新增量偏移 ⟦INLMATH98MATHEND⟧。但TV距离是分布层面的量，如何用样本来控制它？</p>

<p>关键桥梁是下面这个恒等式：</p>

<blockquote>
  <p><strong>引理3.3（TV距离的比值差表示）</strong></p>

  <p>设策略 ⟦INLMATH99MATHEND⟧ 的支撑覆盖 ⟦INLMATH100MATHEND⟧ 和 ⟦INLMATH101MATHEND⟧ 的支撑，则对任意状态分布 ⟦INLMATH102MATHEND⟧：</p>

  <p>⟦DISPMATH8MATHEND⟧</p>
</blockquote>

<p><strong>直观理解</strong>：左边是两个分布的TV距离（需要遍历所有动作），右边是在 ⟦INLMATH103MATHEND⟧ 下采样时两个重要性比值的差的绝对值。这使得我们可以用样本来估计和控制TV距离。</p>

<h3 id="52-inlmath104mathend-的样本表示">5.2 ⟦INLMATH104MATHEND⟧ 的样本表示</h3>

<p>利用引理3.3，取 ⟦INLMATH105MATHEND⟧，⟦INLMATH106MATHEND⟧，⟦INLMATH107MATHEND⟧（采样来源策略），可得：</p>

<p>⟦DISPMATH18MATHEND⟧</p>

<p>记 ⟦INLMATH108MATHEND⟧ 和 ⟦INLMATH109MATHEND⟧，则：</p>

<p>⟦DISPMATH19MATHEND⟧</p>

<p>这意味着：<strong>如果我们能让每个样本上 ⟦INLMATH110MATHEND⟧，就能保证 ⟦INLMATH111MATHEND⟧</strong>。</p>

<h3 id="53-两种约束-inlmath112mathend-的方法">5.3 两种约束 ⟦INLMATH112MATHEND⟧ 的方法</h3>

<p><strong>方法一：直接约束比值差</strong></p>

<p>对每个样本 ⟦INLMATH113MATHEND⟧，要求：</p>

<p>⟦DISPMATH20MATHEND⟧</p>

<p>即裁剪区间为 ⟦INLMATH114MATHEND⟧，<strong>裁剪中心是 ⟦INLMATH115MATHEND⟧ 而非 1</strong>。</p>

<p><strong>方法二：约束增量比值</strong></p>

<p>注意到 ⟦INLMATH116MATHEND⟧，因此：</p>

<p>⟦DISPMATH21MATHEND⟧</p>

<p>如果约束 ⟦INLMATH117MATHEND⟧，由于 ⟦INLMATH118MATHEND⟧，可证 ⟦INLMATH119MATHEND⟧。</p>

<p>这种方法直接对 ⟦INLMATH120MATHEND⟧ 以 1 为中心裁剪，<strong>完全不涉及旧策略 ⟦INLMATH121MATHEND⟧</strong>，我们给出三种裁剪机制的完整目标函数。设当前样本来自旧策略 ⟦INLMATH122MATHEND⟧，记：</p>
<ul>
  <li>⟦INLMATH123MATHEND⟧（新策略相对采样策略的比值）</li>
  <li>⟦INLMATH124MATHEND⟧（当前策略相对采样策略的比值）</li>
  <li>⟦INLMATH125MATHEND⟧（新策略相对当前策略的增量比值）</li>
</ul>

<p><strong>标准PPO</strong>：以 1 为中心裁剪 ⟦INLMATH126MATHEND⟧</p>

<p>⟦DISPMATH22MATHEND⟧</p>

<p><strong>方法一</strong>：以 ⟦INLMATH127MATHEND⟧ 为中心裁剪 ⟦INLMATH128MATHEND⟧</p>

<p>⟦DISPMATH23MATHEND⟧</p>

<p><strong>方法二</strong>：以 1 为中心裁剪增量比值 ⟦INLMATH129MATHEND⟧</p>

<p>⟦DISPMATH24MATHEND⟧</p>

<p>其中 ⟦INLMATH130MATHEND⟧ 是经过重要性加权的优势估计。</p>

<h3 id="55-三种方法的对比">5.5 三种方法的对比</h3>

<p><strong>表5.1　三种裁剪机制的对比</strong></p>

<table>
  <thead>
    <tr>
      <th>方法</th>
      <th>裁剪变量</th>
      <th>裁剪中心</th>
      <th>裁剪区间</th>
      <th>约束的TV距离</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>标准PPO</td>
      <td>⟦INLMATH131MATHEND⟧</td>
      <td>⟦INLMATH132MATHEND⟧</td>
      <td>⟦INLMATH133MATHEND⟧</td>
      <td>⟦INLMATH134MATHEND⟧</td>
    </tr>
    <tr>
      <td>方法一</td>
      <td>⟦INLMATH135MATHEND⟧</td>
      <td>⟦INLMATH136MATHEND⟧</td>
      <td>⟦INLMATH137MATHEND⟧</td>
      <td>⟦INLMATH138MATHEND⟧</td>
    </tr>
    <tr>
      <td>方法二</td>
      <td>⟦INLMATH139MATHEND⟧</td>
      <td>⟦INLMATH140MATHEND⟧</td>
      <td>⟦INLMATH141MATHEND⟧</td>
      <td>⟦INLMATH142MATHEND⟧</td>
    </tr>
  </tbody>
</table>

<p><strong>标准PPO在多策略混合下的根本问题</strong></p>

<p>标准PPO约束 ⟦INLMATH143MATHEND⟧，要求新策略同时接近所有采样来源策略。由观察3.1，当各旧策略 ⟦INLMATH144MATHEND⟧ 之间差异显著时，<strong>不存在能同时满足所有约束的 ⟦INLMATH145MATHEND⟧</strong>。这导致信赖域交集收缩甚至为空，更新被最陈旧的策略所限制。</p>

<p><strong>方法一与方法二的共同优势</strong></p>

<p>两者都约束 ⟦INLMATH146MATHEND⟧——新策略相对<strong>当前策略</strong>（而非采样策略）的偏离。由于 ⟦INLMATH147MATHEND⟧ 是唯一确定的，这个约束对所有来源的样本一致，完全规避了不可行性问题。</p>

<p><strong>方法一 vs 方法二</strong></p>

<table>
  <thead>
    <tr>
      <th>比较维度</th>
      <th>方法一（自适应裁剪）</th>
      <th>方法二（增量裁剪）</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>陈旧样本（⟦INLMATH148MATHEND⟧）</td>
      <td>自动收紧约束，更保守</td>
      <td>可能产生大梯度方差</td>
    </tr>
    <tr>
      <td>LLM大词表低概率token</td>
      <td>允许较大绝对变化（加法型）</td>
      <td>绝对变化受限（乘法型）</td>
    </tr>
    <tr>
      <td>实现复杂度</td>
      <td>需存储 ⟦INLMATH149MATHEND⟧ 和 ⟦INLMATH150MATHEND⟧</td>
      <td>仅需 ⟦INLMATH151MATHEND⟧</td>
    </tr>
    <tr>
      <td>优势函数</td>
      <td>使用 ⟦INLMATH152MATHEND⟧</td>
      <td>使用加权优势 ⟦INLMATH153MATHEND⟧</td>
    </tr>
  </tbody>
</table>

<p><strong>详细解释</strong>：</p>

<p><strong>(一) 陈旧样本处理</strong></p>

<p>当样本来自很旧的策略时，⟦INLMATH154MATHEND⟧ 可能很大。</p>

<ul>
  <li>方法二的被积函数为 ⟦INLMATH155MATHEND⟧，即便 ⟦INLMATH156MATHEND⟧，被积函数仍可达 ⟦INLMATH157MATHEND⟧，产生尖峰。</li>
  <li>方法一直接约束 ⟦INLMATH158MATHEND⟧，被积函数上界恒为 ⟦INLMATH159MATHEND⟧，不受 ⟦INLMATH160MATHEND⟧ 放大。</li>
</ul>

<p><strong>(二) LLM大词表问题</strong></p>

<p>大语言模型词表规模巨大，大量token概率极小。</p>

<ul>
  <li>方法二约束 ⟦INLMATH161MATHEND⟧，这是<strong>乘法型约束</strong>：若 ⟦INLMATH162MATHEND⟧，允许的绝对变化仅为 ⟦INLMATH163MATHEND⟧。</li>
  <li>方法一约束 ⟦INLMATH164MATHEND⟧，这是<strong>加法型约束</strong>：若该token在旧策略下概率较高（如 ⟦INLMATH165MATHEND⟧），即便当前概率很低，也允许较快提升。</li>
</ul>

<h3 id="56-采样陈旧性的控制">5.6 采样陈旧性的控制</h3>

<p>推论3.2表明，⟦INLMATH166MATHEND⟧ 同样影响单调提升下界，但它<strong>无法通过优化侧裁剪控制</strong>，需由采样系统实现：</p>

<p><strong>(一) 丢弃陈旧数据</strong></p>

<p>设定阈值 ⟦INLMATH167MATHEND⟧，对每个样本计算 ⟦INLMATH168MATHEND⟧，丢弃超过阈值者。</p>

<p><strong>(二) 控制策略版本窗口</strong></p>

<p>限制混合采样的旧策略版本数量，如仅用最近 ⟦INLMATH169MATHEND⟧ 个版本的数据。</p>

<h3 id="57-裁剪的操作含义">5.7 裁剪的操作含义</h3>

<p>最后，需要澄清裁剪与理论下界的关系。</p>

<p>推论3.2中，⟦INLMATH170MATHEND⟧ 的系数 ⟦INLMATH171MATHEND⟧ 依赖于新策略 ⟦INLMATH172MATHEND⟧，因此惩罚项<strong>不能简单替换为常数</strong>。正确的操作含义是：</p>

<blockquote>
  <p><strong>在 ⟦INLMATH173MATHEND⟧ 的约束下，最大化代理目标 ⟦INLMATH174MATHEND⟧</strong></p>
</blockquote>

<p>裁剪目标函数正是这一约束优化的实现——通过裁剪<strong>硬性限制</strong>更新幅度，确保 ⟦INLMATH175MATHEND⟧ 可控；在此前提下，梯度上升提升代理目标，从而为策略单调改进提供保障。</p>

<h3 id="58-本节小结">5.8 本节小结</h3>

<p>本节建立了裁剪机制的理论基础：</p>

<ol>
  <li><strong>引理3.3</strong>将TV距离转化为样本层面的比值差，是连接理论与实现的桥梁</li>
  <li><strong>两种约束方法</strong>：方法一（自适应裁剪中心）和方法二（固定增量裁剪），均保证 ⟦INLMATH176MATHEND⟧</li>
  <li><strong>与标准PPO对比</strong>：标准PPO约束 ⟦INLMATH177MATHEND⟧，在多策略混合下不可行；方法一/二约束 ⟦INLMATH178MATHEND⟧，规避了该问题</li>
  <li><strong>方法选择</strong>：陈旧性高或LLM大词表场景推荐方法一；实现简洁优先推荐方法二</li>
  <li><strong>⟦INLMATH179MATHEND⟧ 的控制</strong>由采样侧负责，通过数据过滤和版本窗口实现</li>
  <li><strong>裁剪是约束优化</strong>：在 ⟦INLMATH180MATHEND⟧ 约束下最大化代理目标</li>
</ol>

<h2 id="第六部分轨迹级与步段级混合的比较">第六部分：轨迹级与步/段级混合的比较</h2>

<h3 id="61-两类机制的核心差异">6.1 两类机制的核心差异</h3>

<p>两类混合机制的本质区别在于索引转移核的结构：</p>

<ul>
  <li><strong>轨迹级混合</strong>：⟦INLMATH181MATHEND⟧，索引永不改变</li>
  <li><strong>步/段级混合</strong>：⟦INLMATH182MATHEND⟧，允许轨迹内切换</li>
</ul>

<p>与常见工程术语的对应关系是：</p>

<ul>
  <li>这里的<strong>轨迹级混合</strong>可以大致理解为”<strong>常规异步训练</strong>“的一个理想化抽象：数据按整条轨迹/episode 归属到某个策略版本；</li>
  <li>这里的<strong>步/段级混合</strong>可以大致理解为”<strong>partial rollout</strong>“的一个抽象：由于 actor 与 learner 异步、且 segment 边界处可能刷新到新策略版本，用索引转移核允许”轨迹内部版本切换”可以更好地近似刻画这种现象。</li>
</ul>

<p>关键分水岭是<strong>引理2.1的结构简化是否成立</strong>：轨迹级混合满足优势函数还原；步/段级混合一般不满足，因为未来回报受索引转移核影响。</p>

<h3 id="62-采样陈旧性-inlmath183mathend-的差异">6.2 采样陈旧性 ⟦INLMATH183MATHEND⟧ 的差异</h3>

<p><strong>轨迹级混合</strong>的陈旧性来源于：混合权重 ⟦INLMATH184MATHEND⟧ 在新策略发布后仍对旧策略保留质量。</p>

<p><strong>步/段级混合</strong>具有<strong>指数压缩效应</strong>：考虑从旧到新以概率 ⟦INLMATH185MATHEND⟧ 切换的简化模型，折扣访问分布下旧索引的边缘质量为 ⟦INLMATH186MATHEND⟧。只要 ⟦INLMATH187MATHEND⟧，旧策略权重即可被显著压缩。</p>

<h3 id="63-代理目标估计的差异">6.3 代理目标估计的差异</h3>

<p><strong>轨迹级混合</strong>：优势函数还原为 ⟦INLMATH188MATHEND⟧，估计路径清晰。</p>

<p><strong>步/段级混合的优势替代偏差</strong>：若沿用单策略优势估计，将产生系统性偏差。原因是 ⟦INLMATH189MATHEND⟧ 需要对未来索引切换取期望，而 ⟦INLMATH190MATHEND⟧ 隐含”未来始终沿用 ⟦INLMATH191MATHEND⟧”的假设。</p>

<p><strong>Bandit设定下的统一</strong>：在单步episode的LLM训练中，无后续状态转移，两类机制的估计问题统一，无上述偏差。</p>

<h3 id="64-方差放大风险">6.4 方差放大风险</h3>

<p>步/段级混合还有一个隐患：即便单步重要性比值被裁剪，长轨迹下多步噪声叠加仍会放大梯度估计方差。当每次更新的策略变化幅度较大时，轨迹内部的”行为突变”可能引发更重尾的比值分布。这也是下表中”策略变化幅度大”场景推荐轨迹级混合的原因。</p>

<h3 id="65-适用场景">6.5 适用场景</h3>

<p><strong>表6.1　两类混合机制的适用场景</strong></p>

<table>
  <thead>
    <tr>
      <th>场景特征</th>
      <th>推荐机制</th>
      <th>理由</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>长轨迹、高频更新、强异步</td>
      <td>步/段级</td>
      <td>可显著压缩 ⟦INLMATH192MATHEND⟧</td>
    </tr>
    <tr>
      <td>短轨迹（非Bandit）</td>
      <td>轨迹级</td>
      <td>⟦INLMATH193MATHEND⟧ 自然较低</td>
    </tr>
    <tr>
      <td>每次更新策略变化幅度大</td>
      <td>轨迹级</td>
      <td>避免方差放大</td>
    </tr>
    <tr>
      <td>单步episode（Bandit）</td>
      <td>均可</td>
      <td>按实现便利选择</td>
    </tr>
    <tr>
      <td>需要折中方案</td>
      <td>段级</td>
      <td>在自然边界切换</td>
    </tr>
  </tbody>
</table>

<p><strong>核心权衡</strong>：步/段级混合在采样侧更强（快速去陈旧），轨迹级混合在估计侧更稳（代理目标易估计）。</p>

<h2 id="第七部分训推不一致的处理">第七部分：训推不一致的处理</h2>

<h3 id="71-问题背景">7.1 问题背景</h3>

<p>在大规模分布式训练中，推理端和训练端的策略可能不一致：</p>

<ul>
  <li><strong>数值实现差异</strong>：softmax归一化、量化、核融合</li>
  <li><strong>解码规则差异</strong>：温度缩放、top-p/top-k采样</li>
</ul>

<p>设训练侧建模的行为策略为 ⟦INLMATH194MATHEND⟧，而推理端实际采样的策略为 ⟦INLMATH195MATHEND⟧。</p>

<h3 id="72-有效陈旧性">7.2 有效陈旧性</h3>

<p>定义<strong>有效陈旧性</strong>：</p>

<p>⟦DISPMATH25MATHEND⟧</p>

<p>该定义同时覆盖版本陈旧性与训推实现差异。</p>

<h3 id="73-可操作控制">7.3 可操作控制</h3>

<p>由引理3.3，⟦INLMATH196MATHEND⟧ 可表示为样本级可计算形式。给定阈值 ⟦INLMATH197MATHEND⟧，若训练仅使用满足 ⟦INLMATH198MATHEND⟧ 的样本，则 ⟦INLMATH199MATHEND⟧。</p>

<p><strong>关键实现要点</strong>：</p>

<ol>
  <li><strong>行为分母对齐</strong>：损失中的行为概率应使用推理端记录的 ⟦INLMATH200MATHEND⟧</li>
  <li><strong>概率平滑</strong>：若推理端有截断（如top-k），需确保比值合法</li>
</ol>

<h2 id="总结实践指南">总结：实践指南</h2>

<h3 id="核心理论框架">核心理论框架</h3>

<p>单调提升下界的结构为：</p>

<p>⟦DISPMATH26MATHEND⟧</p>

<h3 id="职责分离原则">职责分离原则</h3>

<table>
  <thead>
    <tr>
      <th>控制项</th>
      <th>负责方</th>
      <th>控制手段</th>
      <th>具体操作</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>⟦INLMATH201MATHEND⟧</td>
      <td>优化算法</td>
      <td>策略裁剪</td>
      <td>对 ⟦INLMATH202MATHEND⟧ 裁剪</td>
    </tr>
    <tr>
      <td>⟦INLMATH203MATHEND⟧</td>
      <td>采样系统</td>
      <td>数据过滤</td>
      <td>丢弃陈旧样本</td>
    </tr>
    <tr>
      <td>⟦INLMATH204MATHEND⟧</td>
      <td>采样系统</td>
      <td>版本窗口</td>
      <td>仅用最近 ⟦INLMATH205MATHEND⟧ 个版本</td>
    </tr>
  </tbody>
</table>

<h3 id="裁剪方法选择">裁剪方法选择</h3>

<table>
  <thead>
    <tr>
      <th>场景</th>
      <th>推荐方法</th>
      <th>理由</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>陈旧性较高</td>
      <td>方法一（自适应）</td>
      <td>自动对陈旧样本收紧约束</td>
    </tr>
    <tr>
      <td>实现简洁优先</td>
      <td>方法二（增量）</td>
      <td>无需存储旧策略信息</td>
    </tr>
    <tr>
      <td>LLM大词表</td>
      <td>方法一</td>
      <td>避免低概率token更新过慢</td>
    </tr>
  </tbody>
</table>

<h3 id="训推不一致处理">训推不一致处理</h3>

<ul>
  <li>使用推理端记录的 ⟦INLMATH206MATHEND⟧ 作为行为分母</li>
  <li>通过样本过滤压缩有效陈旧性</li>
</ul>

<h2 id="附录关键符号速查表">附录：关键符号速查表</h2>

<table>
  <thead>
    <tr>
      <th>符号</th>
      <th>含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>⟦INLMATH207MATHEND⟧, ⟦INLMATH208MATHEND⟧</td>
      <td>第 ⟦INLMATH209MATHEND⟧ 轮最新策略，第 ⟦INLMATH210MATHEND⟧ 个旧策略</td>
    </tr>
    <tr>
      <td>⟦INLMATH211MATHEND⟧, ⟦INLMATH212MATHEND⟧</td>
      <td>折扣状态访问分布，优势函数</td>
    </tr>
    <tr>
      <td>⟦INLMATH213MATHEND⟧</td>
      <td>两策略在状态 ⟦INLMATH214MATHEND⟧ 上的TV距离</td>
    </tr>
    <tr>
      <td>⟦INLMATH215MATHEND⟧</td>
      <td>第 ⟦INLMATH216MATHEND⟧ 轮混合行为策略</td>
    </tr>
    <tr>
      <td>⟦INLMATH217MATHEND⟧, ⟦INLMATH218MATHEND⟧</td>
      <td>索引转移核，索引初始分布</td>
    </tr>
    <tr>
      <td>⟦INLMATH219MATHEND⟧, ⟦INLMATH220MATHEND⟧</td>
      <td>更新增量偏移，采样陈旧性</td>
    </tr>
    <tr>
      <td>⟦INLMATH221MATHEND⟧, ⟦INLMATH222MATHEND⟧, ⟦INLMATH223MATHEND⟧</td>
      <td>裁剪半径，陈旧性阈值，版本窗口</td>
    </tr>
    <tr>
      <td>⟦INLMATH224MATHEND⟧</td>
      <td>期望优势上界常数</td>
    </tr>
  </tbody>
</table>

<h2 id="参考文献">参考文献</h2>

<ol>
  <li>
    <p>John Schulman, Sergey Levine, Philipp Moritz, Michael I. Jordan, Pieter Abbeel. “Trust Region Policy Optimization” (TRPO). arXiv:1502.05477. <a href="https://arxiv.org/abs/1502.05477">https://arxiv.org/abs/1502.05477</a></p>
  </li>
  <li>
    <p>Joshua Achiam, David Held, Aviv Tamar, Pieter Abbeel. “Constrained Policy Optimization” (CPO). arXiv:1705.10528. <a href="https://arxiv.org/abs/1705.10528">https://arxiv.org/abs/1705.10528</a></p>
  </li>
  <li>
    <p>John Schulman, Filip Wolski, Prafulla Dhariwal, Alec Radford, Oleg Klimov. “Proximal Policy Optimization Algorithms” (PPO). arXiv:1707.06347. <a href="https://arxiv.org/abs/1707.06347">https://arxiv.org/abs/1707.06347</a></p>
  </li>
  <li>
    <p>James Queeney, Ioannis Ch. Paschalidis, Christos G. Cassandras. “Generalized Proximal Policy Optimization with Sample Reuse” (GePPO). arXiv:2111.00072. <a href="https://arxiv.org/abs/2111.00072">https://arxiv.org/abs/2111.00072</a></p>
  </li>
  <li>
    <p>Yuzhen Zhou, Jiajun Li, Yusheng Su, et al. “APRIL: Active Partial Rollouts in Reinforcement Learning to Tame Long-tail Generation” (APRIL; partial rollout). arXiv:2509.18521. <a href="https://arxiv.org/abs/2509.18521">https://arxiv.org/abs/2509.18521</a></p>
  </li>
  <li>
    <p>Jacob Hilton, Karl Cobbe, John Schulman. “Batch size-invariance for policy optimization” (Decoupled PPO). arXiv:2110.00641. <a href="https://arxiv.org/abs/2110.00641">https://arxiv.org/abs/2110.00641</a></p>
  </li>
</ol>

<div class="language-bibtex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">@misc</span><span class="p">{</span><span class="nl">WangZhang2025OffPolicyLLMRL</span><span class="p">,</span>
	<span class="na">author</span>       <span class="p">=</span> <span class="s">{Wang, Xihuai and Zhang, Shao}</span><span class="p">,</span>
	<span class="na">title</span>        <span class="p">=</span> <span class="s">{Off-Policy Training in LLM Reinforcement Learning: From Theory to Practice}</span><span class="p">,</span>
	<span class="na">year</span>         <span class="p">=</span> <span class="s">{2025}</span><span class="p">,</span>
	<span class="na">month</span>        <span class="p">=</span> <span class="nv">dec</span><span class="p">,</span>
	<span class="na">day</span>          <span class="p">=</span> <span class="s">{17}</span><span class="p">,</span>
	<span class="na">url</span>          <span class="p">=</span> <span class="s">{https://xihuai18.github.io/reinforcement-learning/2025/12/17/offpolicy-en.html}</span><span class="p">,</span>
	<span class="na">urldate</span>      <span class="p">=</span> <span class="s">{2025-12-17}</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="reinforcement-learning" /><summary type="html"><![CDATA[系统推导大模型强化学习中的异策略训练理论：从单策略采样的性能改进下界出发，扩展到多策略静态/动态混合采样，给出单调提升的充分条件，并通过三角不等式分解将约束拆分为更新增量偏移（优化侧可控）与采样陈旧性（采样侧可控）两部分，最终落地为可操作的裁剪机制与数据过滤策略。]]></summary></entry><entry xml:lang="en"><title type="html">Understanding KL Divergence Estimators in RL: From Value Approximation to Gradient Estimation</title><link href="https://xihuai18.github.io/reinforcement-learning/2025/12/01/kl-estimators-en.html" rel="alternate" type="text/html" title="Understanding KL Divergence Estimators in RL: From Value Approximation to Gradient Estimation" /><published>2025-12-01T00:00:00+00:00</published><updated>2025-12-01T00:00:00+00:00</updated><id>https://xihuai18.github.io/reinforcement-learning/2025/12/01/kl-estimators-en</id><content type="html" xml:base="https://xihuai18.github.io/reinforcement-learning/2025/12/01/kl-estimators-en.html"><![CDATA[<p><img src="/assets/img/kl-estimators/kl-estimator-en.png" alt="Mini-class" style="display:block;margin:0 auto;width:95%;max-width:100%;" /></p>

<blockquote>
  <p>How we approximate KL divergence directly affects training stability. This post systematically analyzes three estimators ⟦INLMATH37MATHEND⟧ in both on-policy and off-policy scenarios, and gives practical guidelines for choosing them when KL is used as a reward penalty versus when it is used as a loss for backpropagation.</p>
</blockquote>

<h2 id="introduction-what-kl-does-in-rl">Introduction: What KL Does in RL</h2>

<p>In policy optimization (PPO, GRPO, etc.) and alignment training (RLHF/RLAIF), <strong>KL penalty</strong> keeps the new policy from drifting too far from a reference policy, preventing instability or collapse. However, implementing KL penalty involves multiple layers of choices: <strong>which estimator</strong> (⟦INLMATH38MATHEND⟧, ⟦INLMATH39MATHEND⟧, ⟦INLMATH40MATHEND⟧), <strong>who to sample from</strong> (on-policy vs off-policy), and <strong>how to use it</strong> (as reward shaping or as a loss for backpropagation). This post systematically dissects these choices and their interrelationships.</p>

<h3 id="forward-vs-reverse-kl">Forward vs. reverse KL</h3>

<p>Let ⟦INLMATH41MATHEND⟧ be the current actor, ⟦INLMATH42MATHEND⟧ the reference policy. The two directions are:</p>

<p><strong>Reverse KL:</strong>
⟦DISPMATH1MATHEND⟧</p>

<figure style="text-align:center;">
<img src="/assets/img/kl-estimators/kl-estimator-reverse.png" style="width:80%;max-width:100%;" />
<figcaption style="font-size:0.9em;color:gray;">Image source: <a href="https://dibyaghosh.com/blog/probability/kldivergence/">Dibya Ghosh's Blog</a></figcaption>
</figure>

<p><strong>Forward KL:</strong>
⟦DISPMATH2MATHEND⟧</p>

<figure style="text-align:center;">
<img src="/assets/img/kl-estimators/kl-estimator-forward.png" style="width:80%;max-width:100%;" />
<figcaption style="font-size:0.9em;color:gray;">Image source: <a href="https://dibyaghosh.com/blog/probability/kldivergence/">Dibya Ghosh's Blog</a></figcaption>
</figure>

<p><strong>Intuition:</strong></p>
<ul>
  <li><strong>Reverse KL</strong> is mode-seeking: policy concentrates on high-probability regions of ⟦INLMATH43MATHEND⟧, possibly sacrificing diversity.</li>
  <li><strong>Forward KL</strong> is mass-covering: policy tries to cover the support of ⟦INLMATH44MATHEND⟧.</li>
</ul>

<p>RLHF typically uses <strong>reverse KL</strong> because we want the actor not to move too far from the reference, not necessarily to cover every mode.</p>

<h2 id="three-estimators-definitions-and-design">Three estimators: definitions and design</h2>

<p>Let ⟦INLMATH45MATHEND⟧. John Schulman defined three single-sample estimators:</p>

<h3 id="inlmath46mathend-the-naive-estimator">⟦INLMATH46MATHEND⟧: the naive estimator</h3>

<p>⟦DISPMATH3MATHEND⟧</p>

<p>Direct log-ratio. It is unbiased for reverse KL, but <strong>can be negative</strong> while KL is always nonnegative, giving huge variance because positive and negative samples cancel.</p>

<h3 id="inlmath47mathend-an-f-divergence-lower-variance">⟦INLMATH47MATHEND⟧: an f-divergence, lower variance</h3>

<p>⟦DISPMATH4MATHEND⟧</p>

<p><strong>Motivation:</strong> ⟦INLMATH48MATHEND⟧ can be positive or negative; ⟦INLMATH49MATHEND⟧ squares it so <strong>every sample is positive</strong>, each telling you how far ⟦INLMATH50MATHEND⟧ and ⟦INLMATH51MATHEND⟧ differ.</p>

<p><strong>Why tiny bias?</strong> ⟦INLMATH52MATHEND⟧ is an <strong>f-divergence</strong> with ⟦INLMATH53MATHEND⟧. All smooth f-divergences have the same second-order expansion near ⟦INLMATH54MATHEND⟧:</p>

<p>⟦DISPMATH5MATHEND⟧</p>

<p>KL corresponds to ⟦INLMATH55MATHEND⟧, so ⟦INLMATH56MATHEND⟧. For ⟦INLMATH57MATHEND⟧, ⟦INLMATH58MATHEND⟧ as well. <strong>When policies are close, ⟦INLMATH59MATHEND⟧ tracks true KL almost identically</strong>, bias only appears in higher-order terms.</p>

<h3 id="inlmath60mathend-control-variate-optimal-shape">⟦INLMATH60MATHEND⟧: control variate, “optimal” shape</h3>

<p>⟦DISPMATH6MATHEND⟧</p>

<p><strong>Motivation:</strong> we want <strong>unbiased and low variance</strong>. Add a <strong>control variate</strong> to ⟦INLMATH61MATHEND⟧: something zero-mean and negatively correlated.</p>

<p>Because ⟦INLMATH62MATHEND⟧, for any ⟦INLMATH63MATHEND⟧:</p>

<p>⟦DISPMATH7MATHEND⟧</p>

<p>is still unbiased.</p>

<p><strong>Why ⟦INLMATH64MATHEND⟧?</strong> By concavity of ⟦INLMATH65MATHEND⟧, ⟦INLMATH66MATHEND⟧, so</p>

<p>⟦DISPMATH8MATHEND⟧</p>

<p>It is <strong>always nonnegative</strong>, avoiding the cancelation problem.</p>

<p><strong>Geometric view:</strong> ⟦INLMATH67MATHEND⟧ is a <strong>Bregman divergence</strong> for ⟦INLMATH68MATHEND⟧. Its tangent at ⟦INLMATH69MATHEND⟧ is ⟦INLMATH70MATHEND⟧, so</p>

<p>⟦DISPMATH9MATHEND⟧</p>

<p>Convexity keeps ⟦INLMATH71MATHEND⟧ above its tangent, so this gap is <strong>nonnegative</strong>. As ⟦INLMATH72MATHEND⟧, the gap shrinks quadratically ⟦INLMATH73MATHEND⟧, explaining the low variance when policies are close.</p>

<h3 id="quick-comparison">Quick comparison</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Estimator</th>
      <th style="text-align: center">Definition</th>
      <th style="text-align: center">Design idea</th>
      <th style="text-align: center">Bias (value)</th>
      <th style="text-align: center">Variance</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">⟦INLMATH74MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH75MATHEND⟧</td>
      <td style="text-align: center">Naive log-ratio</td>
      <td style="text-align: center">Unbiased</td>
      <td style="text-align: center">High (can be negative)</td>
    </tr>
    <tr>
      <td style="text-align: center">⟦INLMATH76MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH77MATHEND⟧</td>
      <td style="text-align: center">f-divergence, KL-matching 2nd order</td>
      <td style="text-align: center">Biased (very small)</td>
      <td style="text-align: center">Low (always positive)</td>
    </tr>
    <tr>
      <td style="text-align: center">⟦INLMATH78MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH79MATHEND⟧</td>
      <td style="text-align: center">Control variate + Bregman</td>
      <td style="text-align: center">Unbiased</td>
      <td style="text-align: center">Low (always positive)</td>
    </tr>
  </tbody>
</table>

<p>For estimating the KL <strong>value</strong>, ⟦INLMATH80MATHEND⟧ is “unbiased + low variance”; but as we’ll analyze, <strong>the gradient story is completely different</strong> — different estimators’ gradients may correspond to different optimization objectives. Moreover, whether KL is added to the reward for shaping or used as a loss for direct gradient backpropagation will fundamentally affect training behavior.</p>

<h2 id="core-analysis">Core analysis</h2>

<h3 id="bias-and-variance-for-kl-values">Bias and variance for KL values</h3>

<p>Assume samples from ⟦INLMATH81MATHEND⟧ to estimate reverse KL ⟦INLMATH82MATHEND⟧.</p>

<p><strong>Unbiasedness:</strong></p>

<p>⟦DISPMATH10MATHEND⟧</p>

<p><strong>Variance trade-off:</strong></p>

<p>John Schulman’s toy experiments (⟦INLMATH83MATHEND⟧, ⟦INLMATH84MATHEND⟧, true KL = 0.005):</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Estimator</th>
      <th style="text-align: center">bias/true</th>
      <th style="text-align: center">stdev/true</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">⟦INLMATH85MATHEND⟧</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">20</td>
    </tr>
    <tr>
      <td style="text-align: center">⟦INLMATH86MATHEND⟧</td>
      <td style="text-align: center">0.002</td>
      <td style="text-align: center">1.42</td>
    </tr>
    <tr>
      <td style="text-align: center">⟦INLMATH87MATHEND⟧</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">1.42</td>
    </tr>
  </tbody>
</table>

<p>When KL is large (⟦INLMATH88MATHEND⟧, true KL = 0.5):</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Estimator</th>
      <th style="text-align: center">bias/true</th>
      <th style="text-align: center">stdev/true</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">⟦INLMATH89MATHEND⟧</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">2</td>
    </tr>
    <tr>
      <td style="text-align: center">⟦INLMATH90MATHEND⟧</td>
      <td style="text-align: center">0.25</td>
      <td style="text-align: center">1.73</td>
    </tr>
    <tr>
      <td style="text-align: center">⟦INLMATH91MATHEND⟧</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">1.7</td>
    </tr>
  </tbody>
</table>

<p><strong>Intuition:</strong></p>
<ul>
  <li>⟦INLMATH92MATHEND⟧ is first-order around ⟦INLMATH93MATHEND⟧, can be negative, so variance explodes when close.</li>
  <li>⟦INLMATH94MATHEND⟧ is second-order near ⟦INLMATH95MATHEND⟧ and always positive, so lower variance when close.</li>
  <li>When coverage is poor (heavy tails in ⟦INLMATH96MATHEND⟧), ⟦INLMATH97MATHEND⟧ can explode; then ⟦INLMATH98MATHEND⟧ can be more stable.</li>
</ul>

<blockquote>
  <p><strong>Note:</strong> To estimate <strong>forward KL value</strong> ⟦INLMATH99MATHEND⟧ but only sample from ⟦INLMATH100MATHEND⟧, use importance sampling ⟦INLMATH101MATHEND⟧.</p>
</blockquote>

<h3 id="gradient-estimation-the-crucial-distinction">Gradient estimation: the crucial distinction</h3>

<p>This is the easiest part to get wrong. First analyze <strong>on-policy</strong> (samples from ⟦INLMATH102MATHEND⟧), then extend to <strong>off-policy</strong> (samples from behavior ⟦INLMATH103MATHEND⟧).</p>

<h4 id="true-gradients-for-reference">True gradients for reference</h4>

<p>Let score function ⟦INLMATH104MATHEND⟧, with key property ⟦INLMATH105MATHEND⟧.</p>

<p><strong>Reverse KL gradient:</strong></p>

<p>⟦DISPMATH11MATHEND⟧</p>

<p>Product rule and ⟦INLMATH106MATHEND⟧, ⟦INLMATH107MATHEND⟧ give</p>

<p>⟦DISPMATH12MATHEND⟧</p>

<p><strong>Forward KL gradient:</strong></p>

<p>⟦DISPMATH13MATHEND⟧</p>

<p>Since ⟦INLMATH108MATHEND⟧ is ⟦INLMATH109MATHEND⟧-independent,</p>

<p>⟦DISPMATH14MATHEND⟧</p>

<p>These baselines tell us what each estimator’s expected gradient really targets.</p>

<h4 id="two-differentiation-orders">Two differentiation orders</h4>

<p>1) <strong>Grad then expectation:</strong> autograd on each sample, then batch average (what DL code actually does).
2) <strong>Expectation then grad:</strong> treat ⟦INLMATH110MATHEND⟧ as a function of ⟦INLMATH111MATHEND⟧ and differentiate analytically.</p>

<p>Typical code does (1).</p>

<h4 id="gradients-of-the-three-estimators-on-policy">Gradients of the three estimators (on-policy)</h4>

<p>⟦DISPMATH15MATHEND⟧</p>

<p>⟦DISPMATH16MATHEND⟧</p>

<p>⟦DISPMATH17MATHEND⟧</p>

<p>Taking expectation under ⟦INLMATH112MATHEND⟧:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Estimator</th>
      <th style="text-align: center">⟦INLMATH113MATHEND⟧</th>
      <th style="text-align: center">Equals</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">⟦INLMATH114MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH115MATHEND⟧</td>
      <td style="text-align: center">Zero (useless as loss)</td>
    </tr>
    <tr>
      <td style="text-align: center">⟦INLMATH116MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH117MATHEND⟧</td>
      <td style="text-align: center">Gradient of reverse KL</td>
    </tr>
    <tr>
      <td style="text-align: center">⟦INLMATH118MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH119MATHEND⟧</td>
      <td style="text-align: center">Gradient of forward KL</td>
    </tr>
  </tbody>
</table>

<p><strong>Key takeaways:</strong></p>
<ul>
  <li><strong>⟦INLMATH120MATHEND⟧ gradient</strong> matches reverse KL gradient (the usual “stay near ref” objective).</li>
  <li><strong>⟦INLMATH121MATHEND⟧ gradient</strong> matches forward KL gradient (coverage objective).</li>
  <li><strong>⟦INLMATH122MATHEND⟧ gradient expectation is zero</strong> — useless as a loss.</li>
</ul>

<h4 id="expectation-then-grad-vs-grad-then-expectation">Expectation-then-grad vs. grad-then-expectation</h4>

<p>If you first form ⟦INLMATH123MATHEND⟧ and then differentiate (expectation-then-grad):</p>

<p>⟦DISPMATH18MATHEND⟧</p>

<p>Both give reverse KL. But autograd on per-sample ⟦INLMATH124MATHEND⟧ averages (grad-then-expectation) yields <strong>forward KL gradient</strong>. Same estimator, different order, different result.</p>

<h3 id="off-policy-gradients-with-importance-sampling">Off-policy gradients with importance sampling</h3>

<p>Real RL often samples from a behavior policy ⟦INLMATH125MATHEND⟧ (old or mixed policy, replay buffer). To optimize <strong>reverse KL</strong> you need <strong>importance weights</strong>.</p>

<p>See also my earlier post: <a href="/reinforcement-learning/2025/11/15/three-policy-zh.html">Three-policy TRPO extension for LLM RL</a>.</p>

<h4 id="setup">Setup</h4>

<p>Define importance weight</p>

<p>⟦DISPMATH19MATHEND⟧</p>

<p>Using batch loss ⟦INLMATH126MATHEND⟧ with autograd, what gradients do we get?</p>

<p>A key difference:</p>
<ul>
  <li>Previously expectations were under ⟦INLMATH127MATHEND⟧ (depends on ⟦INLMATH128MATHEND⟧).</li>
  <li>Now expectations are under ⟦INLMATH129MATHEND⟧ (independent of ⟦INLMATH130MATHEND⟧).</li>
</ul>

<h4 id="crucial-observation-the-two-orders-coincide">Crucial observation: the two orders coincide</h4>

<p>Because ⟦INLMATH131MATHEND⟧ is ⟦INLMATH132MATHEND⟧-independent,</p>

<p>⟦DISPMATH20MATHEND⟧</p>

<p>So autograd on sample means (grad-then-expectation) equals expectation-then-grad. For ⟦INLMATH133MATHEND⟧ and ⟦INLMATH134MATHEND⟧, both value-unbiased for reverse KL, their gradient expectations also match reverse KL.</p>

<h4 id="value-unbiasedness-remains">Value unbiasedness remains</h4>

<p>By ⟦INLMATH135MATHEND⟧:</p>

<p>⟦DISPMATH21MATHEND⟧</p>

<p>⟦DISPMATH22MATHEND⟧</p>

<h4 id="gradients-with-weights">Gradients with weights</h4>

<p>Gradient of weight: ⟦INLMATH136MATHEND⟧. Using product rule:</p>

<p>⟦DISPMATH23MATHEND⟧
⟦DISPMATH24MATHEND⟧
⟦DISPMATH25MATHEND⟧</p>

<p>Which give expected gradients:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Weighted estimator</th>
      <th style="text-align: center">Value target</th>
      <th style="text-align: center">Expected gradient</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">⟦INLMATH137MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH138MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH139MATHEND⟧ (reverse KL) ✓</td>
    </tr>
    <tr>
      <td style="text-align: center">⟦INLMATH140MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH141MATHEND⟧ (f-divergence)</td>
      <td style="text-align: center">⟦INLMATH142MATHEND⟧, not reverse KL ✗</td>
    </tr>
    <tr>
      <td style="text-align: center">⟦INLMATH143MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH144MATHEND⟧ (f-divergence)</td>
      <td style="text-align: center">⟦INLMATH145MATHEND⟧ (reverse KL) ✓</td>
    </tr>
    <tr>
      <td style="text-align: center">⟦INLMATH146MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH147MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH148MATHEND⟧ (reverse KL) ✓</td>
    </tr>
  </tbody>
</table>

<p><strong>Interesting reversal vs. on-policy:</strong></p>
<ul>
  <li>On-policy: ⟦INLMATH149MATHEND⟧ as loss gives reverse KL gradient; ⟦INLMATH150MATHEND⟧ gradient is zero.</li>
  <li>Off-policy + weights: ⟦INLMATH151MATHEND⟧ and ⟦INLMATH152MATHEND⟧ give reverse KL gradients; ⟦INLMATH153MATHEND⟧ (with weight in grad) fails.</li>
  <li>Detaching the weight makes ⟦INLMATH154MATHEND⟧ also give reverse KL gradient.</li>
</ul>

<h4 id="variance-of-the-three-unbiased-off-policy-gradient-estimators">Variance of the three unbiased off-policy gradient estimators</h4>

<p>Unbiased reverse-KL gradient estimators (off-policy + IS):</p>

<p>⟦DISPMATH26MATHEND⟧</p>

<p>With ⟦INLMATH155MATHEND⟧, ⟦INLMATH156MATHEND⟧. Using ⟦INLMATH157MATHEND⟧, ⟦INLMATH158MATHEND⟧, ⟦INLMATH159MATHEND⟧, ⟦INLMATH160MATHEND⟧:</p>

<p>⟦DISPMATH27MATHEND⟧</p>

<p>So <strong>⟦INLMATH161MATHEND⟧</strong>. Only two distinct variance behaviors: ⟦INLMATH162MATHEND⟧ vs. ⟦INLMATH163MATHEND⟧.</p>

<p>Let ⟦INLMATH164MATHEND⟧. Then</p>

<p>⟦DISPMATH28MATHEND⟧</p>

<p>Variance difference:</p>

<p>⟦DISPMATH29MATHEND⟧</p>

<p>In the typical KL-penalty regime ⟦INLMATH165MATHEND⟧, write ⟦INLMATH166MATHEND⟧, ⟦INLMATH167MATHEND⟧, so ⟦INLMATH168MATHEND⟧, ⟦INLMATH169MATHEND⟧. Thus ⟦INLMATH170MATHEND⟧.</p>

<p>Intuition:</p>
<ul>
  <li>⟦INLMATH171MATHEND⟧ includes an ⟦INLMATH172MATHEND⟧ zero-mean noise term ⟦INLMATH173MATHEND⟧.</li>
  <li>⟦INLMATH174MATHEND⟧ cancels that term; remaining magnitude is ⟦INLMATH175MATHEND⟧, giving much lower variance.</li>
</ul>

<p>Table summary:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Estimator</th>
      <th style="text-align: center">Gradient rv</th>
      <th style="text-align: center">Scale (⟦INLMATH176MATHEND⟧)</th>
      <th style="text-align: center">Variance</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">⟦INLMATH177MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH178MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH179MATHEND⟧</td>
      <td style="text-align: center">High</td>
    </tr>
    <tr>
      <td style="text-align: center">⟦INLMATH180MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH181MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH182MATHEND⟧</td>
      <td style="text-align: center">Low</td>
    </tr>
    <tr>
      <td style="text-align: center">⟦INLMATH183MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH184MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH185MATHEND⟧</td>
      <td style="text-align: center">Low</td>
    </tr>
  </tbody>
</table>

<p>Conclusion: off-policy IS with reverse-KL gradients has three unbiased options: ⟦INLMATH186MATHEND⟧, ⟦INLMATH187MATHEND⟧, ⟦INLMATH188MATHEND⟧. The latter two are identical in gradient and variance and are preferred; ⟦INLMATH189MATHEND⟧ is unbiased but noisier.</p>

<p><strong>When far off-policy:</strong> If ⟦INLMATH190MATHEND⟧ explodes (little overlap), any ⟦INLMATH191MATHEND⟧ method suffers. Then the variance advantage of ⟦INLMATH192MATHEND⟧ over ⟦INLMATH193MATHEND⟧ is not guaranteed; clipping/regularization becomes necessary.</p>

<h3 id="gradient-cheat-sheet">Gradient cheat sheet</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Sampling</th>
      <th style="text-align: center">Loss</th>
      <th style="text-align: center">⟦INLMATH194MATHEND⟧</th>
      <th style="text-align: center">Optimizes</th>
      <th style="text-align: center">Right for reverse KL?</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">⟦INLMATH195MATHEND⟧ (on)</td>
      <td style="text-align: center">⟦INLMATH196MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH197MATHEND⟧</td>
      <td style="text-align: center">None (zero grad)</td>
      <td style="text-align: center">✗</td>
    </tr>
    <tr>
      <td style="text-align: center">⟦INLMATH198MATHEND⟧ (on)</td>
      <td style="text-align: center">⟦INLMATH199MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH200MATHEND⟧</td>
      <td style="text-align: center">Reverse KL</td>
      <td style="text-align: center">✓</td>
    </tr>
    <tr>
      <td style="text-align: center">⟦INLMATH201MATHEND⟧ (on)</td>
      <td style="text-align: center">⟦INLMATH202MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH203MATHEND⟧</td>
      <td style="text-align: center">Forward KL</td>
      <td style="text-align: center">✗</td>
    </tr>
    <tr>
      <td style="text-align: center">⟦INLMATH204MATHEND⟧ (off)</td>
      <td style="text-align: center">⟦INLMATH205MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH206MATHEND⟧</td>
      <td style="text-align: center">Reverse KL</td>
      <td style="text-align: center">✓ (higher var)</td>
    </tr>
    <tr>
      <td style="text-align: center">⟦INLMATH207MATHEND⟧ (off)</td>
      <td style="text-align: center">⟦INLMATH208MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH209MATHEND⟧</td>
      <td style="text-align: center">f-divergence (not KL)</td>
      <td style="text-align: center">✗</td>
    </tr>
    <tr>
      <td style="text-align: center">⟦INLMATH210MATHEND⟧ (off)</td>
      <td style="text-align: center">⟦INLMATH211MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH212MATHEND⟧</td>
      <td style="text-align: center">Reverse KL</td>
      <td style="text-align: center">✓</td>
    </tr>
    <tr>
      <td style="text-align: center">⟦INLMATH213MATHEND⟧ (off)</td>
      <td style="text-align: center">⟦INLMATH214MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH215MATHEND⟧</td>
      <td style="text-align: center">Reverse KL</td>
      <td style="text-align: center">✓ (recommended, low var)</td>
    </tr>
  </tbody>
</table>

<p><strong>Key conclusions:</strong>
1) <strong>On-policy reverse KL:</strong> use ⟦INLMATH216MATHEND⟧ (only correct choice).
2) <strong>Off-policy reverse KL:</strong> three correct options: ⟦INLMATH217MATHEND⟧ (unbiased, higher var); ⟦INLMATH218MATHEND⟧ (unbiased, equals next); ⟦INLMATH219MATHEND⟧ (unbiased, lower var; equals previous).
3) <strong>⟦INLMATH220MATHEND⟧ with weight in grad is wrong</strong> for reverse KL.</p>

<p>However, before choosing an estimator, there’s a more fundamental question to answer: <strong>should KL be added to rewards, or be part of the loss?</strong> This choice fundamentally affects optimization behavior and credit assignment.</p>

<h2 id="two-ways-to-use-kl-as-reward-vs-as-loss">Two Ways to Use KL: As Reward vs. As Loss</h2>

<p>In practice, KL penalty can be used in two fundamentally different ways: added to rewards for shaping (no gradient backpropagation needed), or as part of the loss for backpropagation (gradient needed).</p>

<p>These two approaches may seem like just a <code class="language-plaintext highlighter-rouge">detach</code> difference in code, but they correspond to completely different optimization behaviors.</p>

<h3 id="definitions">Definitions</h3>

<p><strong>KL as Reward (stop-gradient):</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">kl</span> <span class="o">=</span> <span class="nf">compute_kl</span><span class="p">(</span><span class="n">log_prob_q</span><span class="p">,</span> <span class="n">log_prob_p</span><span class="p">).</span><span class="nf">detach</span><span class="p">()</span>
<span class="n">shaped_reward</span> <span class="o">=</span> <span class="n">reward</span> <span class="o">-</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">kl</span>
</code></pre></div></div>

<p>Use shaped reward for standard actor-critic updates.</p>

<p><strong>KL as Loss (backprop):</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">actor_loss</span> <span class="o">=</span> <span class="o">-</span><span class="n">advantage</span> <span class="o">*</span> <span class="n">log_prob</span> <span class="o">+</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">kl</span>  <span class="c1"># kl participates in gradient
</span></code></pre></div></div>

<p>Critic only learns environment value; KL is a regularization term for the actor that backpropagates gradients.</p>

<h3 id="key-difference-1-optimization-target">Key Difference 1: Optimization Target</h3>

<p><strong>KL as Reward:</strong> Optimizes a <strong>regularized new MDP</strong> where the reward function becomes ⟦INLMATH221MATHEND⟧.</p>

<p><strong>KL as Loss:</strong> Optimizes the <strong>original task + supervised regularization</strong>; KL doesn’t change the MDP definition, it’s just an external constraint term.</p>

<p><strong>Intuition:</strong> The former “changes the game rules”; the latter “adds constraints under the original rules”.</p>

<h3 id="key-difference-2-actor-gradient">Key Difference 2: Actor Gradient</h3>

<p><strong>KL as Reward:</strong> Single policy gradient, KL influence is <strong>reflected indirectly through advantage</strong>:</p>

<p>⟦DISPMATH30MATHEND⟧</p>

<p><strong>KL as Loss:</strong> Gradient splits into two independent paths:</p>

<p>⟦DISPMATH31MATHEND⟧</p>

<p><strong>Key distinction:</strong> Is KL’s force “multiplied on advantage” or “a separate force”? The latter’s KL gradient is deterministic, unaffected by critic quality.</p>

<h3 id="key-difference-3-critic-learning-target">Key Difference 3: Critic Learning Target</h3>

<p><strong>KL as Reward:</strong> Critic learns mixed value</p>

<p>⟦DISPMATH32MATHEND⟧</p>

<p><strong>KL as Loss:</strong> Critic only learns environment value</p>

<p>⟦DISPMATH33MATHEND⟧</p>

<p>The latter has cleaner separation, making it easier to monitor task return and KL divergence separately.</p>

<h3 id="key-difference-4-credit-assignment">Key Difference 4: Credit Assignment</h3>

<p>Consider a scenario: first few steps are routing behavior, final step has high reward but also high KL.</p>

<p><strong>KL as Reward:</strong> The large KL at the terminal state is <strong>propagated back to all previous steps</strong> through TD, so the policy tends to <strong>fundamentally avoid</strong> high-KL regions — this is “planning-based KL budget allocation”.</p>

<p><strong>KL as Loss:</strong> The terminal state’s KL only appears in that state’s gradient term; the policy is still willing to <strong>visit high-reward regions but locally correct</strong> behavior.</p>

<h3 id="summary">Summary</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Dimension</th>
      <th style="text-align: center">KL as Reward (stop-grad)</th>
      <th style="text-align: center">KL as Loss (backprop)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Optimization target</td>
      <td style="text-align: center">Regularized new MDP</td>
      <td style="text-align: center">Original task + supervised regularization</td>
    </tr>
    <tr>
      <td style="text-align: center">Actor gradient</td>
      <td style="text-align: center">Single PG, based on shaped advantage</td>
      <td style="text-align: center">RL gradient + explicit KL gradient</td>
    </tr>
    <tr>
      <td style="text-align: center">Critic</td>
      <td style="text-align: center">Learns ⟦INLMATH222MATHEND⟧: reward + KL mixed</td>
      <td style="text-align: center">Learns ⟦INLMATH223MATHEND⟧: only environment reward</td>
    </tr>
    <tr>
      <td style="text-align: center">Credit Assignment</td>
      <td style="text-align: center">Multi-step backprop, planning-capable</td>
      <td style="text-align: center">Local per-state, no planning</td>
    </tr>
  </tbody>
</table>

<p><strong>One-liner:</strong> KL as reward makes the agent “plan to avoid high-KL paths” — constraints are more global and thorough; KL as loss makes the agent “visit but locally correct” — constraints are more local and flexible. The choice depends on whether you need cross-timestep KL budget allocation capability, and whether you want constraints to be “preventive” or “corrective”.</p>

<h2 id="rl-practice-guide">RL practice guide</h2>

<p>Combining the preceding analysis of “estimator mathematical properties” and “usage modes”, this section provides practical recommendations for specific scenarios.</p>

<h3 id="kl-as-reward-penalty-no-gradient-needed">KL as reward penalty (no gradient needed)</h3>

<p>When KL is a scalar penalty in rewards, we only need accurate <strong>values</strong>, no backprop. Refer to the earlier section on “Bias and variance for KL values”.</p>

<p><strong>Recommend:</strong></p>
<ul>
  <li>Use <strong>⟦INLMATH224MATHEND⟧</strong> or <strong>⟦INLMATH225MATHEND⟧</strong> (both unbiased for reverse KL value).</li>
  <li>When policies are close, ⟦INLMATH226MATHEND⟧ is typically lower variance.</li>
  <li>With poor coverage or heavy tails, ⟦INLMATH227MATHEND⟧ is more robust.</li>
  <li>Off-policy: multiply by ⟦INLMATH228MATHEND⟧.</li>
</ul>

<blockquote>
  <p>For a <strong>forward KL penalty</strong>, use ⟦INLMATH229MATHEND⟧ or (if sampling from ⟦INLMATH230MATHEND⟧) ⟦INLMATH231MATHEND⟧.</p>
</blockquote>

<h3 id="kl-as-loss-needs-gradients">KL as loss (needs gradients)</h3>

<h4 id="on-policy-optimize-reverse-kl-most-common">On-policy: optimize reverse KL (most common)</h4>

<p>Goal: keep actor near reference.</p>

<p><strong>Use ⟦INLMATH232MATHEND⟧ as loss.</strong></p>

<p>⟦DISPMATH34MATHEND⟧</p>

<p>Then ⟦INLMATH233MATHEND⟧.</p>

<h4 id="on-policy-optimize-forward-kl-coverage">On-policy: optimize forward KL (coverage)</h4>

<p>Goal: cover the reference distribution (offline RL, imitation, etc.).</p>

<p><strong>Use ⟦INLMATH234MATHEND⟧ as loss.</strong> Autograd on sample means gives ⟦INLMATH235MATHEND⟧.</p>

<h4 id="off-policy-optimize-reverse-kl">Off-policy: optimize reverse KL</h4>

<p>Goal: samples from behavior ⟦INLMATH236MATHEND⟧, still optimize reverse KL.</p>

<p><strong>Recommended:</strong> ⟦INLMATH237MATHEND⟧ or ⟦INLMATH238MATHEND⟧ (identical gradients).</p>

<p>⟦DISPMATH35MATHEND⟧</p>

<p>or</p>

<p>⟦DISPMATH36MATHEND⟧</p>

<ul>
  <li>Gradients are unbiased.</li>
  <li>When ⟦INLMATH239MATHEND⟧, both have much lower variance.</li>
</ul>

<p><strong>Fallback:</strong> ⟦INLMATH240MATHEND⟧ (unbiased but higher variance).</p>

<p><strong>Avoid:</strong> ⟦INLMATH241MATHEND⟧ with weight in gradient — biased for reverse KL.</p>

<h2 id="grab-and-use-crib-sheet">“Grab-and-use” crib sheet</h2>

<p>The table below provides recommended estimator choices along three dimensions: “target KL direction” × “sampling source” × “usage mode”. “For <strong>value</strong>” corresponds to KL as reward penalty (no gradient needed); “For <strong>gradient</strong>” corresponds to KL as loss (gradient backpropagation needed).</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Target</th>
      <th style="text-align: center">Sampling</th>
      <th style="text-align: center">For value (KL as Reward)</th>
      <th style="text-align: center">For gradient (KL as Loss)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Reverse KL ⟦INLMATH242MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH243MATHEND⟧ (on-policy)</td>
      <td style="text-align: center">⟦INLMATH244MATHEND⟧ or ⟦INLMATH245MATHEND⟧ (unbiased)</td>
      <td style="text-align: center">⟦INLMATH246MATHEND⟧</td>
    </tr>
    <tr>
      <td style="text-align: center">Reverse KL ⟦INLMATH247MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH248MATHEND⟧ (off-policy)</td>
      <td style="text-align: center">⟦INLMATH249MATHEND⟧ or ⟦INLMATH250MATHEND⟧ (unbiased)</td>
      <td style="text-align: center">⟦INLMATH251MATHEND⟧ (recommended) or ⟦INLMATH252MATHEND⟧</td>
    </tr>
    <tr>
      <td style="text-align: center">Forward KL ⟦INLMATH253MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH254MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH255MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH256MATHEND⟧</td>
    </tr>
  </tbody>
</table>

<h2 id="common-implementation-traps">Common implementation traps</h2>

<p><strong>Trap 1: Using ⟦INLMATH257MATHEND⟧ directly as loss (on-policy)</strong></p>

<p>When KL is used as a loss, ⟦INLMATH258MATHEND⟧ gradient expectation is zero (⟦INLMATH259MATHEND⟧); as a loss it does nothing.</p>

<blockquote>
  <p><strong>Fix:</strong> First clarify the KL usage mode. For reward shaping (no gradient needed), both ⟦INLMATH260MATHEND⟧ and ⟦INLMATH261MATHEND⟧ work; for losses (gradient needed), use ⟦INLMATH262MATHEND⟧ (reverse KL) or ⟦INLMATH263MATHEND⟧ (forward KL) on-policy.</p>
</blockquote>

<p><strong>Trap 2: Mixing up ⟦INLMATH264MATHEND⟧ value-unbiasedness vs. gradient target</strong></p>

<p>⟦INLMATH265MATHEND⟧ is value-unbiased for reverse KL, but its <strong>gradient</strong> is <strong>forward KL</strong>. If you want reverse KL and backprop ⟦INLMATH266MATHEND⟧, you are actually optimizing forward KL.</p>

<blockquote>
  <p><strong>Fix:</strong> be explicit: reverse KL -&gt; ⟦INLMATH267MATHEND⟧; forward KL -&gt; ⟦INLMATH268MATHEND⟧.</p>
</blockquote>

<p><strong>Trap 3: Heavy-tailed ⟦INLMATH269MATHEND⟧ blows up variance</strong></p>

<p>If ⟦INLMATH270MATHEND⟧ has extreme values, ⟦INLMATH271MATHEND⟧ variance can explode.</p>

<blockquote>
  <p><strong>Fix:</strong> enforce KL constraint or clip ⟦INLMATH272MATHEND⟧.</p>
</blockquote>

<p><strong>Trap 4: Off-policy but still using ⟦INLMATH273MATHEND⟧ or ⟦INLMATH274MATHEND⟧ (with grad on weight)</strong></p>

<p>If ⟦INLMATH275MATHEND⟧:</p>
<ul>
  <li>Plain ⟦INLMATH276MATHEND⟧ (no weight): expectation is under ⟦INLMATH277MATHEND⟧, estimator fails.</li>
  <li>⟦INLMATH278MATHEND⟧ with weight in grad: gradient is biased (f-divergence), not reverse KL.</li>
</ul>

<blockquote>
  <p><strong>Fix:</strong> off-policy reverse KL -&gt; use ⟦INLMATH279MATHEND⟧ (recommended), ⟦INLMATH280MATHEND⟧, or ⟦INLMATH281MATHEND⟧.</p>
</blockquote>

<p><strong>Trap 5: Wrong detach on importance weights</strong></p>

<p>⟦INLMATH282MATHEND⟧ often comes from <code class="language-plaintext highlighter-rouge">log_prob_q - log_prob_mu</code> then <code class="language-plaintext highlighter-rouge">exp</code>. Detaching ⟦INLMATH283MATHEND⟧ matters:</p>

<ul>
  <li><strong>Using ⟦INLMATH284MATHEND⟧ or ⟦INLMATH285MATHEND⟧:</strong> ⟦INLMATH286MATHEND⟧ <strong>must participate in gradient</strong> (do not detach), otherwise you drop ⟦INLMATH287MATHEND⟧ and get wrong gradients.</li>
  <li><strong>Using ⟦INLMATH288MATHEND⟧:</strong> <strong>detach ⟦INLMATH289MATHEND⟧</strong> to get reverse KL gradient. If ⟦INLMATH290MATHEND⟧ stays in the graph, you get f-divergence gradient instead.</li>
</ul>

<blockquote>
  <p><strong>Summary:</strong> match estimator with the right detach strategy.</p>
</blockquote>

<h2 id="summary-1">Summary</h2>

<p><strong>One-liners:</strong></p>

<ul>
  <li><strong>Only value (reward penalty):</strong> use ⟦INLMATH291MATHEND⟧ or ⟦INLMATH292MATHEND⟧ (both unbiased for reverse KL value); off-policy multiply by ⟦INLMATH293MATHEND⟧.</li>
  <li><strong>Need gradients (loss):</strong>
    <ul>
      <li><strong>On-policy:</strong> reverse KL -&gt; ⟦INLMATH294MATHEND⟧; forward KL -&gt; ⟦INLMATH295MATHEND⟧.</li>
      <li><strong>Off-policy:</strong> reverse KL -&gt; ⟦INLMATH296MATHEND⟧ or ⟦INLMATH297MATHEND⟧ (same gradient, low variance); fallback ⟦INLMATH298MATHEND⟧ (unbiased but noisier).</li>
    </ul>
  </li>
</ul>

<p>Keep three questions clear: <strong>who do we sample from, whose value do we estimate, whose gradient do we need?</strong> Especially note: <strong>on-policy vs. off-policy choose different estimators for reverse KL</strong> — on-policy use ⟦INLMATH299MATHEND⟧, off-policy use ⟦INLMATH300MATHEND⟧ or ⟦INLMATH301MATHEND⟧.</p>

<p>Additionally, don’t forget to determine <strong>the KL usage mode</strong> before choosing an estimator:</p>
<ul>
  <li><strong>KL as reward:</strong> Constraints act on the policy indirectly through shaped advantage, with cross-timestep credit assignment capability; agent will “plan to avoid high-KL paths”</li>
  <li><strong>KL as loss:</strong> Constraints act on the policy directly as an independent gradient term; agent will “visit but locally correct”</li>
</ul>

<p>This choice is more fundamental than the estimator itself, depending on whether you want constraints to be “preventive” or “corrective”.</p>

<h2 id="references">References</h2>

<ol>
  <li>Dibya Ghosh. “KL Divergence for Machine Learning”. <a href="https://dibyaghosh.com/blog/probability/kldivergence">https://dibyaghosh.com/blog/probability/kldivergence</a></li>
  <li>John Schulman. “Approximating KL Divergence”. <a href="https://joschu.net/blog/kl-approx.html">https://joschu.net/blog/kl-approx.html</a></li>
  <li>Verl Documentation. “Proximal Policy Optimization (PPO)”. <a href="https://verl.readthedocs.io/en/latest/algo/ppo.html">https://verl.readthedocs.io/en/latest/algo/ppo.html</a></li>
  <li>初七123334. “RLHF/RLVR 训练中的 KL 近似方法浅析（k1 / k2 / k3)”. <a href="https://zhuanlan.zhihu.com/p/1966872846212010437">https://zhuanlan.zhihu.com/p/1966872846212010437</a></li>
  <li>Kezhao Liu, Jason Klein Liu, Mingtao Chen, Yiming Liu. “Rethinking KL Regularization in RLHF: From Value Estimation to Gradient Optimization”. <a href="https://arxiv.org/abs/2510.01555">https://arxiv.org/abs/2510.01555</a></li>
  <li>Yifan Zhang, Yiping Ji, Gavin Brown, et al. “On the Design of KL-Regularized Policy Gradient Algorithms for LLM Reasoning”. <a href="https://arxiv.org/abs/2505.17508">https://arxiv.org/abs/2505.17508</a></li>
</ol>

<div class="language-bibtex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">@misc</span><span class="p">{</span><span class="nl">WangZhang2025KLEstimators</span><span class="p">,</span>
	<span class="na">author</span>       <span class="p">=</span> <span class="s">{Wang, Xihuai and Zhang, Shao}</span><span class="p">,</span>
	<span class="na">title</span>        <span class="p">=</span> <span class="s">{Understanding {KL} Divergence Estimators in {RL}: From Value Approximation to Gradient Estimation}</span><span class="p">,</span>
	<span class="na">year</span>         <span class="p">=</span> <span class="s">{2025}</span><span class="p">,</span>
	<span class="na">month</span>        <span class="p">=</span> <span class="nv">dec</span><span class="p">,</span>
	<span class="na">day</span>          <span class="p">=</span> <span class="s">{01}</span><span class="p">,</span>
	<span class="na">url</span>          <span class="p">=</span> <span class="s">{https://xihuai18.github.io/reinforcement-learning/2025/12/01/kl-estimators-en.html}</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="reinforcement-learning" /><summary type="html"><![CDATA[How we approximate KL directly affects stability. This post dissects three classic estimators k1, k2, k3, covering on-policy and off-policy, and gives practical rules for using them for reward penalties vs. losses that backpropagate.]]></summary></entry><entry xml:lang="zh"><title type="html">简单理解 RL 中的 KL 散度估计器：从数值估计到梯度估计</title><link href="https://xihuai18.github.io/reinforcement-learning/2025/12/01/kl-estimators-zh.html" rel="alternate" type="text/html" title="简单理解 RL 中的 KL 散度估计器：从数值估计到梯度估计" /><published>2025-12-01T00:00:00+00:00</published><updated>2025-12-01T00:00:00+00:00</updated><id>https://xihuai18.github.io/reinforcement-learning/2025/12/01/kl-estimators-zh</id><content type="html" xml:base="https://xihuai18.github.io/reinforcement-learning/2025/12/01/kl-estimators-zh.html"><![CDATA[<p><img src="/assets/img/kl-estimators/kl-estimator-zh.png" alt="Mini-class" style="display:block;margin:0 auto;width:95%;max-width:100%;" /></p>

<blockquote>
  <p>在强化学习中，KL 散度的估计方式直接影响训练稳定性。本文系统剖析三种经典估计器 ⟦INLMATH61MATHEND⟧ 在 on-policy 和 off-policy 场景的性质差异，并给出「用于 reward 惩罚」与「用于 loss 回传」时的选型指南。</p>
</blockquote>

<h2 id="引言kl-散度在强化学习中的角色">引言：KL 散度在强化学习中的角色</h2>

<p>在策略优化（PPO、GRPO 等）或对齐训练（RLHF/RLAIF）中，<strong>KL 惩罚</strong>是约束新策略不偏离参考策略的核心手段，用以防止训练不稳定或策略崩溃。然而，KL 惩罚的实现涉及多个层次的选择：<strong>用哪个估计器</strong>（⟦INLMATH62MATHEND⟧, ⟦INLMATH63MATHEND⟧, ⟦INLMATH64MATHEND⟧）、<strong>从谁采样</strong>（on-policy vs off-policy）、以及<strong>如何使用</strong>（作为 reward shaping 还是作为 loss 回传）。本文将系统地拆解这些选择及其相互关系。</p>

<h3 id="正向-kl-与反向-kl-的区别">正向 KL 与反向 KL 的区别</h3>

<p>设 ⟦INLMATH65MATHEND⟧ 为当前 actor 策略，⟦INLMATH66MATHEND⟧ 为参考策略，两种方向的 KL 散度分别为：</p>

<p><strong>反向 KL（Reverse KL）</strong>：
⟦DISPMATH1MATHEND⟧</p>

<figure style="text-align:center;">
  <img src="/assets/img/kl-estimators/kl-estimator-reverse.png" style="width:80%;max-width:100%;" />
  <figcaption style="font-size:0.9em;color:gray;">图片来源：<a href="https://dibyaghosh.com/blog/probability/kldivergence/">Dibya Ghosh's Blog</a></figcaption>
</figure>

<p><strong>正向 KL（Forward KL）</strong>：
⟦DISPMATH60MATHEND⟧</p>

<figure style="text-align:center;">
  <img src="/assets/img/kl-estimators/kl-estimator-forward.png" style="width:80%;max-width:100%;" />
  <figcaption style="font-size:0.9em;color:gray;">图片来源：<a href="https://dibyaghosh.com/blog/probability/kldivergence/">Dibya Ghosh's Blog</a></figcaption>
</figure>

<p><strong>直觉理解</strong>：</p>
<ul>
  <li><strong>反向 KL</strong> 倾向于「模式寻优」（mode-seeking）——策略会集中在参考分布的高概率区域，可能牺牲多样性</li>
  <li><strong>正向 KL</strong> 倾向于「质量覆盖」（mass-covering）——策略会尽量覆盖参考分布的支撑集</li>
</ul>

<p>在 RLHF 的主流实现中，<strong>反向 KL</strong> 更为常见，因为我们希望 actor 不要偏离 reference policy 太远，而非要求完全覆盖所有模式。</p>

<h2 id="三种估计器的定义与设计原理">三种估计器的定义与设计原理</h2>

<p>设比值 ⟦INLMATH67MATHEND⟧，John Schulman 提出的三种单样本估计子定义如下：</p>

<h3 id="inlmath68mathend最朴素的估计器">⟦INLMATH68MATHEND⟧：最朴素的估计器</h3>

<p>⟦DISPMATH2MATHEND⟧</p>

<p>这是最直接的定义——直接取 log-ratio 的负值。它对反向 KL 无偏，但有一个致命缺陷：<strong>可能取负值</strong>，而 KL 散度始终非负。这导致其方差极高，因为正负样本会相互抵消。</p>

<h3 id="inlmath69mathend基于-f-散度的低方差估计器">⟦INLMATH69MATHEND⟧：基于 f-散度的低方差估计器</h3>

<p>⟦DISPMATH3MATHEND⟧</p>

<p><strong>设计动机</strong>：⟦INLMATH70MATHEND⟧ 的问题在于可正可负，而 ⟦INLMATH71MATHEND⟧ 通过取平方保证<strong>每个样本都是正的</strong>，直观上每个样本都在告诉你 ⟦INLMATH72MATHEND⟧ 和 ⟦INLMATH73MATHEND⟧ 相差多远。</p>

<p><strong>为什么偏差很小？</strong> ⟦INLMATH74MATHEND⟧ 本质上是一个 <strong>f-散度</strong>（f-divergence），其中 ⟦INLMATH75MATHEND⟧。f-散度有一个优美的性质：<strong>所有可微的 f-散度在 ⟦INLMATH76MATHEND⟧ 时，二阶展开都形如</strong></p>

<p>⟦DISPMATH4MATHEND⟧</p>

<p>其中 ⟦INLMATH77MATHEND⟧ 是 Fisher 信息矩阵。KL 散度对应 ⟦INLMATH78MATHEND⟧，有 ⟦INLMATH79MATHEND⟧；而 ⟦INLMATH80MATHEND⟧ 对应的 ⟦INLMATH81MATHEND⟧，同样有 ⟦INLMATH82MATHEND⟧。这意味着<strong>当策略接近时，⟦INLMATH83MATHEND⟧ 与真实 KL 的行为几乎一致</strong>，偏差仅体现在高阶项。</p>

<h3 id="inlmath84mathend控制变量法构造的最优估计器">⟦INLMATH84MATHEND⟧：控制变量法构造的「最优」估计器</h3>

<p>⟦DISPMATH5MATHEND⟧</p>

<p><strong>设计动机</strong>：我们想要一个<strong>既无偏又低方差</strong>的估计器。标准做法是给 ⟦INLMATH85MATHEND⟧ 加一个<strong>控制变量</strong>（control variate）——一个期望为零但与 ⟦INLMATH86MATHEND⟧ 负相关的量。</p>

<p>注意到 ⟦INLMATH87MATHEND⟧，所以对于任意 ⟦INLMATH88MATHEND⟧，</p>

<p>⟦DISPMATH6MATHEND⟧</p>

<p>仍然是无偏估计。</p>

<p><strong>为什么选 ⟦INLMATH89MATHEND⟧？</strong> 由于 ⟦INLMATH90MATHEND⟧ 是凹函数，有 ⟦INLMATH91MATHEND⟧，因此</p>

<p>⟦DISPMATH7MATHEND⟧</p>

<p><strong>始终非负</strong>！这保证了每个样本都在「正向」贡献信息，消除了 ⟦INLMATH92MATHEND⟧ 正负抵消的问题。</p>

<p><strong>几何直觉</strong>：⟦INLMATH93MATHEND⟧ 实际上是一个 <strong>Bregman 散度</strong>。考虑凸函数 ⟦INLMATH94MATHEND⟧，它在 ⟦INLMATH95MATHEND⟧ 处的切线为 ⟦INLMATH96MATHEND⟧。Bregman 散度定义为「函数值与切线值之差」：</p>

<p>⟦DISPMATH8MATHEND⟧</p>

<p>由于凸函数始终位于其切线上方，这个差值<strong>天然非负</strong>。更重要的是，在 ⟦INLMATH97MATHEND⟧ 时，函数与切线「贴合」得越来越紧，差值以 ⟦INLMATH98MATHEND⟧ 的二阶速度趋近于零——这正是 ⟦INLMATH99MATHEND⟧ 在策略接近时方差小的根本原因。</p>

<h3 id="三者对比总结">三者对比总结</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: center">估计器</th>
      <th style="text-align: center">定义</th>
      <th style="text-align: center">设计原理</th>
      <th style="text-align: center">对数值的偏差</th>
      <th style="text-align: center">方差特性</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">⟦INLMATH100MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH101MATHEND⟧</td>
      <td style="text-align: center">最朴素定义</td>
      <td style="text-align: center">无偏</td>
      <td style="text-align: center">高（可正可负）</td>
    </tr>
    <tr>
      <td style="text-align: center">⟦INLMATH102MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH103MATHEND⟧</td>
      <td style="text-align: center">f-散度，二阶行为与 KL 一致</td>
      <td style="text-align: center">有偏（但极小）</td>
      <td style="text-align: center">低（恒正）</td>
    </tr>
    <tr>
      <td style="text-align: center">⟦INLMATH104MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH105MATHEND⟧</td>
      <td style="text-align: center">控制变量 + Bregman 散度</td>
      <td style="text-align: center">无偏</td>
      <td style="text-align: center">低（恒正）</td>
    </tr>
  </tbody>
</table>

<p>从数值估计的角度看，⟦INLMATH106MATHEND⟧ 是「无偏 + 低方差」的最优选择；但正如后文将分析的，<strong>梯度层面的故事完全不同</strong>——不同估计器的梯度可能对应不同的优化目标。此外，KL 是加入 reward 做 shaping，还是作为 loss 直接回传梯度，也会根本性地影响训练行为。</p>

<h2 id="核心分析">核心分析</h2>

<h3 id="估计-kl-数值时的偏差与方差">估计 KL 数值时的偏差与方差</h3>

<p>假设从 ⟦INLMATH107MATHEND⟧ 采样来估计反向 KL ⟦INLMATH108MATHEND⟧：</p>

<p><strong>无偏性分析</strong>：</p>

<p>⟦DISPMATH9MATHEND⟧</p>

<p><strong>结论</strong>：对于估计反向 KL 的<strong>数值</strong>，⟦INLMATH109MATHEND⟧ 和 ⟦INLMATH110MATHEND⟧ 是无偏估计，而 ⟦INLMATH111MATHEND⟧ 是有偏的。</p>

<p><strong>方差特性的 Trade-off</strong>：</p>

<p>John Schulman 的实验（⟦INLMATH112MATHEND⟧，⟦INLMATH113MATHEND⟧，真实 KL = 0.005）表明：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">估计器</th>
      <th style="text-align: center">bias/true</th>
      <th style="text-align: center">stdev/true</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">⟦INLMATH114MATHEND⟧</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">20</td>
    </tr>
    <tr>
      <td style="text-align: center">⟦INLMATH115MATHEND⟧</td>
      <td style="text-align: center">0.002</td>
      <td style="text-align: center">1.42</td>
    </tr>
    <tr>
      <td style="text-align: center">⟦INLMATH116MATHEND⟧</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">1.42</td>
    </tr>
  </tbody>
</table>

<p>当 KL 较大时（⟦INLMATH117MATHEND⟧，真实 KL = 0.5）：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">估计器</th>
      <th style="text-align: center">bias/true</th>
      <th style="text-align: center">stdev/true</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">⟦INLMATH118MATHEND⟧</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">2</td>
    </tr>
    <tr>
      <td style="text-align: center">⟦INLMATH119MATHEND⟧</td>
      <td style="text-align: center">0.25</td>
      <td style="text-align: center">1.73</td>
    </tr>
    <tr>
      <td style="text-align: center">⟦INLMATH120MATHEND⟧</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">1.7</td>
    </tr>
  </tbody>
</table>

<p><strong>核心直觉</strong>：</p>
<ul>
  <li>⟦INLMATH121MATHEND⟧ 以一阶项起步，当 ⟦INLMATH122MATHEND⟧ 接近 1 时波动较大，且可能取负值</li>
  <li>⟦INLMATH123MATHEND⟧ 在 ⟦INLMATH124MATHEND⟧ 处是二阶小量，始终非负，因此在策略接近时方差更小</li>
  <li>但当覆盖严重不足（⟦INLMATH125MATHEND⟧ 可能爆炸）时，⟦INLMATH126MATHEND⟧ 的方差会被权重爆炸拖累；此时 ⟦INLMATH127MATHEND⟧ 反而更稳定</li>
</ul>

<blockquote>
  <p><strong>注</strong>：若要估计<strong>正向 KL 的数值</strong> ⟦INLMATH128MATHEND⟧，而只能从 ⟦INLMATH129MATHEND⟧ 采样，可用重要性采样 ⟦INLMATH130MATHEND⟧。</p>
</blockquote>

<h3 id="估计-kl-梯度时的关键区分">估计 KL 梯度时的关键区分</h3>

<p><strong>这是最容易混淆、也是实践中最关键的部分。</strong> 本节先分析<strong>从 ⟦INLMATH131MATHEND⟧ 采样</strong>（on-policy）的情形，后文将进一步讨论从行为策略 ⟦INLMATH132MATHEND⟧ 采样（off-policy）时的变化。</p>

<h4 id="正向与反向-kl-真梯度的推导">正向与反向 KL 真梯度的推导</h4>

<p>在分析估计器之前，我们先推导正向和反向 KL 散度对 ⟦INLMATH133MATHEND⟧ 的<strong>真梯度</strong>作为参照。</p>

<p>记 score function ⟦INLMATH134MATHEND⟧，它有一个重要性质：⟦INLMATH135MATHEND⟧（因为 ⟦INLMATH136MATHEND⟧）。</p>

<p><strong>反向 KL 的梯度</strong>：</p>

<p>⟦DISPMATH10MATHEND⟧</p>

<p>对 ⟦INLMATH137MATHEND⟧ 求梯度（使用乘积法则）：</p>

<p>⟦DISPMATH11MATHEND⟧</p>

<p>利用 ⟦INLMATH138MATHEND⟧ 以及 ⟦INLMATH139MATHEND⟧、⟦INLMATH140MATHEND⟧：</p>

<p>⟦DISPMATH12MATHEND⟧</p>

<p>即：</p>

<p>⟦DISPMATH13MATHEND⟧</p>

<p><strong>正向 KL 的梯度</strong>：</p>

<p>⟦DISPMATH14MATHEND⟧</p>

<p>由于 ⟦INLMATH141MATHEND⟧ 不依赖于 ⟦INLMATH142MATHEND⟧：</p>

<p>⟦DISPMATH15MATHEND⟧</p>

<p>为了用 ⟦INLMATH143MATHEND⟧ 的样本估计这个量，进行重要性采样：</p>

<p>⟦DISPMATH16MATHEND⟧</p>

<p>利用 ⟦INLMATH144MATHEND⟧，可改写为：</p>

<p>⟦DISPMATH17MATHEND⟧</p>

<p>有了这两个结果，我们就能判断各估计器的梯度期望究竟对应哪个 KL 的真梯度。</p>

<h4 id="两种求导顺序">两种求导顺序</h4>

<p>在代码实现中，存在两条路径：</p>

<ol>
  <li><strong>先梯度、后期望</strong>：对每个样本的 ⟦INLMATH145MATHEND⟧ 求梯度，再对梯度求期望（Monte Carlo 估计）</li>
  <li><strong>先期望、后梯度</strong>：把 ⟦INLMATH146MATHEND⟧ 当作损失函数，对解析表达式求梯度</li>
</ol>

<p><strong>在典型的深度学习代码中，我们实际执行的是「先梯度、后期望」</strong>——自动微分对每个样本计算梯度，然后在 batch 上取平均。</p>

<h4 id="三种估计器的梯度推导">三种估计器的梯度推导</h4>

<p>现在我们计算三种估计器的梯度，看它们的期望分别对应哪个 KL 的真梯度。</p>

<p><strong>推导 ⟦INLMATH147MATHEND⟧</strong>：</p>

<p>⟦DISPMATH18MATHEND⟧</p>

<p>⟦DISPMATH19MATHEND⟧</p>

<p><strong>推导 ⟦INLMATH148MATHEND⟧</strong>：</p>

<p>⟦DISPMATH20MATHEND⟧</p>

<p>由链式法则：</p>

<p>⟦DISPMATH21MATHEND⟧</p>

<p><strong>推导 ⟦INLMATH149MATHEND⟧</strong>：</p>

<p>⟦DISPMATH22MATHEND⟧</p>

<p>首先计算 ⟦INLMATH150MATHEND⟧。由于 ⟦INLMATH151MATHEND⟧：</p>

<p>⟦DISPMATH23MATHEND⟧</p>

<p>再计算 ⟦INLMATH152MATHEND⟧：</p>

<p>⟦DISPMATH24MATHEND⟧</p>

<p>因此：</p>

<p>⟦DISPMATH25MATHEND⟧</p>

<p>对它们在 ⟦INLMATH153MATHEND⟧ 下取期望：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Estimator</th>
      <th style="text-align: center">⟦INLMATH154MATHEND⟧</th>
      <th style="text-align: center">Equals</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">⟦INLMATH155MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH156MATHEND⟧</td>
      <td style="text-align: center">Zero (useless as loss)</td>
    </tr>
    <tr>
      <td style="text-align: center">⟦INLMATH157MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH158MATHEND⟧</td>
      <td style="text-align: center">Gradient of reverse KL</td>
    </tr>
    <tr>
      <td style="text-align: center">⟦INLMATH159MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH160MATHEND⟧</td>
      <td style="text-align: center">Gradient of forward KL</td>
    </tr>
  </tbody>
</table>

<p><strong>关键洞察</strong>：</p>
<ul>
  <li><strong>⟦INLMATH161MATHEND⟧ 的梯度</strong>等价于反向 KL 的真梯度——这是优化「约束策略不偏离 ref」的正确选择</li>
  <li><strong>⟦INLMATH162MATHEND⟧ 的梯度</strong>等价于正向 KL 的真梯度——这对应「覆盖型」目标</li>
  <li><strong>⟦INLMATH163MATHEND⟧ 的梯度期望恒为零</strong>——作为 loss 反传毫无意义！</li>
</ul>

<h4 id="先期望后梯度vs先梯度后期望">「先期望后梯度」vs「先梯度后期望」</h4>

<p>如果从解析角度把 ⟦INLMATH164MATHEND⟧ 当作一个关于 ⟦INLMATH165MATHEND⟧ 的函数再求梯度（即「先期望后梯度」），那么：</p>

<p>⟦DISPMATH26MATHEND⟧</p>

<p>⟦DISPMATH27MATHEND⟧</p>

<p>两者都给出反向 KL 的梯度。但在代码中直接对 ⟦INLMATH166MATHEND⟧ 的样本均值调用反传时，自动微分执行的是「先梯度后期望」，得到的是 ⟦INLMATH167MATHEND⟧，即<strong>正向 KL 的梯度</strong>。</p>

<p>这个区分非常重要：<strong>同一个估计器，两种求导顺序可能给出完全不同的结果</strong>。</p>

<h3 id="扩展从行为策略-inlmath168mathend-采样时的-kl-梯度估计">扩展：从行为策略 ⟦INLMATH168MATHEND⟧ 采样时的 KL 梯度估计</h3>

<p>前面的分析都默认<strong>样本来自当前策略 ⟦INLMATH169MATHEND⟧</strong>。然而在实际 RL 训练中，我们常常遇到这样的 off-policy 场景：</p>

<ul>
  <li>用旧策略或混合策略生成数据，再更新当前 actor ⟦INLMATH170MATHEND⟧</li>
  <li>离线 RL / 经验回放中，样本分布固定为 ⟦INLMATH171MATHEND⟧，而不是当前的 ⟦INLMATH172MATHEND⟧</li>
</ul>

<p>这时，如果我们仍然希望优化<strong>反向 KL</strong> ⟦INLMATH173MATHEND⟧，就必须引入<strong>重要性权重</strong>。</p>

<p>关于大模型 off-policy 场景的深入分析，可以参考我之前的博客：<a href="/reinforcement-learning/2025/11/15/three-policy-zh.html">从两策略到三策略：LLM RL 中行为策略–参考策略不一致下的 TRPO 扩展</a>。</p>

<h4 id="设置与记号">设置与记号</h4>

<p>仍然沿用前文的记号，现在加入采样分布 ⟦INLMATH174MATHEND⟧，并定义<strong>重要性权重</strong></p>

<p>⟦DISPMATH28MATHEND⟧</p>

<p>当从 ⟦INLMATH175MATHEND⟧ 采样时，用 ⟦INLMATH176MATHEND⟧ 的 batch 均值作为 loss，然后调用自动微分。那么三种估计器分别给出什么梯度？</p>

<p>一个关键差异是：</p>

<blockquote>
  <p><strong>以前</strong>的期望是 ⟦INLMATH177MATHEND⟧，分布本身依赖 ⟦INLMATH178MATHEND⟧；
<strong>现在</strong>的期望是 ⟦INLMATH179MATHEND⟧，而 ⟦INLMATH180MATHEND⟧ 与 ⟦INLMATH181MATHEND⟧ 无关。</p>
</blockquote>

<p>这会让「先期望后梯度」与「先梯度后期望」的关系发生根本变化。</p>

<h4 id="关键观察两种求导顺序的等价性">关键观察：两种求导顺序的等价性</h4>

<p>因为 ⟦INLMATH182MATHEND⟧ 与 ⟦INLMATH183MATHEND⟧ 无关，对任何关于 ⟦INLMATH184MATHEND⟧ 可微的函数 ⟦INLMATH185MATHEND⟧，有</p>

<p>⟦DISPMATH29MATHEND⟧</p>

<p>换句话说，<strong>代码中对样本均值反传（先梯度后期望）就等价于对解析形式求梯度（先期望后梯度）</strong>，不会再像 on-policy 时那样分裂成两个不同的结果。</p>

<p><strong>所以在 off-policy + 重要性加权 的情形下，对反向 KL 数值无偏的估计器 ⟦INLMATH186MATHEND⟧ 和 ⟦INLMATH187MATHEND⟧，它们的梯度期望都将对应于反向 KL 的真梯度。</strong></p>

<p>这是与 on-policy 情形的根本区别。</p>

<h4 id="数值层面无偏性仍然保持">数值层面：无偏性仍然保持</h4>

<p>由标准的重要性采样关系 ⟦INLMATH188MATHEND⟧，有</p>

<p>⟦DISPMATH30MATHEND⟧</p>

<p>⟦DISPMATH31MATHEND⟧</p>

<p>这与 on-policy 情形完全一致。</p>

<h4 id="梯度推导">梯度推导</h4>

<p>首先计算重要性权重的梯度。由 ⟦INLMATH189MATHEND⟧ 且 ⟦INLMATH190MATHEND⟧ 不依赖 ⟦INLMATH191MATHEND⟧：</p>

<p>⟦DISPMATH32MATHEND⟧</p>

<p>结合前文已推导的 ⟦INLMATH192MATHEND⟧，用乘积法则：</p>

<p><strong>⟦INLMATH193MATHEND⟧</strong>：</p>

<p>⟦DISPMATH33MATHEND⟧</p>

<p><strong>⟦INLMATH194MATHEND⟧</strong>：</p>

<p>⟦DISPMATH34MATHEND⟧</p>

<p><strong>⟦INLMATH195MATHEND⟧</strong>：</p>

<p>⟦DISPMATH35MATHEND⟧</p>

<p>代入 ⟦INLMATH196MATHEND⟧：</p>

<p>⟦DISPMATH36MATHEND⟧</p>

<p>因此有一个漂亮的简化：</p>

<p>⟦DISPMATH37MATHEND⟧</p>

<h4 id="哪些给出无偏的反向-kl-梯度">哪些给出无偏的反向 KL 梯度？</h4>

<p>利用 ⟦INLMATH197MATHEND⟧ 和 ⟦INLMATH198MATHEND⟧：</p>

<p><strong>⟦INLMATH199MATHEND⟧</strong>：</p>

<p>⟦DISPMATH38MATHEND⟧</p>

<p><strong>⟦INLMATH200MATHEND⟧</strong>：</p>

<p>⟦DISPMATH39MATHEND⟧</p>

<p>这是 ⟦INLMATH201MATHEND⟧ 这个 f-散度的真梯度，<strong>不是</strong>反向 KL 的梯度。</p>

<p><strong>⟦INLMATH202MATHEND⟧</strong>（⟦INLMATH203MATHEND⟧ 表示 detach）：</p>

<p>如果把重要性权重视为常数（在代码中 detach 掉），则：</p>

<p>⟦DISPMATH40MATHEND⟧</p>

<p>取期望：</p>

<p>⟦DISPMATH41MATHEND⟧</p>

<p>这正是反向 KL 的真梯度！</p>

<p><strong>⟦INLMATH204MATHEND⟧</strong>：</p>

<p>⟦DISPMATH42MATHEND⟧</p>

<p><strong>总结表格</strong>：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">加权估计器</th>
      <th style="text-align: center">期望对应的目标</th>
      <th style="text-align: center">梯度期望对应的真梯度</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">⟦INLMATH205MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH206MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH207MATHEND⟧（反向 KL） ✓</td>
    </tr>
    <tr>
      <td style="text-align: center">⟦INLMATH208MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH209MATHEND⟧（f-散度）</td>
      <td style="text-align: center">⟦INLMATH210MATHEND⟧，不是反向 KL ✗</td>
    </tr>
    <tr>
      <td style="text-align: center">⟦INLMATH211MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH212MATHEND⟧（f-散度）</td>
      <td style="text-align: center">⟦INLMATH213MATHEND⟧（反向 KL） ✓</td>
    </tr>
    <tr>
      <td style="text-align: center">⟦INLMATH214MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH215MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH216MATHEND⟧（反向 KL） ✓</td>
    </tr>
  </tbody>
</table>

<p><strong>与 on-policy 情形的对比——一个有趣的反转</strong>：</p>

<ul>
  <li>On-policy 时，用 ⟦INLMATH217MATHEND⟧ 做 loss 的梯度是反向 KL，而 ⟦INLMATH218MATHEND⟧ 的梯度期望恒为零</li>
  <li>Off-policy + 重要性加权时，⟦INLMATH219MATHEND⟧ 和 ⟦INLMATH220MATHEND⟧ 给出反向 KL 的真梯度，而 ⟦INLMATH221MATHEND⟧（权重参与梯度计算）<strong>不再适用</strong></li>
  <li>但如果把重要性权重 <strong>detach</strong> 掉，⟦INLMATH222MATHEND⟧ 的梯度也是反向 KL 的真梯度</li>
</ul>

<h4 id="三个无偏梯度估计器的方差对比">三个无偏梯度估计器的方差对比</h4>

<p>前一小节我们看到，在 off-policy + 重要性采样的设置下，下面三个 loss 都给出<strong>反向 KL</strong> 的无偏梯度估计：</p>

<p>⟦DISPMATH43MATHEND⟧</p>

<p>其中 ⟦INLMATH223MATHEND⟧，⟦INLMATH224MATHEND⟧ 表示对权重做 stop-gradient。它们对应的梯度随机变量为：</p>

<p>⟦DISPMATH44MATHEND⟧</p>

<p>利用前文已推导的结果：</p>

<ul>
  <li>⟦INLMATH225MATHEND⟧;</li>
  <li>⟦INLMATH226MATHEND⟧;</li>
  <li>⟦INLMATH227MATHEND⟧;</li>
  <li>⟦INLMATH228MATHEND⟧.</li>
</ul>

<p>有：</p>

<p>⟦DISPMATH45MATHEND⟧</p>

<p>最后一步用到了 ⟦INLMATH229MATHEND⟧。于是出现了一个非常关键的事实：</p>

<blockquote>
  <p>在 off-policy + detach 权重的情况下，⟦INLMATH230MATHEND⟧ 与 ⟦INLMATH231MATHEND⟧ 的梯度完全一样：⟦INLMATH232MATHEND⟧。</p>
</blockquote>

<p>换言之，三个 loss 实际上只对应<strong>两种</strong>不同的梯度随机变量：⟦INLMATH233MATHEND⟧ 与 ⟦INLMATH234MATHEND⟧。</p>

<p>下面就比较这两种随机变量的方差。</p>

<p>为简化记号，令</p>

<p>⟦DISPMATH46MATHEND⟧</p>

<p>则</p>

<p>⟦DISPMATH47MATHEND⟧</p>

<p>两者的期望都等于 ⟦INLMATH235MATHEND⟧，因此有相同的均值项。展开方差定义并相减得到：</p>

<p>⟦DISPMATH48MATHEND⟧</p>

<p>也就是</p>

<p>⟦DISPMATH49MATHEND⟧</p>

<p>在常见的 KL 惩罚 regime 下，⟦INLMATH236MATHEND⟧，取 ⟦INLMATH237MATHEND⟧，⟦INLMATH238MATHEND⟧。此时 ⟦INLMATH239MATHEND⟧，因此 ⟦INLMATH240MATHEND⟧，主导项为正的 ⟦INLMATH241MATHEND⟧ 常数。这意味着上式右侧近似为 ⟦INLMATH242MATHEND⟧，从而 ⟦INLMATH243MATHEND⟧。</p>

<p>更具体地，一阶近似</p>

<p>⟦DISPMATH50MATHEND⟧</p>

<p>于是</p>

<p>⟦DISPMATH51MATHEND⟧</p>

<p>核心直觉：</p>

<ul>
  <li>⟦INLMATH244MATHEND⟧ 包含一个量级为 ⟦INLMATH245MATHEND⟧ 的零均值噪声项 ⟦INLMATH246MATHEND⟧，导致单样本方差较大；</li>
  <li>⟦INLMATH247MATHEND⟧ 已把该常数噪声项消去，剩下与 ⟦INLMATH248MATHEND⟧ 成正比的一阶小量，方差为 ⟦INLMATH249MATHEND⟧，显著更小。</li>
</ul>

<p>小结表格：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">估计器</th>
      <th style="text-align: center">梯度随机变量</th>
      <th style="text-align: center">系数量级（⟦INLMATH250MATHEND⟧）</th>
      <th style="text-align: center">方差</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">⟦INLMATH251MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH252MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH253MATHEND⟧</td>
      <td style="text-align: center">高</td>
    </tr>
    <tr>
      <td style="text-align: center">⟦INLMATH254MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH255MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH256MATHEND⟧</td>
      <td style="text-align: center">低</td>
    </tr>
    <tr>
      <td style="text-align: center">⟦INLMATH257MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH258MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH259MATHEND⟧</td>
      <td style="text-align: center">低</td>
    </tr>
  </tbody>
</table>

<p>结论：在 off-policy + 重要性采样的设置下，给出反向 KL 真梯度的无偏估计器有三个：⟦INLMATH260MATHEND⟧。其中 ⟦INLMATH261MATHEND⟧ 与 ⟦INLMATH262MATHEND⟧ 在梯度层面完全等价——同均值、同方差、同高阶矩；相比之下，⟦INLMATH263MATHEND⟧ 的梯度多了一个零均值的常数噪声项 ⟦INLMATH264MATHEND⟧，在典型的 KL 惩罚 regime 下其方差大约高一个量级。</p>

<blockquote>
  <p>实践建议：若在 off-policy 场景下优化反向 KL，首选 ⟦INLMATH265MATHEND⟧ 或 ⟦INLMATH266MATHEND⟧（两者梯度等价且方差低）；⟦INLMATH267MATHEND⟧ 虽无偏但方差高，可作为备选并需配合 clipping/正则化。</p>
</blockquote>

<p><strong>极度 off-policy 时的警示</strong>：</p>

<p>当 ⟦INLMATH268MATHEND⟧ 与 ⟦INLMATH269MATHEND⟧ 差异很大——比如 ⟦INLMATH270MATHEND⟧ 在 ⟦INLMATH271MATHEND⟧ 的高密度区域几乎没有采样，或 ⟦INLMATH272MATHEND⟧ 在尾部爆炸——任何基于 ⟦INLMATH273MATHEND⟧ 的方法都会遭遇严重的方差问题。此时 ⟦INLMATH274MATHEND⟧（或 ⟦INLMATH275MATHEND⟧）相对 ⟦INLMATH276MATHEND⟧ 的优势不再有理论保证，需要结合 clipping、正则化等策略综合处理。</p>

<p>不过，在 RL 实践中我们通常会控制 KL 约束、限制 off-policy 程度（比如使用近邻策略 ⟦INLMATH277MATHEND⟧），在这个常见的 regime 里，可以相当有信心地说：</p>

<blockquote>
  <p><strong>如果已经决定用 off-policy + 重要性采样来优化反向 KL，推荐使用 ⟦INLMATH278MATHEND⟧ 或 ⟦INLMATH279MATHEND⟧（两者梯度等价且方差低）；相较之下，⟦INLMATH280MATHEND⟧ 方差更高。</strong></p>
</blockquote>

<p>这就是为什么 DeepSeek v3.2 技术报告中使用的是 ⟦INLMATH281MATHEND⟧ 作为 off-policy KL 惩罚的估计器。</p>

<figure style="text-align:center;">
<img src="/assets/img/kl-estimators/dpsk-3d2-k3.png" style="width:95%;max-width:100%;" />
<figcaption style="font-size:0.9em;color:gray;">图片来源：<a href="https://arxiv.org/pdf/2512.02556v1">DeepSeek v3.2 技术报告 3.1 章节</a></figcaption>
</figure>

<h4 id="小结">小结</h4>

<ul>
  <li>从行为策略 ⟦INLMATH282MATHEND⟧ 采样时，自然的 off-policy KL 估计为 ⟦INLMATH283MATHEND⟧。</li>
  <li><strong>数值上</strong>，⟦INLMATH284MATHEND⟧ 与 ⟦INLMATH285MATHEND⟧ 仍然是反向 KL 的无偏估计。</li>
  <li><strong>梯度上</strong>，因为 ⟦INLMATH286MATHEND⟧ 与 ⟦INLMATH287MATHEND⟧ 无关，「先期望后梯度」与「先梯度后期望」等价：
    <ul>
      <li>⟦INLMATH288MATHEND⟧</li>
      <li>⟦INLMATH289MATHEND⟧</li>
      <li>⟦INLMATH290MATHEND⟧</li>
    </ul>
  </li>
  <li><strong>方差上</strong>，⟦INLMATH291MATHEND⟧ 与 ⟦INLMATH292MATHEND⟧ 的梯度<strong>完全相同</strong>（两者都是 ⟦INLMATH293MATHEND⟧），在统计性质上等价。相比之下，⟦INLMATH294MATHEND⟧ 的梯度多了一个零均值噪声项 ⟦INLMATH295MATHEND⟧，在 ⟦INLMATH296MATHEND⟧ 的典型场景下方差显著更高。</li>
</ul>

<h3 id="梯度估计总览">梯度估计总览</h3>

<p>下表汇总了 on-policy 与 off-policy 两种场景下，各估计器的梯度期望及其对应的优化目标：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">采样来源</th>
      <th style="text-align: center">Loss</th>
      <th style="text-align: center">⟦INLMATH297MATHEND⟧ Loss 的期望</th>
      <th style="text-align: center">对应的优化目标</th>
      <th style="text-align: center">能否用于优化反向 KL？</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">⟦INLMATH298MATHEND⟧ (on)</td>
      <td style="text-align: center">⟦INLMATH299MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH300MATHEND⟧</td>
      <td style="text-align: center">无（梯度恒为零）</td>
      <td style="text-align: center">✗</td>
    </tr>
    <tr>
      <td style="text-align: center">⟦INLMATH301MATHEND⟧ (on)</td>
      <td style="text-align: center">⟦INLMATH302MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH303MATHEND⟧</td>
      <td style="text-align: center">反向 KL</td>
      <td style="text-align: center">✓</td>
    </tr>
    <tr>
      <td style="text-align: center">⟦INLMATH304MATHEND⟧ (on)</td>
      <td style="text-align: center">⟦INLMATH305MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH306MATHEND⟧</td>
      <td style="text-align: center">正向 KL</td>
      <td style="text-align: center">✗</td>
    </tr>
    <tr>
      <td style="text-align: center">⟦INLMATH307MATHEND⟧ (off)</td>
      <td style="text-align: center">⟦INLMATH308MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH309MATHEND⟧</td>
      <td style="text-align: center">反向 KL</td>
      <td style="text-align: center">✓（但方差较高）</td>
    </tr>
    <tr>
      <td style="text-align: center">⟦INLMATH310MATHEND⟧ (off)</td>
      <td style="text-align: center">⟦INLMATH311MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH312MATHEND⟧</td>
      <td style="text-align: center">f-散度（非 KL）</td>
      <td style="text-align: center">✗</td>
    </tr>
    <tr>
      <td style="text-align: center">⟦INLMATH313MATHEND⟧ (off)</td>
      <td style="text-align: center">⟦INLMATH314MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH315MATHEND⟧</td>
      <td style="text-align: center">反向 KL</td>
      <td style="text-align: center">✓</td>
    </tr>
    <tr>
      <td style="text-align: center">⟦INLMATH316MATHEND⟧ (off)</td>
      <td style="text-align: center">⟦INLMATH317MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH318MATHEND⟧</td>
      <td style="text-align: center">反向 KL</td>
      <td style="text-align: center">✓（推荐，低方差）</td>
    </tr>
  </tbody>
</table>

<p><strong>关键结论</strong>：</p>

<ol>
  <li><strong>On-policy 优化反向 KL</strong>：唯一正确选择是 ⟦INLMATH319MATHEND⟧</li>
  <li><strong>Off-policy 优化反向 KL</strong>：有三个正确选项：
    <ul>
      <li>⟦INLMATH320MATHEND⟧：无偏但方差较高</li>
      <li>⟦INLMATH321MATHEND⟧：无偏，与 ⟦INLMATH322MATHEND⟧ <strong>梯度完全等价</strong></li>
      <li>⟦INLMATH323MATHEND⟧：无偏且方差更低（与上一项等价，均为推荐选择）</li>
    </ul>
  </li>
  <li><strong>⟦INLMATH324MATHEND⟧（权重参与梯度）在 off-policy 下失效</strong>：这是一个容易被忽视的陷阱</li>
</ol>

<p>然而，在选定估计器之前，还有一个更基础的问题需要回答：<strong>KL 应该加进 reward 里，还是作为 loss 的一部分？</strong> 这一选择会从根本上影响优化行为和 credit assignment。</p>

<h2 id="kl-的两种使用方式作为-reward-vs-作为-loss">KL 的两种使用方式：作为 Reward vs 作为 Loss</h2>

<p>在实际实现中，KL 惩罚有两种截然不同的使用方式：加入 reward 进行 shaping（不需要回传梯度），或作为 loss 的一部分参与反传（需要梯度）。</p>

<p>这两种做法看似只是代码里一个 <code class="language-plaintext highlighter-rouge">detach</code> 的区别，实际上对应着截然不同的优化行为。</p>

<h3 id="两种用法的定义">两种用法的定义</h3>

<p><strong>KL 作为 Reward（stop-gradient）</strong>：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">kl</span> <span class="o">=</span> <span class="nf">compute_kl</span><span class="p">(</span><span class="n">log_prob_q</span><span class="p">,</span> <span class="n">log_prob_p</span><span class="p">).</span><span class="nf">detach</span><span class="p">()</span>
<span class="n">shaped_reward</span> <span class="o">=</span> <span class="n">reward</span> <span class="o">-</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">kl</span>
</code></pre></div></div>

<p>用 shaped reward 做标准 actor-critic 更新。</p>

<p><strong>KL 作为 Loss（backprop）</strong>：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">actor_loss</span> <span class="o">=</span> <span class="o">-</span><span class="n">advantage</span> <span class="o">*</span> <span class="n">log_prob</span> <span class="o">+</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">kl</span>  <span class="c1"># kl 参与梯度计算
</span></code></pre></div></div>

<p>Critic 只学环境价值，KL 作为 actor 的正则项回传梯度。</p>

<h3 id="核心差异一更新目标">核心差异一：更新目标</h3>

<p><strong>KL 作为 Reward</strong>：优化一个<strong>正则化后的新 MDP</strong>，奖励函数变为 ⟦INLMATH325MATHEND⟧。</p>

<p><strong>KL 作为 Loss</strong>：优化<strong>原任务 + 监督正则</strong>，KL 不改变 MDP 定义，只是外挂的约束项。</p>

<p><strong>直觉</strong>：前者是「改变游戏规则」，后者是「在原规则下加约束」。</p>

<h3 id="核心差异二actor-梯度">核心差异二：Actor 梯度</h3>

<p><strong>KL 作为 Reward</strong>：单一 policy gradient，KL 的影响<strong>通过 advantage 间接体现</strong>：</p>

<p>⟦DISPMATH52MATHEND⟧</p>

<p><strong>KL 作为 Loss</strong>：梯度分成两条独立路径：</p>

<p>⟦DISPMATH53MATHEND⟧</p>

<p><strong>关键区别</strong>：KL 的力量是「乘在 advantage 上」还是「单独一股力」。后者的 KL 梯度是确定性的，不受 critic 质量影响。</p>

<h3 id="核心差异三critic-学习目标">核心差异三：Critic 学习目标</h3>

<p><strong>KL 作为 Reward</strong>：Critic 学混合价值</p>

<p>⟦DISPMATH54MATHEND⟧</p>

<p><strong>KL 作为 Loss</strong>：Critic 只学环境价值</p>

<p>⟦DISPMATH55MATHEND⟧</p>

<p>后者分工更清晰，便于分别监控任务回报和 KL 散度。</p>

<h3 id="核心差异四credit-assignment">核心差异四：Credit Assignment</h3>

<p>考虑场景：前几步是路由行为，最后一步 reward 高但 KL 也大。</p>

<p><strong>KL 作为 Reward</strong>：末状态的大 KL 通过 TD <strong>回传到前面所有步骤</strong>，策略倾向于<strong>从根本上避开</strong>高 KL 区域——这是「规划性的 KL 预算分配」。</p>

<p><strong>KL 作为 Loss</strong>：末状态的 KL 只在该状态的梯度项里体现，策略仍愿意<strong>访问高回报区域，但局部修正</strong>行为。</p>

<h3 id="小结-1">小结</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: center">维度</th>
      <th style="text-align: center">KL 作为 Reward（stop-grad）</th>
      <th style="text-align: center">KL 作为 Loss（backprop）</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">更新目标</td>
      <td style="text-align: center">正则化后的新 MDP</td>
      <td style="text-align: center">原任务 + 监督正则</td>
    </tr>
    <tr>
      <td style="text-align: center">Actor 梯度</td>
      <td style="text-align: center">单一 PG，基于 shaped advantage</td>
      <td style="text-align: center">RL 梯度 + 显式 KL 梯度</td>
    </tr>
    <tr>
      <td style="text-align: center">Critic</td>
      <td style="text-align: center">学 ⟦INLMATH326MATHEND⟧：reward + KL 混合</td>
      <td style="text-align: center">学 ⟦INLMATH327MATHEND⟧：只看环境 reward</td>
    </tr>
    <tr>
      <td style="text-align: center">Credit Assignment</td>
      <td style="text-align: center">多步回传，有规划性</td>
      <td style="text-align: center">局部 per-state，无规划性</td>
    </tr>
  </tbody>
</table>

<p><strong>一句话总结</strong>：KL 作为 reward 让 agent「规划性地避开高 KL 路径」，约束更全局、更彻底；KL 作为 loss 让 agent「访问但局部修正」，约束更局部、更灵活。选择取决于你是否需要跨时间步的 KL 预算分配能力，以及希望约束是「预防性」还是「修正性」的。</p>

<h2 id="rl-实践指南">RL 实践指南</h2>

<p>结合前面对「估计器数学性质」和「使用方式」的分析，本节给出具体场景下的实践建议。</p>

<h3 id="kl-作为-reward-惩罚不需要梯度">KL 作为 Reward 惩罚（不需要梯度）</h3>

<p>当 KL 仅作为标量惩罚加入 reward shaping 时，我们只需要准确的<strong>数值估计</strong>，不需要反传梯度。此时应参考前文「估计 KL 数值时的偏差与方差」中的分析。</p>

<p><strong>推荐</strong>：</p>
<ul>
  <li>使用 <strong>⟦INLMATH328MATHEND⟧</strong> 或 <strong>⟦INLMATH329MATHEND⟧</strong>（两者对反向 KL 数值均无偏）</li>
  <li>当策略已接近参考策略时，⟦INLMATH330MATHEND⟧ 往往更低方差</li>
  <li>覆盖不足或尾部错配明显时，⟦INLMATH331MATHEND⟧ 更稳健</li>
  <li>Off-policy 时加重要性权重 ⟦INLMATH332MATHEND⟧ 即可</li>
</ul>

<blockquote>
  <p><strong>注</strong>：若想施加<strong>正向 KL 惩罚</strong>（偏向覆盖行为分布），数值上可用 ⟦INLMATH333MATHEND⟧ 或（若可从 ⟦INLMATH334MATHEND⟧ 采样）⟦INLMATH335MATHEND⟧。</p>
</blockquote>

<h3 id="kl-作为-loss需要梯度回传">KL 作为 Loss（需要梯度回传）</h3>

<p>当 KL 作为 loss 的一部分参与反传时，必须考虑梯度的正确性。</p>

<h4 id="on-policy优化反向-kl最常见场景">On-policy：优化反向 KL（最常见场景）</h4>

<p>目标：控制 actor 不偏离 reference policy。</p>

<p><strong>正确做法</strong>：使用 <strong>⟦INLMATH336MATHEND⟧</strong> 作为 loss。</p>

<p>⟦DISPMATH56MATHEND⟧</p>

<p>其梯度期望 ⟦INLMATH337MATHEND⟧ 正是反向 KL 的真梯度。</p>

<h4 id="on-policy优化正向-kl覆盖型场景">On-policy：优化正向 KL（覆盖型场景）</h4>

<p>目标：让策略覆盖参考分布的支撑集（如离线 RL、模仿学习等）。</p>

<p><strong>正确做法</strong>：使用 <strong>⟦INLMATH338MATHEND⟧</strong> 作为 loss。</p>

<p>⟦DISPMATH57MATHEND⟧</p>

<p>直接对 ⟦INLMATH339MATHEND⟧ 的样本均值调用反传，自动微分计算的就是 ⟦INLMATH340MATHEND⟧，即正向 KL 的梯度，无需额外处理。</p>

<h4 id="off-policy优化反向-kl">Off-policy：优化反向 KL</h4>

<p>目标：数据来自行为策略 ⟦INLMATH341MATHEND⟧，仍希望优化反向 KL。</p>

<p><strong>推荐做法</strong>：使用 <strong>⟦INLMATH342MATHEND⟧</strong> 或 <strong>⟦INLMATH343MATHEND⟧</strong> 作为 loss（两者梯度完全等价）。</p>

<p>⟦DISPMATH58MATHEND⟧</p>

<p>或</p>

<p>⟦DISPMATH59MATHEND⟧</p>

<ul>
  <li>梯度无偏</li>
  <li>在 ⟦INLMATH344MATHEND⟧ 时方差都显著更低</li>
</ul>

<p><strong>备选方案</strong>：使用 ⟦INLMATH345MATHEND⟧（梯度同样无偏，但方差更高）</p>

<p><strong>避免</strong>：使用 ⟦INLMATH346MATHEND⟧（权重参与梯度计算）——梯度有偏，不是反向 KL 的正确方向</p>

<h2 id="一份拿来就用的对照表">一份「拿来就用」的对照表</h2>

<p>下表按「目标 KL 方向」×「采样来源」×「使用方式」三个维度给出推荐的估计器选择。其中「用于<strong>数值</strong>」对应 KL 作为 reward 惩罚（不需要梯度），「用于<strong>梯度</strong>」对应 KL 作为 loss（需要反传梯度）。</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">目标</th>
      <th style="text-align: center">采样来源</th>
      <th style="text-align: center">用于数值（KL 作为 Reward）</th>
      <th style="text-align: center">用于梯度（KL 作为 Loss）</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">反向 KL ⟦INLMATH347MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH348MATHEND⟧（on-policy）</td>
      <td style="text-align: center">⟦INLMATH349MATHEND⟧ 或 ⟦INLMATH350MATHEND⟧（无偏）</td>
      <td style="text-align: center">⟦INLMATH351MATHEND⟧</td>
    </tr>
    <tr>
      <td style="text-align: center">反向 KL ⟦INLMATH352MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH353MATHEND⟧（off-policy）</td>
      <td style="text-align: center">⟦INLMATH354MATHEND⟧ 或 ⟦INLMATH355MATHEND⟧（无偏）</td>
      <td style="text-align: center">⟦INLMATH356MATHEND⟧（推荐）或 ⟦INLMATH357MATHEND⟧</td>
    </tr>
    <tr>
      <td style="text-align: center">正向 KL ⟦INLMATH358MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH359MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH360MATHEND⟧</td>
      <td style="text-align: center">⟦INLMATH361MATHEND⟧</td>
    </tr>
  </tbody>
</table>

<h2 id="常见实现陷阱">常见实现陷阱</h2>

<p><strong>陷阱 1：把 ⟦INLMATH362MATHEND⟧ 直接当 loss 反传（on-policy）</strong></p>

<p>当 KL 作为 loss 使用时，⟦INLMATH363MATHEND⟧ 的梯度期望恒为零（⟦INLMATH364MATHEND⟧），作为 loss 完全无效。</p>

<blockquote>
  <p><strong>解决</strong>：首先明确 KL 的使用方式。如果是 reward shaping（不需要梯度），用 ⟦INLMATH365MATHEND⟧ 或 ⟦INLMATH366MATHEND⟧ 均可；如果是 loss（需要梯度），on-policy 下用 ⟦INLMATH367MATHEND⟧（反向 KL）或 ⟦INLMATH368MATHEND⟧（正向 KL）。</p>
</blockquote>

<p><strong>陷阱 2：混淆 ⟦INLMATH369MATHEND⟧ 的「数值无偏性」与「梯度对应的目标」</strong></p>

<p>⟦INLMATH370MATHEND⟧ 对<strong>反向 KL 的数值</strong>是无偏估计，但它的<strong>梯度</strong>对应的是<strong>正向 KL</strong>。如果你的目标是优化反向 KL，却用 ⟦INLMATH371MATHEND⟧ 作为 loss，实际上在优化正向 KL。</p>

<blockquote>
  <p><strong>解决</strong>：明确你的优化目标。优化反向 KL 用 ⟦INLMATH372MATHEND⟧；优化正向 KL 才用 ⟦INLMATH373MATHEND⟧。</p>
</blockquote>

<p><strong>陷阱 3：⟦INLMATH374MATHEND⟧ 重尾导致方差爆炸</strong></p>

<p>当策略与参考分布差异过大时，⟦INLMATH375MATHEND⟧ 可能出现极端值，导致 ⟦INLMATH376MATHEND⟧ 的方差爆炸。</p>

<blockquote>
  <p><strong>解决</strong>：控制 KL 约束，或对 ⟦INLMATH377MATHEND⟧ 进行 clipping。</p>
</blockquote>

<p><strong>陷阱 4：离策略下仍用 ⟦INLMATH378MATHEND⟧ 或 ⟦INLMATH379MATHEND⟧（权重参与梯度）</strong></p>

<p>在 on-policy 下，⟦INLMATH380MATHEND⟧ 是优化反向 KL 的正确选择。但如果数据来自 ⟦INLMATH381MATHEND⟧：</p>
<ul>
  <li>直接用 ⟦INLMATH382MATHEND⟧（不加权）：期望不是在 ⟦INLMATH383MATHEND⟧ 下取的，估计器完全失效</li>
  <li>用 ⟦INLMATH384MATHEND⟧（权重参与梯度计算）：梯度有偏，不是反向 KL 的真梯度</li>
</ul>

<blockquote>
  <p><strong>解决</strong>：离策略场景下，改用 ⟦INLMATH385MATHEND⟧（推荐）、⟦INLMATH386MATHEND⟧（将权重 detach）或 ⟦INLMATH387MATHEND⟧。</p>
</blockquote>

<p><strong>陷阱 5：对重要性权重的 detach 处理不当</strong></p>

<p>代码实现中，⟦INLMATH388MATHEND⟧ 通常通过 <code class="language-plaintext highlighter-rouge">log_prob_q - log_prob_mu</code> 再取 <code class="language-plaintext highlighter-rouge">exp</code> 计算得到。是否对 ⟦INLMATH389MATHEND⟧ 进行 detach 会导致完全不同的结果：</p>

<ul>
  <li><strong>使用 ⟦INLMATH390MATHEND⟧ 或 ⟦INLMATH391MATHEND⟧ 时</strong>：⟦INLMATH392MATHEND⟧ <strong>应该参与梯度计算</strong>（不要 detach），否则会丢失 ⟦INLMATH393MATHEND⟧ 这一项，导致梯度错误</li>
  <li><strong>使用 ⟦INLMATH394MATHEND⟧ 时</strong>：⟦INLMATH395MATHEND⟧ <strong>应该被 detach</strong>，这样才能得到反向 KL 的真梯度。如果让 ⟦INLMATH396MATHEND⟧ 参与梯度计算，得到的是 f-散度的梯度，不是反向 KL</li>
</ul>

<blockquote>
  <p><strong>总结</strong>：选择不同的估计器时，要注意匹配正确的 detach 策略。</p>
</blockquote>

<h2 id="总结">总结</h2>

<p><strong>一句话记忆</strong>：</p>

<ul>
  <li><strong>只要数值（KL 作为 reward 惩罚）</strong>：选 ⟦INLMATH397MATHEND⟧ 或 ⟦INLMATH398MATHEND⟧（均对反向 KL 无偏）；off-policy 时加重要性权重即可</li>
  <li><strong>需要梯度（KL 作为 loss）</strong>：
    <ul>
      <li><strong>On-policy</strong>：优化反向 KL → 用 ⟦INLMATH399MATHEND⟧；优化正向 KL → 用 ⟦INLMATH400MATHEND⟧</li>
      <li><strong>Off-policy</strong>：优化反向 KL → 用 ⟦INLMATH401MATHEND⟧ 或 ⟦INLMATH402MATHEND⟧（两者梯度等价，均为无偏 + 低方差的推荐选择）</li>
    </ul>
  </li>
</ul>

<p>把「<strong>从谁采样</strong>」、「<strong>估计谁的值</strong>」、「<strong>对谁求梯度</strong>」这三个问题捋清楚，三种估计器就不再让人混淆了。特别注意：<strong>on-policy 和 off-policy 下，优化反向 KL 的正确选择是不同的</strong>——前者用 ⟦INLMATH403MATHEND⟧，后者用 ⟦INLMATH404MATHEND⟧ 或 ⟦INLMATH405MATHEND⟧。</p>

<p>此外，别忘了在选择估计器之前先确定 <strong>KL 的使用方式</strong>：</p>
<ul>
  <li><strong>KL 作为 reward</strong>：约束通过 shaped advantage 间接作用于策略，具有跨时间步的 credit assignment 能力，agent 会「规划性地避开高 KL 路径」</li>
  <li><strong>KL 作为 loss</strong>：约束作为独立梯度项直接作用于策略，agent 会「访问但局部修正」</li>
</ul>

<p>这一选择比估计器本身更根本，取决于你希望约束是「预防性」还是「修正性」的。</p>

<h2 id="参考文献">参考文献</h2>

<ol>
  <li>
    <p>Dibya Ghosh. “KL Divergence for Machine Learning”. <a href="https://dibyaghosh.com/blog/probability/kldivergence">https://dibyaghosh.com/blog/probability/kldivergence</a></p>
  </li>
  <li>
    <p>John Schulman. “Approximating KL Divergence”. <a href="https://joschu.net/blog/kl-approx.html">https://joschu.net/blog/kl-approx.html</a></p>
  </li>
  <li>
    <p>Verl Documentation. “Proximal Policy Optimization (PPO)”. <a href="https://verl.readthedocs.io/en/latest/algo/ppo.html">https://verl.readthedocs.io/en/latest/algo/ppo.html</a></p>
  </li>
  <li>
    <p>初七123334. RLHF/RLVR 训练中的 KL 近似方法浅析（k1 / k2 / k3）. <a href="https://zhuanlan.zhihu.com/p/1966872846212010437">https://zhuanlan.zhihu.com/p/1966872846212010437</a></p>
  </li>
  <li>
    <p>Kezhao Liu, Jason Klein Liu, Mingtao Chen, Yiming Liu. “Rethinking KL Regularization in RLHF: From Value Estimation to Gradient Optimization”. <a href="https://arxiv.org/abs/2510.01555">https://arxiv.org/abs/2510.01555</a></p>
  </li>
  <li>
    <p>Yifan Zhang, Yiping Ji, Gavin Brown, et al. “On the Design of KL-Regularized Policy Gradient Algorithms for LLM Reasoning”. <a href="https://arxiv.org/abs/2505.17508">https://arxiv.org/abs/2505.17508</a></p>
  </li>
</ol>

<div class="language-bibtex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">@misc</span><span class="p">{</span><span class="nl">WangZhang2025KLEstimators</span><span class="p">,</span>
  <span class="na">author</span>       <span class="p">=</span> <span class="s">{Wang, Xihuai and Zhang, Shao}</span><span class="p">,</span>
  <span class="na">title</span>        <span class="p">=</span> <span class="s">{Understanding {KL} Divergence Estimators in {RL}: From Value Approximation to Gradient Estimation}</span><span class="p">,</span>
  <span class="na">year</span>         <span class="p">=</span> <span class="s">{2025}</span><span class="p">,</span>
  <span class="na">month</span>        <span class="p">=</span> <span class="nv">dec</span><span class="p">,</span>
  <span class="na">day</span>          <span class="p">=</span> <span class="s">{01}</span><span class="p">,</span>
  <span class="na">url</span>          <span class="p">=</span> <span class="s">{https://xihuai18.github.io/reinforcement-learning/2025/12/01/kl-estimators-en.html}</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="reinforcement-learning" /><summary type="html"><![CDATA[在强化学习中，KL 散度的估计方式直接影响训练稳定性。本文系统剖析三种经典估计器 k1, k2, k3 的性质差异，涵盖 on-policy 与 off-policy 两种场景，并给出「用于 reward 惩罚」与「用于 loss 回传」时的选型指南。]]></summary></entry><entry xml:lang="en"><title type="html">From Two Policies to Three: Extending TRPO under Behavior–Reference Policy Mismatch in LLM RL</title><link href="https://xihuai18.github.io/reinforcement-learning/2025/11/15/three-policy-en.html" rel="alternate" type="text/html" title="From Two Policies to Three: Extending TRPO under Behavior–Reference Policy Mismatch in LLM RL" /><published>2025-11-15T00:00:00+00:00</published><updated>2025-11-15T00:00:00+00:00</updated><id>https://xihuai18.github.io/reinforcement-learning/2025/11/15/three-policy-en</id><content type="html" xml:base="https://xihuai18.github.io/reinforcement-learning/2025/11/15/three-policy-en.html"><![CDATA[<p><img src="/assets/img/three-policy/three-policy-mini-class-en.png" alt="Mini-class" style="display:block;margin:0 auto;width:95%;max-width:100%;" /></p>

<h2 id="traininginference-mismatch-and-asynchronous-frameworks">Training–Inference Mismatch and Asynchronous Frameworks</h2>

<p>Recently I’ve seen quite a lot of discussion around <em>training–inference mismatch</em> and <em>asynchronous RL frameworks</em> for large language models. My intuition is that many of these seemingly diverse and complicated issues are, in fact, manifestations of a more fundamental tension: a mismatch between the <strong>behavior policy</strong> and the <strong>reference policy</strong>.</p>

<p>In this post, I’ll first briefly summarize the related work I’ve come across, and then try to connect them through the lens of “behavior policy vs. reference policy,” as a complementary way to look at the problem.</p>

<p>Throughout the post I’ll use:</p>

<ul>
  <li>
    <p><strong>Behavior policy</strong> ⟦INLMATH48MATHEND⟧: the policy that <em>actually</em> generates rollouts, i.e., “under which distribution your data are sampled.” In modern LLM RL systems this typically corresponds to the implementation inside the inference engine (vLLM, SGLang, etc.), and under asynchronous frameworks it is often a <strong>mixture distribution over multiple worker policies</strong>.</p>
  </li>
  <li>
    <p><strong>Reference policy</strong> ⟦INLMATH49MATHEND⟧: the policy used in the training objective for importance sampling, clipping, or KL constraints — typically the “old policy” in PPO / GRPO.</p>
  </li>
  <li>
    <p><strong>Target policy</strong> ⟦INLMATH50MATHEND⟧: the policy we optimize in the training objective, i.e., “what we want the model to become” — typically the “new policy” in PPO / GRPO.</p>
  </li>
</ul>

<p>In the classical idealized setup, we usually <strong>implicitly assume</strong> ⟦INLMATH51MATHEND⟧. In real systems, however, asynchronous updates, different inference / training backends, MoE routing fluctuations, and even hardware-level numerical differences cause these two policies to deviate to varying degrees.</p>

<h2 id="related-work">Related Work</h2>

<p>Below is a rough timeline of the works that left a strong impression on me (this is only a partial and biased subset of the literature I’ve seen):</p>

<ul>
  <li><a href="https://arxiv.org/pdf/2110.00641">Decoupled PPO</a> was among the first to point out that in trust-region policy optimization methods (TRPO and PPO), the “old policy” actually plays two distinct roles:
    <ol>
      <li>
        <p>It is used for importance sampling to perform off-policy correction. In this sense, the “old policy” is meant to represent the <strong>behavior policy</strong> that generated the training data.</p>
      </li>
      <li>
        <p>It is also used to limit the update step size of the new policy. In this sense, the “old policy” acts as a baseline to measure how much the new and old policies differ, i.e., a <strong>proximal policy</strong> (what I call the reference policy here).</p>
      </li>
    </ol>

    <p>The paper points out that these two roles do <em>not</em> have to be played by the same policy, and proposes the Decoupled PPO objective, which explicitly decouples “who generates the data” from “who defines the trust region” at the level of the optimization objective.</p>
  </li>
  <li>
    <p><a href="https://arxiv.org/abs/2505.24298">AReaL</a> focuses on the mismatch between behavior and reference policies under asynchronous training frameworks: rollouts are often generated by <strong>stale parameter versions</strong> or <strong>different workers</strong>. The paper adopts a Decoupled-PPO-style objective in the asynchronous setting, explicitly separating the behavior distribution from the reference policy, while still maintaining PPO-like optimization properties in this asynchronous regime.</p>
  </li>
  <li>
    <p><a href="https://arxiv.org/abs/2507.18071">GSPO</a> starts from stability issues of GRPO on long sequences and MoE models. It shows that token-level PPO / GRPO can become highly unstable when MoE expert routing is extremely volatile (especially when routing differs significantly between old and new policies), leading to large variance and training collapse. GSPO proposes a <strong>sequence-level</strong> PPO-style objective and ratio constraint, using the ratio over entire sequences to control updates. This substantially mitigates training collapse in MoE scenarios caused by routing instability and token-level noise.</p>
  </li>
  <li>
    <p><a href="https://fengyao.notion.site/off-policy-rl#28b721e3f6c480c3a756f8fb319e860d">Your Efficient RL Framework Secretly Brings You Off-Policy RL Training</a> observes that in existing LLM RL frameworks (such as VeRL), the inference stack and the training stack often differ across multiple functional modules (e.g., vLLM vs. FSDP / Megatron kernels and operators). This makes the behavior policy ⟦INLMATH52MATHEND⟧ differ from the reference policy ⟦INLMATH53MATHEND⟧, so what is <em>assumed</em> to be on-policy training actually becomes off-policy training with nontrivial bias. The article summarizes two existing ways to handle this: PPO-IS and vanilla-IS, and further proposes <strong>token-level truncated importance sampling (TIS)</strong> to downweight samples with severe training–inference mismatch. The author also wrote two more foundational notes analyzing training–inference mismatch from basic principles: <a href="https://fengyao.notion.site/pg-seq-token-part1-basics">Part I</a> and <a href="https://fengyao.notion.site/pg-seq-token-part2-mismatch">Part II</a>.</p>
  </li>
  <li>
    <p><a href="https://thinkingmachines.ai/blog/defeating-nondeterminism-in-llm-inference">Defeating Nondeterminism in LLM Inference</a> points out that the lack of <strong>batch-size invariance</strong> is a core source of randomness in LLM inference: the same input can yield noticeably different probability distributions under different batch compositions and kernel paths. This means that even when you “nominally” have a single set of parameters, the <strong>behavior policy</strong> ⟦INLMATH54MATHEND⟧ realized in practice can fluctuate with system load and scheduling, further exacerbating training–inference mismatch.</p>
  </li>
  <li>
    <p><a href="https://ringtech.notion.site/icepop">Small Leak Can Sink a Great Ship—Boost RL Training on MoE with 𝑰𝒄𝒆𝑷𝒐𝒑!</a> observes that the above mismatch issues are further amplified in MoE models: routing itself is highly sensitive to small perturbations, and stacked with inference / training implementation differences and asynchronous sampling, it is easy to magnify bias and instability. The paper proposes IcePop: at the <strong>token level</strong>, it computes importance sampling ratios and applies <strong>two-sided masking</strong> to discard tokens whose ratios are either too large or too small. This removes “very noisy” data from the gradient, stabilizing RL training on MoE models.</p>
  </li>
  <li>
    <p><a href="https://yingru.notion.site/When-Speed-Kills-Stability-Demystifying-RL-Collapse-from-the-Training-Inference-Mismatch-271211a558b7808d8b12d403fd15edda">When Speed Kills Stability: Demystifying RL Collapse from the Training-Inference Mismatch</a> gives a systematic analysis of the causes of training–inference mismatch, including large amounts of out-of-distribution and low-probability content introduced by agent workflows, hardware and kernel-level numerical uncertainty, and how <strong>token-level</strong> importance sampling can introduce severe bias on long sequences. It further proposes <strong>sequence-level</strong> masked importance sampling (sequence-level MIS): compute an IS ratio at the sequence level and discard only those sequences whose overall ratio is too large, thereby controlling bias while strongly suppressing training collapse caused by extreme samples. The paper provides reasonably complete theoretical derivations and extensive experimental evidence.</p>
  </li>
  <li>
    <p><a href="https://arxiv.org/abs/2510.11370">Stabilizing MoE Reinforcement Learning by Aligning Training and Inference Routers</a> focuses on the MoE-specific problem of <strong>routing inconsistency</strong>. The paper finds that even for identical inputs, inference and training can route tokens to different experts due to small differences in operator implementations or parallelism. This “physical-path” mismatch makes the gap between the behavior policy ⟦INLMATH55MATHEND⟧ and the reference policy ⟦INLMATH56MATHEND⟧ much larger than expected and can easily cause training collapse. To address this, the paper proposes <strong>Rollout Routing Replay (R3)</strong>: during rollout it records, for each token, the actual expert indices selected by the inference router, and during training it <strong>replays</strong> these routing decisions instead of recomputing them. In effect, R3 forces the training and inference stacks to share the same routing paths in the MoE topology, aligning the two sides at the level of the computation graph.</p>
  </li>
  <li>
    <p><a href="https://zhuanlan.zhihu.com/p/1959976628290590602">RL 老训崩？训推差异是基石</a> approaches the problem more from a practical perspective, sharing experience on how to engineer for near training–inference consistency: choosing consistent operators and precision settings, monitoring and constraining the log-prob gap between training and inference, etc. The focus is on framework-level engineering practices that can mitigate training–inference difference at the root.</p>
  </li>
  <li>
    <p><a href="https://verl.readthedocs.io/en/latest/algo/rollout_corr.html">verl Rollout Importance Sampling</a> introduces a <strong>Token Veto</strong> mechanism in its rollout correction module: it computes <strong>token-level</strong> importance ratios ⟦INLMATH57MATHEND⟧, and if any token in a trajectory satisfies ⟦INLMATH58MATHEND⟧, the entire sequence is discarded from training. This “token-level detection, sequence-level veto” design embodies a conservative “one-vote veto” strategy.</p>
  </li>
  <li><a href="https://storage.googleapis.com/intellect-3-paper/INTELLECT_3_Technical_Report.pdf">INTELLECT-3 Technical Report</a> adopts a similar rejection sampling strategy in its asynchronous distributed RL training framework. INTELLECT-3 computes <strong>token-level</strong> importance ratios for each rollout; if any token’s ratio falls below a threshold (⟦INLMATH59MATHEND⟧ in the paper), the entire trajectory is masked.</li>
</ul>

<h2 id="a-minimally-unified-view-from-a-three-policy-trpo-perspective">A Minimally Unified View from a Three-Policy TRPO Perspective</h2>

<p>At first glance, the works listed above seem to tackle different aspects:</p>

<ul>
  <li><strong>Algorithmic level</strong>: how to formulate PPO / GRPO objectives, token-level vs. sequence-level, clip vs. mask, etc.</li>
  <li><strong>Systems level</strong>: how to align inference and training stacks.</li>
  <li><strong>Model level</strong>: how MoE routing amplifies instability, and so on.</li>
</ul>

<p>However, if we align everything along a single axis — <strong>behavior policy vs. reference policy</strong> — a large fraction of these issues can be placed in a relatively simple theoretical framework: a <strong>three-policy TRPO</strong>.</p>

<p>In the next section I’ll unpack this three-policy TRPO in as simple math as I can. You can think of it as “TRPO + triangle inequality” — a very small extension conceptually, but surprisingly handy when analyzing training–inference mismatch in LLM RL:</p>

<ul>
  <li>On the one hand, it helps us understand what exactly “training–inference mismatch” and “asynchronous training frameworks” are harming within the TRPO view.</li>
  <li>On the other hand, it offers a unifying way to interpret TIS, IcePop, sequence-level MIS, etc. In the view of this post, they can all be seen as different incarnations of <strong>Constraint 2</strong> introduced below.</li>
</ul>

<h3 id="three-policies">Three Policies</h3>

<p>We stick to the notation from above and consider a discounted MDP with discount factor ⟦INLMATH60MATHEND⟧:</p>

<ul>
  <li>States ⟦INLMATH61MATHEND⟧, actions ⟦INLMATH62MATHEND⟧.</li>
  <li>Policy ⟦INLMATH63MATHEND⟧.</li>
  <li>Discounted state distribution:
⟦DISPMATH10MATHEND⟧</li>
  <li>Return (episodic view):
⟦DISPMATH11MATHEND⟧</li>
  <li>Value / Q / advantage functions:
⟦DISPMATH12MATHEND⟧</li>
</ul>

<p>It’s worth spelling out that in the three-policy setup we have:</p>

<ul>
  <li>
    <p><strong>Behavior policy</strong> ⟦INLMATH64MATHEND⟧: the policy that actually generates rollouts. Data ⟦INLMATH65MATHEND⟧ are sampled from it.</p>
  </li>
  <li>
    <p><strong>Reference policy</strong> ⟦INLMATH66MATHEND⟧: the “old policy” used in the optimization objective for importance sampling ratios, clipping, or KL constraints.</p>
  </li>
  <li>
    <p><strong>Target policy</strong> ⟦INLMATH67MATHEND⟧: the policy we are optimizing in this update.</p>
  </li>
</ul>

<p>In the ideal setup we assume ⟦INLMATH68MATHEND⟧; in real systems they are often unequal. This is the mathematical shadow of “training–inference mismatch.”</p>

<h3 id="two-policy-trpo">Two-Policy TRPO</h3>

<blockquote>
  <p>If you’re already familiar with TRPO, feel free to skip ahead to the “Three-Policy TRPO” subsection.</p>
</blockquote>

<p>All the theoretical guarantees in TRPO are stated <strong>with respect to the advantage function of some baseline policy</strong>. Since the only advantage we can estimate reliably in practice is ⟦INLMATH69MATHEND⟧ (data are sampled under ⟦INLMATH70MATHEND⟧), we may as well treat ⟦INLMATH71MATHEND⟧ as the baseline policy.</p>

<p>A classical result is the <strong>Performance Difference Lemma</strong>:</p>

<blockquote>
  <p>For any two policies ⟦INLMATH72MATHEND⟧ and ⟦INLMATH73MATHEND⟧, we have</p>

  <p>⟦DISPMATH1MATHEND⟧</p>
</blockquote>

<p>The intuition is simple:</p>

<ul>
  <li>⟦INLMATH74MATHEND⟧ says: “if I deviate from what ⟦INLMATH75MATHEND⟧ would do at state ⟦INLMATH76MATHEND⟧ and instead take action ⟦INLMATH77MATHEND⟧, how much will the long-term return change?”</li>
  <li>Summing that “gain” across all time steps, states, and actions gives the total improvement of the new policy over the behavior policy.</li>
</ul>

<p>The challenge in TRPO is that we cannot compute</p>

<p>⟦DISPMATH13MATHEND⟧</p>

<p>exactly, because ⟦INLMATH78MATHEND⟧ is the state distribution of the <em>new</em> policy, under which we do not have samples.</p>

<p>So TRPO introduces a surrogate objective by replacing the state distribution with that of the behavior policy:</p>

<p>⟦DISPMATH14MATHEND⟧</p>

<p>Intuitively, ⟦INLMATH79MATHEND⟧ asks the following question: “Under the states visited by the behavior policy, how good is the new policy if we just let it pick the actions?”</p>

<p>Starting from the Performance Difference Lemma, the difference between the true objective and the surrogate is:</p>

<p>⟦DISPMATH15MATHEND⟧</p>

<p>If we define</p>

<p>⟦DISPMATH16MATHEND⟧</p>

<p>we immediately get the following upper bound:</p>

<blockquote>
  <p><strong>Lemma 1</strong></p>

  <p>⟦DISPMATH2MATHEND⟧</p>
</blockquote>

<p>This reveals the first key quantity:</p>

<blockquote>
  <p><strong>State distribution shift</strong> ⟦INLMATH80MATHEND⟧, i.e., “how differently the new policy sees the world, compared to the behavior policy.”</p>
</blockquote>

<p>We usually do <em>not</em> directly impose constraints on ⟦INLMATH81MATHEND⟧. Instead, we constrain the per-timestep action distribution difference — via trust regions, KL penalties, clipping, etc.</p>

<p>Define the total variation (TV) distance:</p>

<p>⟦DISPMATH17MATHEND⟧</p>

<p>Assume there is a constant ⟦INLMATH82MATHEND⟧ such that</p>

<blockquote>
  <p>For all ⟦INLMATH83MATHEND⟧, the TV distance between the behavior and target policies is bounded:</p>

  <p>⟦DISPMATH3MATHEND⟧</p>
</blockquote>

<p>Intuitively: in any state, the action distribution of the “new policy” cannot deviate too much from that of the policy that generated the data.</p>

<p>A standard result (provable via coupling) is:</p>

<blockquote>
  <p><strong>Lemma 2</strong>
Under the assumption above,</p>

  <p>⟦DISPMATH4MATHEND⟧</p>
</blockquote>

<p>Combining Lemma 1 and Lemma 2, we obtain</p>

<p>⟦DISPMATH18MATHEND⟧</p>

<p>This gives a compact <strong>two-policy TRPO lower bound (baseline = behavior policy)</strong>:</p>

<blockquote>
  <p><strong>Theorem 1 (Two-Policy TRPO)</strong></p>

  <p>⟦DISPMATH5MATHEND⟧</p>
</blockquote>

<p>This suggests:</p>

<ul>
  <li><strong>What really matters for the tightness of ⟦INLMATH84MATHEND⟧ as a surrogate for ⟦INLMATH85MATHEND⟧ is how far the behavior policy ⟦INLMATH86MATHEND⟧ and the target policy ⟦INLMATH87MATHEND⟧ drift apart:</strong>
⟦DISPMATH19MATHEND⟧</li>
</ul>

<p>If you can directly control this ⟦INLMATH88MATHEND⟧, you can essentially port TRPO’s monotonic improvement guarantees to the behavior-policy view.</p>

<h3 id="three-policy-trpo">Three-Policy TRPO</h3>

<p>In practice, especially in large-scale LLM RL, <strong>we often cannot directly control ⟦INLMATH89MATHEND⟧ itself.</strong></p>

<p>In most PPO / GRPO / GSPO / RLHF-style frameworks, the actual situation is:</p>

<ul>
  <li>Rollout data are generated by some <strong>behavior policy</strong> ⟦INLMATH90MATHEND⟧ (some particular parameter version plus system details inside the inference engine).</li>
  <li>During updates, we would like to leverage a <strong>reference policy</strong> ⟦INLMATH91MATHEND⟧ to limit the update of the <strong>target policy</strong> ⟦INLMATH92MATHEND⟧.</li>
</ul>

<p>In other words, what we can actually touch and control are two quantities:</p>

<ol>
  <li>
    <p><strong>Reference vs. target</strong>: via KL penalties, clipping, etc., we constrain</p>

    <p>⟦DISPMATH20MATHEND⟧</p>
  </li>
  <li>
    <p><strong>Behavior vs. reference</strong>: we would <em>like</em> to keep
⟦DISPMATH21MATHEND⟧
small as well — this is where training–inference mismatch and asynchronous execution come in.</p>
  </li>
</ol>

<p>This motivates defining two “proxy gaps”:</p>

<ul>
  <li>
    <p><strong>Constraint 1: reference vs. target</strong></p>

    <p>⟦DISPMATH22MATHEND⟧</p>
  </li>
  <li>
    <p><strong>Constraint 2: behavior vs. reference</strong>
⟦DISPMATH23MATHEND⟧</p>
  </li>
</ul>

<p>Intuitively:</p>

<ul>
  <li>⟦INLMATH93MATHEND⟧: how far the new policy is from the “old policy” you are using in the loss — this is the trust-region part.</li>
  <li>⟦INLMATH94MATHEND⟧: how far the reference policy used in training is from the <em>actual</em> behavior policy that generated the data — this is the footprint of training–inference mismatch and asynchrony.</li>
</ul>

<p>Now we can plug these two quantities back into the TRPO lower bound.</p>

<p>For any state ⟦INLMATH95MATHEND⟧, by the triangle inequality we have</p>

<p>⟦DISPMATH24MATHEND⟧</p>

<p>Taking the supremum over ⟦INLMATH96MATHEND⟧ gives</p>

<p>⟦DISPMATH25MATHEND⟧</p>

<p>Plugging this inequality into the two-policy TRPO bound (Theorem 1), and denoting</p>

<p>⟦DISPMATH26MATHEND⟧</p>

<p>we obtain</p>

<p>⟦DISPMATH27MATHEND⟧</p>

<p>This yields a very direct <strong>three-policy TRPO lower bound</strong>:</p>

<blockquote>
  <p><strong>Theorem 2 (Three-Policy TRPO)</strong>
Let</p>

  <p>⟦DISPMATH6MATHEND⟧</p>

  <p>and</p>

  <p>⟦DISPMATH7MATHEND⟧</p>

  <p>Then for any target policy ⟦INLMATH97MATHEND⟧,</p>

  <p>⟦DISPMATH8MATHEND⟧</p>

  <p>where</p>

  <p>⟦DISPMATH9MATHEND⟧</p>
</blockquote>

<p>The meaning of this bound is quite straightforward:</p>

<ul>
  <li><strong>The gap between the surrogate objective ⟦INLMATH98MATHEND⟧ and the true performance ⟦INLMATH99MATHEND⟧ decomposes into two pieces:</strong>
    <ul>
      <li>The deviation between reference and target policies, ⟦INLMATH100MATHEND⟧.</li>
      <li>The deviation between behavior and reference policies, ⟦INLMATH101MATHEND⟧.</li>
    </ul>
  </li>
</ul>

<p>As long as both terms are small, <strong>optimizing ⟦INLMATH102MATHEND⟧ is likely to improve ⟦INLMATH103MATHEND⟧</strong>.</p>

<h3 id="how-to-control-these-two-deviations-in-practice">How to Control These Two Deviations in Practice?</h3>

<p>We can now revisit various practical methods through the lens of Theorem 2:</p>

<ul>
  <li>Most PPO / GRPO / GSPO-style work focuses on controlling <strong>Constraint 1: ⟦INLMATH104MATHEND⟧</strong>.</li>
  <li>Most TIS / IcePop / MIS-style work, in the view of this post, can be understood as primarily targeting <strong>Constraint 2: ⟦INLMATH105MATHEND⟧</strong>.</li>
</ul>

<p>In the remainder of this post I will focus on <strong>Constraint 2</strong>.</p>

<p>The goal of Constraint 2 is: <strong>ensure that the data used in training come (effectively) from a behavior policy that is close to the reference policy.</strong></p>

<p>In practice, this usually involves both <strong>system-level mechanisms</strong> and <strong>algorithmic mechanisms (importance sampling)</strong>.</p>

<ol>
  <li><strong>System level: keep the behavior policy from drifting too far</strong>
    <ul>
      <li>
        <p>Asynchronous frameworks:
Tag each sample with a policy version, and only use data generated by parameter versions that are close enough to ⟦INLMATH106MATHEND⟧.</p>
      </li>
      <li>
        <p>Training–inference alignment:
Use consistent precision, operators, and similar kernel behavior between the training and inference stacks.</p>
      </li>
    </ul>

    <p>These mechanisms act “outside” the algorithm to make ⟦INLMATH107MATHEND⟧ closer to ⟦INLMATH108MATHEND⟧, thereby shrinking ⟦INLMATH109MATHEND⟧.</p>
  </li>
  <li>
    <p><strong>Algorithmic level: sample-wise correction</strong></p>

    <p>At the algorithmic level, we no longer attempt to “fix” the entire behavior policy. Instead, we use importance sampling ratios to correct at the <strong>sample level</strong>: we filter or reweight samples so that the behavior policy is close to the reference policy <em>on the subset of data that actually participates in training</em>, or at least reduce the influence of samples with large mismatch.</p>

    <p>Concretely, this gives rise to methods like TIS, IcePop, and MIS, which can be seen as different ways of implementing Constraint 2 at the sample level.</p>
  </li>
</ol>

<h2 id="importance-sampling-and-masking-four-implementations-of-constraint-2">Importance Sampling and Masking: Four Implementations of Constraint 2</h2>

<p>In this section I’ll reuse the notation introduced above to write down the objectives of these three methods, focusing only on the design choices related to “behavior vs. reference policy.” Let the token-level PPO / GRPO-style update term be</p>

<p>⟦DISPMATH28MATHEND⟧</p>

<p>where</p>

<p>⟦DISPMATH29MATHEND⟧</p>

<p>Here:</p>

<ul>
  <li>⟦INLMATH110MATHEND⟧ is the <strong>target vs. reference</strong> ratio (corresponding to Constraint 1).</li>
  <li>⟦INLMATH111MATHEND⟧ is the advantage estimated from data sampled under the behavior policy.</li>
</ul>

<p>To connect token-level ⟦INLMATH112MATHEND⟧ with sequence-level ⟦INLMATH113MATHEND⟧ notation, consider the RLHF setting (reinforcement learning from human feedback) for LLMs:</p>

<ul>
  <li>Prompts are denoted by ⟦INLMATH114MATHEND⟧, and responses by ⟦INLMATH115MATHEND⟧.</li>
  <li>Token-level states and actions are defined as ⟦INLMATH116MATHEND⟧, ⟦INLMATH117MATHEND⟧.</li>
  <li>The behavior and reference policies on sequences can then be written as
⟦DISPMATH30MATHEND⟧</li>
</ul>

<p>To quantify the deviation between reference and behavior policies, we can define the token-level importance ratio:</p>

<p>⟦DISPMATH31MATHEND⟧</p>

<p>and its sequence-level counterpart:</p>

<p>⟦DISPMATH32MATHEND⟧</p>

<p>The difference between TIS, IcePop, and MIS lies in <strong>how they use ⟦INLMATH118MATHEND⟧ to implement Constraint 2</strong>.</p>

<h3 id="1-tis-token-level-truncated-importance-sampling">1. TIS: Token-Level Truncated Importance Sampling</h3>

<p>TIS directly truncates the token-level ratio ⟦INLMATH119MATHEND⟧; define</p>

<p>⟦DISPMATH33MATHEND⟧</p>

<p>The update objective becomes</p>

<p>⟦DISPMATH34MATHEND⟧</p>

<ul>
  <li>The blue ⟦INLMATH120MATHEND⟧ is the truncated IS weight: extremely large ratios are capped at a constant ⟦INLMATH121MATHEND⟧.</li>
  <li>From the three-policy TRPO perspective, this is a <em>soft</em> way to downweight tokens where behavior and reference policies differ significantly, effectively reducing their contribution to ⟦INLMATH122MATHEND⟧ in the gradient.</li>
</ul>

<h3 id="2-icepop-token-level-two-sided-masking-in-moe">2. IcePop: Token-Level Two-Sided Masking in MoE</h3>

<p>IcePop also uses ⟦INLMATH123MATHEND⟧ as a discrepancy measure, but opts for <strong>two-sided masking</strong>:</p>

<p>⟦DISPMATH35MATHEND⟧</p>

<p>The update objective becomes</p>

<p>⟦DISPMATH36MATHEND⟧</p>

<ul>
  <li>The blue ⟦INLMATH124MATHEND⟧ decides whether a token participates in the update: tokens with ratios that are too large or too small are dropped entirely.</li>
  <li>This is a <em>hard</em> sample selection scheme: only tokens where behavior and reference policies are reasonably aligned (ratios within ⟦INLMATH125MATHEND⟧) are kept, implementing a stricter version of Constraint 2 at the token level.</li>
</ul>

<h3 id="3-sequence-level-mis-masked-importance-sampling-over-entire-sequences">3. Sequence-Level MIS: Masked Importance Sampling Over Entire Sequences</h3>

<p>The core operation in sequence-level MIS is to <strong>retain only sequences whose sequence-level IS ratio is below a threshold ⟦INLMATH126MATHEND⟧</strong>, zeroing out the loss for all other sequences:</p>

<p>⟦DISPMATH37MATHEND⟧</p>

<p>In a unified loss form, this can be written as</p>

<p>⟦DISPMATH38MATHEND⟧</p>

<p>In words:</p>

<ul>
  <li>For <strong>sequences with small IS ratios</strong>, the full weight ⟦INLMATH127MATHEND⟧ is retained for off-policy correction.</li>
  <li>For <strong>sequences whose ratios exceed the threshold ⟦INLMATH128MATHEND⟧</strong>, the entire policy loss is masked out (weight set to ⟦INLMATH129MATHEND⟧).</li>
</ul>

<p>From the three-policy TRPO viewpoint, sequence-level MIS no longer truncates at the token level. Instead, it performs <strong>trajectory-level</strong> filtering: it drops trajectories where behavior and reference policies diverge too much, and only optimizes on the subset with ⟦INLMATH130MATHEND⟧. This implements Constraint 2 at the sequence level.</p>

<h3 id="4-worst-token-reject-sampling-rejecting-entire-sequences-based-on-the-worst-token">4. Worst Token Reject Sampling: Rejecting Entire Sequences Based on the Worst Token</h3>

<p>The verl Token Veto mechanism and INTELLECT-3 both adopt a rejection sampling strategy that can be collectively called <strong>Worst Token Reject Sampling (WTRS)</strong>:</p>

<ul>
  <li>
    <p><strong>verl Token Veto</strong>: In its rollout correction module, if any token in a trajectory has ⟦INLMATH131MATHEND⟧, the entire sequence is discarded via response*mask. The threshold ⟦INLMATH132MATHEND⟧ is user-configurable.</p>
  </li>
  <li>
    <p><strong>INTELLECT-3 Token Masking</strong>: In its asynchronous distributed RL framework, if any token’s ratio is below ⟦INLMATH133MATHEND⟧, the entire trajectory is masked.</p>
  </li>
</ul>

<p>The core operation is identical: <strong>if any token in a trajectory has an IS ratio below a threshold ⟦INLMATH134MATHEND⟧, the entire sequence is rejected from training.</strong> This can be written as:</p>

<p>⟦DISPMATH39MATHEND⟧</p>

<p>In a unified loss form:</p>

<p>⟦DISPMATH40MATHEND⟧</p>

<p>In words:</p>

<ul>
  <li>For <strong>sequences where all tokens have IS ratios ⟦INLMATH135MATHEND⟧</strong>: participate in training normally.</li>
  <li>For <strong>sequences where any token has an IS ratio ⟦INLMATH136MATHEND⟧</strong>: the entire sequence’s policy loss is masked out.</li>
</ul>

<p>From the three-policy TRPO perspective, WTRS adopts a hybrid “token-level detection, sequence-level veto” strategy: it detects extreme mismatch signals at the <strong>token level</strong>, and once detected, rejects at the <strong>sequence level</strong>. This “one-vote veto” design reflects a conservative philosophy — when a trajectory contains a token that “the behavior policy generated but the reference policy would almost never generate,” <strong>the credibility of the entire trajectory is called into question</strong>, thereby implementing control over Constraint 2 (⟦INLMATH137MATHEND⟧ vs. ⟦INLMATH138MATHEND⟧ deviation) at the trajectory granularity.</p>

<h2 id="moe-routing-replay-what-does-it-actually-do-in-three-policy-trpo">MoE Routing Replay: What Does It Actually Do in Three-Policy TRPO?</h2>

<p>In MoE (Mixture-of-Experts) models, training–inference mismatch often first appears as <strong>routing inconsistency</strong>: even with identical parameters, the inference and training stacks may route tokens to different experts because of small differences in operators, parallelism, or numerics. A natural engineering response is <strong>routing replay</strong>: during rollout (inference), record the actual expert paths, and during training, force the model to reuse these routing decisions.</p>

<p>These methods are often intuitively described as “implementing Constraint 2 and shrinking ⟦INLMATH139MATHEND⟧.” From the three-policy TRPO perspective, a more precise statement is:</p>

<blockquote>
  <p><strong>Routing replay does not tighten the original surrogate objective via a constraint; instead, it rewrites the surrogate objective into one that is conditioned on / replaces the routing.</strong>
It makes routing mismatch invisible in the loss, but it does not actually shrink the true policy distances ⟦INLMATH140MATHEND⟧ or ⟦INLMATH141MATHEND⟧.</p>
</blockquote>

<p>Below I’ll sketch a <strong>minimal</strong> abstraction that is sufficient to make this concrete.</p>

<h3 id="surrogate-objective-in-moe-separating-routing-and-token-generation">Surrogate Objective in MoE: Separating Routing and Token Generation</h3>

<p>Abstract an MoE model as a two-stage stochastic decision: “first choose an expert ⟦INLMATH142MATHEND⟧, then generate token ⟦INLMATH143MATHEND⟧ conditioned on that expert.” The target policy can be factorized as</p>

<p>⟦DISPMATH41MATHEND⟧</p>

<p>where:</p>

<ul>
  <li>⟦INLMATH144MATHEND⟧ is the router distribution.</li>
  <li>⟦INLMATH145MATHEND⟧ is the token distribution conditioned on expert ⟦INLMATH146MATHEND⟧.</li>
</ul>

<p>In the three-policy TRPO setting, the surrogate objective we actually want to optimize can be written as</p>

<p>⟦DISPMATH42MATHEND⟧</p>

<p>where I use</p>

<p>⟦DISPMATH43MATHEND⟧</p>

<p>to denote the expert-level aggregation of advantages.</p>

<p>The key point is that <strong>in the original ⟦INLMATH147MATHEND⟧, the routing distribution is precisely the current router ⟦INLMATH148MATHEND⟧ that we are updating</strong>. In other words, RL on MoE is updating not only the token-generation distribution but also the router itself.</p>

<h3 id="1-replaying-behavior-policy-routing-behavior-router-replay--r3-style">(1) Replaying Behavior-Policy Routing (Behavior-Router Replay / R3-Style)</h3>

<p>R3-style methods record, during rollout, the set of experts ⟦INLMATH149MATHEND⟧ actually selected by the behavior policy on the inference side, and during training force the current policy to <strong>route only within this set</strong>. This can be written as a “conditional projection” of the routing distribution:</p>

<p>⟦DISPMATH44MATHEND⟧</p>

<p>The surrogate objective that is actually optimized during training becomes</p>

<p>⟦DISPMATH45MATHEND⟧</p>

<p>Compared to the original ⟦INLMATH150MATHEND⟧, R3 does <em>not</em> push ⟦INLMATH151MATHEND⟧ closer to ⟦INLMATH152MATHEND⟧ or ⟦INLMATH153MATHEND⟧. Instead, it:</p>

<ul>
  <li><strong>replaces the expectation over ⟦INLMATH154MATHEND⟧ by a conditional expectation over ⟦INLMATH155MATHEND⟧</strong>, and</li>
  <li>equivalently, <strong>shrinks the feasible routing support to ⟦INLMATH156MATHEND⟧</strong>.</li>
</ul>

<p>So R3 is optimizing a “behavior-routing-conditioned surrogate objective,” rather than the original ⟦INLMATH157MATHEND⟧. The benefit is substantially reduced variance and improved stability; the cost is that <strong>the router’s exploration and update freedom is constrained at every state</strong>.</p>

<h3 id="2-replaying-reference-policy-routing-reference-router-replay">(2) Replaying Reference-Policy Routing (Reference-Router Replay)</h3>

<p>Another class of routing-replay schemes instead reuses the reference policy’s router ⟦INLMATH158MATHEND⟧. This is equivalent to training a hybrid policy</p>

<p>⟦DISPMATH46MATHEND⟧</p>

<p>with surrogate objective</p>

<p>⟦DISPMATH47MATHEND⟧</p>

<p>This has the effect that:</p>

<ul>
  <li>In the surrogate objective, the router is <strong>frozen to the old router</strong> ⟦INLMATH159MATHEND⟧, so the “reference vs. target” discrepancy in routing is simply removed from the loss.</li>
  <li>Training becomes insensitive to how far the <em>new</em> router ⟦INLMATH160MATHEND⟧ drifts from ⟦INLMATH161MATHEND⟧, thereby sidestepping the instabilities caused by routing mismatch.</li>
</ul>

<p>Again, this is fundamentally a <strong>change of objective</strong>:</p>

<ul>
  <li>The deviation ⟦INLMATH162MATHEND⟧ in the true policy space is not reduced; it is merely rendered invisible by redefining the surrogate in terms of the old router.</li>
  <li>Learning of the router is effectively frozen or heavily suppressed.</li>
</ul>

<h3 id="routing-replay-as-a-change-of-surrogate-objective">Routing Replay as a Change of Surrogate Objective</h3>

<p>Putting these replay variants side by side, they share several properties:</p>

<ol>
  <li><strong>They optimize not the original ⟦INLMATH163MATHEND⟧, but a surrogate where routing has been conditioned or replaced.</strong></li>
  <li><strong>They do not directly shrink the three-policy TRPO bound’s ⟦INLMATH164MATHEND⟧ or ⟦INLMATH165MATHEND⟧</strong>. Routing mismatch is removed from the loss, but it still exists in the true policy distances.</li>
  <li><strong>In practice they trade bias for variance</strong>: replay typically lowers variance and improves stability, but may also limit the router’s ability to learn routing patterns that are optimal for the RL objective.</li>
</ol>

<p>So, in the three-policy TRPO view, a more accurate characterization is:</p>

<blockquote>
  <p><strong>Routing replay is best thought of as a rewrite of the surrogate objective, not as a direct implementation of a constraint on ⟦INLMATH166MATHEND⟧ or ⟦INLMATH167MATHEND⟧.</strong></p>
</blockquote>

<h2 id="conclusion">Conclusion</h2>

<p>If I had to compress this post into a single sentence, it would be:</p>

<blockquote>
  <p><strong>Many issues around “training–inference mismatch” and “asynchronous training” in large-scale LLM RL can be understood, in the TRPO framework, as severely underestimating the deviation between the behavior policy ⟦INLMATH168MATHEND⟧ and the reference policy ⟦INLMATH169MATHEND⟧ — i.e., the term ⟦INLMATH170MATHEND⟧.</strong></p>
</blockquote>

<p>From two policies to three, what we did is conceptually very small:</p>

<ul>
  <li>
    <p>We rewrote the TRPO lower bound from an “old vs. new policy” narrative into a “<strong>behavior–reference–target</strong>” three-policy relationship.</p>
  </li>
  <li>We explicitly separated two TV distances:
    <ul>
      <li><strong>Constraint 1: reference vs. target</strong>, ⟦INLMATH171MATHEND⟧, corresponding to the KL / clip / trust-region style constraints in PPO / GRPO / GSPO.</li>
      <li><strong>Constraint 2: behavior vs. reference</strong>, ⟦INLMATH172MATHEND⟧, capturing real-world factors like asynchronous frameworks, training–inference mismatch, MoE routing volatility, kernel-level nondeterminism, etc.</li>
    </ul>
  </li>
  <li>This leads to a simple conclusion:
The gap between the surrogate ⟦INLMATH173MATHEND⟧ and the true performance ⟦INLMATH174MATHEND⟧ scales with ⟦INLMATH175MATHEND⟧.</li>
</ul>

<p>Under this lens (which is of course only one of many possible perspectives):</p>

<ul>
  <li>
    <p>Decoupled PPO / AReaL can be viewed as <strong>formally acknowledging the existence of three policies</strong> and explicitly decoupling the behavior distribution from the reference policy in the objective.</p>
  </li>
  <li>TIS, IcePop, MIS, and WTRS can be seen as different ways of implementing <strong>Constraint 2</strong> using importance sampling truncation / masking:
    <ul>
      <li>TIS: token-level truncation of IS weights to soften the influence of extreme samples.</li>
      <li>IcePop: token-level two-sided masking in MoE to hard-drop tokens with severe mismatch.</li>
      <li>MIS: sequence-level masking to ignore entire trajectories whose behavior–reference mismatch is too large.</li>
      <li>WTRS: token-level detection of extremely small ratios, rejecting the entire trajectory once such a signal is found.</li>
    </ul>
  </li>
  <li>
    <p><strong>Routing replay</strong> (whether replaying behavior routing in R3-style schemes or replaying reference routing) is better viewed as <strong>changing the surrogate objective</strong> rather than directly implementing a constraint: both variants replace the original ⟦INLMATH176MATHEND⟧ with a routing-conditioned / routing-frozen surrogate, trading off some objective bias and reduced routing learning freedom for lower variance and greater stability, without actually shrinking ⟦INLMATH177MATHEND⟧ or ⟦INLMATH178MATHEND⟧—they simply make routing mismatch invisible in the loss.</p>
  </li>
  <li>Engineering advice such as in <em>RL 老训崩？训推差异是基石</em> and system-level work like <em>Defeating Nondeterminism in LLM Inference</em> can be interpreted as efforts to <strong>reduce ⟦INLMATH179MATHEND⟧ on the systems and numerical side</strong>, so that the assumptions underlying the algorithms do not break too badly.</li>
</ul>

<p>From this unified perspective, it may also be easier to think about the following practical questions (these are completely open and I don’t have definitive answers):</p>

<ul>
  <li>
    <p>Under what conditions can we still reasonably interpret “LLM RL training” as some approximate form of TRPO / PPO?</p>
  </li>
  <li>For a concrete RL system, where should we invest more effort:
    <ul>
      <li>tightening ⟦INLMATH180MATHEND⟧ (stronger KL control, more stable sequence-level objectives), or</li>
      <li>reducing ⟦INLMATH181MATHEND⟧ (better training–inference alignment, more aggressive MIS / TIS / IcePop)?</li>
    </ul>
  </li>
  <li>In the presence of MoE, asynchronous sampling, and complex agent workflows, how long can we safely pretend that “⟦INLMATH182MATHEND⟧”?</li>
</ul>

<p>This post is just a very <strong>minimal</strong> extension of the classic TRPO framework, making the “three policies” explicit and using them to organize some existing work. There are inevitably misunderstandings and omissions. If you also care about how RL training actually behaves in large LLM systems, I’d be very interested to see how your own setup can be abstracted into a relationship between ⟦INLMATH183MATHEND⟧, ⟦INLMATH184MATHEND⟧, and ⟦INLMATH185MATHEND⟧, and then re-examined through the inequality in Theorem 2. It might give a slightly different intuitive feel for what your system is really optimizing.</p>

<div class="language-bibtex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">@misc</span><span class="p">{</span><span class="nl">WangZhang2025ThreePolicyTRPO</span><span class="p">,</span>
  <span class="na">author</span>       <span class="p">=</span> <span class="s">{Wang, Xihuai and Zhang, Shao}</span><span class="p">,</span>
  <span class="na">title</span>        <span class="p">=</span> <span class="s">{From Two Policies to Three: Extending TRPO under Behavior-Reference Policy Mismatch in LLM RL}</span><span class="p">,</span>
  <span class="na">year</span>         <span class="p">=</span> <span class="s">{2025}</span><span class="p">,</span>
  <span class="na">month</span>        <span class="p">=</span> <span class="nv">nov</span><span class="p">,</span>
  <span class="na">day</span>          <span class="p">=</span> <span class="s">{15}</span><span class="p">,</span>
  <span class="na">url</span>          <span class="p">=</span> <span class="s">{https://xihuai18.github.io/reinforcement-learning/2025/11/15/three-policy-en.html}</span><span class="p">,</span>
  <span class="na">urldate</span>      <span class="p">=</span> <span class="s">{2025-11-23}</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="reinforcement-learning" /><summary type="html"><![CDATA[Modern LLM RL pipelines often train under an "old policy" that silently drifts away from the behavior policy that actually generates rollouts, breaking the usual on-policy assumptions. This post rewrites the classic TRPO lower bound in a three-policy form — behavior, reference, and target — so that the performance gap cleanly decomposes into two TV distances that we can reason about and control. Seen through this lens, methods like Decoupled PPO, AReaL, TIS, IcePop, sequence-level MIS, Worst Token Reject Sampling (WTRS), MoE routing replay, and common engineering tricks for training–inference alignment all become different ways of shrinking these two deviations.]]></summary></entry><entry xml:lang="zh"><title type="html">从两策略到三策略：LLM RL 中行为策略–参考策略不一致下的 TRPO 扩展</title><link href="https://xihuai18.github.io/reinforcement-learning/2025/11/15/three-policy-zh.html" rel="alternate" type="text/html" title="从两策略到三策略：LLM RL 中行为策略–参考策略不一致下的 TRPO 扩展" /><published>2025-11-15T00:00:00+00:00</published><updated>2025-11-15T00:00:00+00:00</updated><id>https://xihuai18.github.io/reinforcement-learning/2025/11/15/three-policy-zh</id><content type="html" xml:base="https://xihuai18.github.io/reinforcement-learning/2025/11/15/three-policy-zh.html"><![CDATA[<p><img src="/assets/img/three-policy/three-policy-mini-class-zh.jpg" alt="Mini-class" style="display:block;margin:0 auto;width:95%;max-width:100%;" /></p>

<h2 id="训推不一致和异步框架">训推不一致和异步框架</h2>

<p>最近看到不少关于大模型强化学习中“训推不一致”和“异步训推框架”的讨论，我自己的直觉是：这些看上去复杂多样的问题，很大一部分其实都围绕着一个更基础的矛盾——<strong>行为策略（behavior policy）和参考策略（reference policy）不一致。</strong></p>

<p>本文先简单梳理一下我目前看到的相关工作，然后再尝试从“行为策略 vs 参考策略”的角度，把它们串到同一条线上，为读者提供一个补充视角。</p>

<p>在本文中我会用：</p>

<ul>
  <li><strong>行为策略</strong> ⟦INLMATH48MATHEND⟧：实际负责生成 rollout 的策略，也就是“你在什么分布下采样到了这些数据”。在现代 LLM-RL 系统里，它对应的是推理引擎里的那套实现（vLLM / SGLang 等），在异步框架下往往还是<strong>多个 worker 策略的混合分布</strong>。</li>
  <li><strong>参考策略</strong> ⟦INLMATH49MATHEND⟧：训练目标里拿来做重要性采样、clipping 或 KL 约束的策略，典型地就是 PPO / GRPO 里的“旧策略”（old policy）。</li>
  <li><strong>目标策略</strong> ⟦INLMATH50MATHEND⟧：训练目标里要优化的策略，也就是“你想让模型变成什么样”。典型地就是 PPO / GRPO 里的“新策略”（new policy）。</li>
</ul>

<p>在最经典、理想化的设定里，我们通常<strong>默认</strong> ⟦INLMATH51MATHEND⟧。但在现实系统中，受异步更新、不同推理 / 训练后端、MoE 路由波动甚至硬件数值差异等因素影响，二者往往会出现不同程度的偏离。</p>

<h2 id="相关工作">相关工作</h2>

<p>下面按时间线简单列一下我印象比较深的一些工作（只代表我个人看到的片面子集）：</p>

<ul>
  <li>
    <p><a href="https://arxiv.org/abs/2110.00641">Decoupled PPO</a> 率先指出，在信赖域策略优化（TRPO 和 PPO）方法中，“旧策略”（old policy）实际承担了两个不同的角色：一是用于重要性采样进行异策略修正，在这个目的下，“旧策略”用于代表训练数据集所服从的行为策略（behavior policy）；二是用于限制新策略的更新幅度，在这个目的下，“旧策略”被用于衡量新旧策略的变化程度，称作近端策略（proximal policy，对应本文中的“参考策略”）。文章指出这两个目的下的“旧策略”可以是不同的策略，从而提出了 Decoupled PPO 更新目标，把“采样用谁”和“对谁做 trust region”在形式上解耦开来。</p>
  </li>
  <li>
    <p><a href="https://arxiv.org/abs/2505.24298">AReaL</a> 关注到了异步训练框架下行为策略与参考策略不一致的问题：rollout 往往由滞后的参数版本或不同 worker 产生。文章在异步框架下采用了 Decoupled PPO 风格的目标，将“行为策略分布”和“参考策略”显式区分开来，从而在异步场景下仍然维持类似 PPO 的优化性质。</p>
  </li>
  <li>
    <p><a href="https://arxiv.org/abs/2507.18071">GSPO</a> 从 GRPO 在长序列和 MoE 模型上的稳定性问题出发，指出 token-level 的 PPO / GRPO 在专家路由高度波动（尤其是新旧策略之间的路由差异）时，会引入巨大的方差与不稳定。GSPO 提出在 <strong>sequence-level</strong> 定义 PPO-style 目标与比率约束，用整条序列的比率来约束更新，从而在 MoE 场景下显著缓解由路由不一致带来的训练崩溃问题。</p>
  </li>
  <li>
    <p><a href="https://fengyao.notion.site/off-policy-rl#28b721e3f6c480c3a756f8fb319e860d">Your Efficient RL Framework Secretly Brings You Off-Policy RL Training</a> 关注到了现有的一些大模型强化学习训练框架（如 VeRL）中，推理框架和训练框架在不少相同的功能模块上有不同的实现（例如 vLLM 和 FSDP / Megatron 等算子上的差异），导致行为策略 ⟦INLMATH52MATHEND⟧ 与参考策略 ⟦INLMATH53MATHEND⟧ 不一致。这种不一致使得原本假定为同策略（on-policy）的训练，实际上变成了带有明显偏差的异策略（off-policy）训练。文章总结了两种处理这一问题的现有方法：PPO-IS 与 vanilla-IS，并提出在 <strong>token-level</strong> 做截断重要性采样（truncated IS, TIS），以减少训推不一致程度较重的样本在训练中的影响。作者还写了两篇更为基础的分析文章，从原理上分析训推不一致问题：<a href="https://fengyao.notion.site/pg-seq-token-part1-basics">Part I</a> 和 <a href="https://fengyao.notion.site/pg-seq-token-part2-mismatch">Part II</a>。</p>
  </li>
  <li>
    <p><a href="https://thinkingmachines.ai/blog/defeating-nondeterminism-in-llm-inference">Defeating Nondeterminism in LLM Inference</a> 指出，批处理大小不变性（batch-size invariance）的缺失是大模型推理框架随机性的核心来源之一：同一个输入在不同的 batch 组合和 kernel 路径下，得到的概率分布会发生可观差异。这意味着，即便“名义上”是同一套参数，真实运行时的行为策略 ⟦INLMATH54MATHEND⟧ 也会因为系统负载和调度差异而波动，从而进一步加剧训推不一致。</p>
  </li>
  <li>
    <p><a href="https://ringtech.notion.site/icepop">Small Leak Can Sink a Great Ship—Boost RL Training on MoE with 𝑰𝒄𝒆𝑷𝒐𝒑!</a> 观察到，上述训推不一致问题在 MoE 模型上会进一步加剧：路由本身就对微小扰动高度敏感，再叠加推理 / 训练实现差异和异步采样，很容易放大偏差。文章提出 IcePop 方法：在 <strong>token-level</strong> 通过计算重要性采样比率，对过于大或者过于小的比率进行双侧掩码（masking），将这些“噪声较大”的数据从梯度中丢弃，从而稳定 MoE 上的 RL 训练。</p>
  </li>
  <li>
    <p><a href="https://yingru.notion.site/When-Speed-Kills-Stability-Demystifying-RL-Collapse-from-the-Training-Inference-Mismatch-271211a558b7808d8b12d403fd15edda">When Speed Kills Stability: Demystifying RL Collapse from the Training-Inference Mismatch</a> 系统性分析了训推不一致的各种成因，包括智能体工作流中引入的大量分布外和低概率信息、硬件和内核 / kernel 实现带来的计算不确定性，并分析了在 <strong>token-level</strong> 进行重要性采样如何在长序列上引入严重的偏差。文章进一步提出在 <strong>sequence-level</strong> 计算重要性采样掩码（sequence-level masked IS, sequence-level MIS）：只丢弃那些整条序列的重要性采样比率过大的数据，从而在控制偏差的同时，显著抑制由极端样本导致的训练崩溃。文中给出了较为完整的理论推导和丰富的实验支撑。</p>
  </li>
  <li>
    <p><a href="https://arxiv.org/abs/2510.11370">Stabilizing MoE Reinforcement Learning by Aligning Training and Inference Routers</a> 聚焦于 MoE 架构下特有的 <strong>路由不一致（Routing Inconsistency）</strong> 问题。文章发现，推理端和训练端即便在输入完全相同的情况下，由于算子实现或并行的微小差异，Router 选中的专家往往不同。这种“物理路径”上的不一致，使得行为策略 ⟦INLMATH55MATHEND⟧ 和参考策略 ⟦INLMATH56MATHEND⟧ 之间的差异远超预期，极易导致训练崩溃。文章提出了 <strong>Rollout Routing Replay (R3)</strong>：在推理阶段记录下每个 token 实际命中的专家索引，并在训练阶段<strong>强制回放</strong>这些路由决策，不再重新进行计算。通过这种方式，R3 在 MoE 拓扑结构上强制对齐了训推两端的计算路径。</p>
  </li>
  <li>
    <p><a href="https://zhuanlan.zhihu.com/p/1959976628290590602">RL 老训崩？训推差异是基石</a> 则更多从实践角度出发，分享了如何在实现上尽可能靠近“训推一致”的经验，包括如何选用一致的算子和精度配置、如何监控与约束训练端和推理端 log-prob 的偏差等，更着力于从训推框架层面入手，在工程上尽量从根本缓解训推差异问题。</p>
  </li>
  <li>
    <p><a href="https://verl.readthedocs.io/en/latest/algo/rollout_corr.html">verl Rollout Importance Sampling</a> 在其 rollout correction 模块中引入了 Token Veto（一票否决）机制：在 <strong>token-level</strong> 计算重要性比率 ⟦INLMATH57MATHEND⟧，若轨迹中存在任意 token 使得 ⟦INLMATH58MATHEND⟧，则将整条序列从训练中剔除。这种”token 粒度检测、sequence 粒度否决”的设计体现了一种”一票否决”的保守策略。</p>
  </li>
  <li>
    <p><a href="https://storage.googleapis.com/intellect-3-paper/INTELLECT_3_Technical_Report.pdf">INTELLECT-3 Technical Report</a> 在其异步分布式 RL 训练框架中采用了类似的拒绝采样策略。INTELLECT-3 对每条 rollout 计算 <strong>token-level</strong> 重要性比率，若任意 token 的比率低于阈值（文中使用 ⟦INLMATH59MATHEND⟧），则对整条轨迹进行 masking。</p>
  </li>
</ul>

<h2 id="三策略-trpo-视角下的最小统一理解">三策略 TRPO 视角下的最小统一理解</h2>

<p>上面列的这些工作，看上去各自解决的是：</p>

<ul>
  <li>算法层：PPO / GRPO 的目标怎么写，token-level 还是 sequence-level，用 clip 还是 mask；</li>
  <li>系统层：推理框架和训练框架怎样对齐；</li>
  <li>模型层：MoE 模型路由问题如何放大训练不稳定，等等。</li>
</ul>

<p>但如果我们把“行为策略 vs 参考策略”这条线拉直，会发现相当一部分问题，其实都可以放到一个相对简单的理论框架里理解：<strong>三策略 TRPO</strong>。</p>

<p>下面这节我会用尽量简单的数学，把这个三策略版 TRPO 摊开——它可以被看作是“TRPO + 三角不等式”的一个小扩展，但在分析大模型 RL 里的训推不一致时非常好用：</p>

<ul>
  <li>一方面让我们重新理解“训推不一致”和“异步训练框架”到底在影响什么；</li>
  <li>另一方面，也帮我们统一理解 TIS、IcePop、sequence-level MIS 等，在本文的视角下，它们其实都是在实施下文的“<strong>约束 2</strong>”。</li>
</ul>

<h3 id="三个策略">三个策略</h3>

<p>沿用前文的记号，我们在一个折扣 MDP 上工作，折扣因子为 ⟦INLMATH60MATHEND⟧：</p>

<ul>
  <li>状态 ⟦INLMATH61MATHEND⟧，动作 ⟦INLMATH62MATHEND⟧；</li>
  <li>策略 ⟦INLMATH63MATHEND⟧；</li>
  <li>折扣状态分布：
⟦DISPMATH10MATHEND⟧</li>
  <li>回报（episode 视角）：
⟦DISPMATH11MATHEND⟧</li>
  <li>值函数 / 优势函数：
⟦DISPMATH12MATHEND⟧</li>
</ul>

<p>稍微赘述一下，在“三策略”设定里，我们有：</p>

<ul>
  <li><strong>行为策略</strong>（behavior policy）：⟦INLMATH64MATHEND⟧，真正用来 rollout 的策略；数据 ⟦INLMATH65MATHEND⟧ 都是从它来的。</li>
  <li><strong>参考策略</strong>（reference policy）：⟦INLMATH66MATHEND⟧，优化目标里拿来做 ratio、clip 或 KL 约束的那一份“旧策略”。</li>
  <li><strong>目标策略</strong>（target policy）：⟦INLMATH67MATHEND⟧，我们这一步想要优化的策略。</li>
</ul>

<p>在理想设定里我们默认 ⟦INLMATH68MATHEND⟧；现实系统里二者往往不等，这就是“训推不一致”的数学影子。</p>

<h3 id="两策略-trpo">两策略 TRPO</h3>

<blockquote>
  <p>熟悉 TRPO 的读者可以直接跳到后面的“三策略 TRPO”小节。</p>
</blockquote>

<p>TRPO 的所有理论保证，都是建立在<strong>某个“基准策略”的优势函数</strong>之上的。既然实际能算清楚的<strong>只有</strong> ⟦INLMATH69MATHEND⟧（数据是按 ⟦INLMATH70MATHEND⟧ 采的），那我们就直接把 ⟦INLMATH71MATHEND⟧ 当成基准。</p>

<p>一个经典的结论是 <strong>性能差分引理（Performance Difference Lemma）</strong>：</p>

<blockquote>
  <p>对任意两策略 ⟦INLMATH72MATHEND⟧ 和 ⟦INLMATH73MATHEND⟧，有</p>

  <p>⟦DISPMATH1MATHEND⟧</p>
</blockquote>

<p>直觉非常简单：</p>

<ul>
  <li>⟦INLMATH74MATHEND⟧ 就是在说“如果在 ⟦INLMATH75MATHEND⟧ 里本来按 ⟦INLMATH76MATHEND⟧ 行动，现在换成动作 ⟦INLMATH77MATHEND⟧，长期回报会多或少多少”；</li>
  <li>把所有时刻、所有状态、所有动作的“增益”累积起来，就得到新策略比行为策略总共赚了多少。</li>
</ul>

<p>TRPO 的问题在于，我们没法准确算</p>

<p>⟦DISPMATH13MATHEND⟧</p>

<p>因为 ⟦INLMATH78MATHEND⟧ 是“新策略”的状态分布，我们没有在它下面采样过。</p>

<p>于是 TRPO 引入了一个替代目标：把状态分布换成行为策略的：</p>

<p>⟦DISPMATH14MATHEND⟧</p>

<p>⟦INLMATH79MATHEND⟧ 的直觉解释是：在行为策略的状态分布下，让新策略试着去选动作，看优势有多大。</p>

<p>从性能差分引理出发，两者之差是：</p>

<p>⟦DISPMATH15MATHEND⟧</p>

<p>如果我们定义</p>

<p>⟦DISPMATH16MATHEND⟧</p>

<p>那么有一个直接的上界：</p>

<blockquote>
  <p><strong>Lemma 1</strong></p>

  <p>⟦DISPMATH2MATHEND⟧</p>
</blockquote>

<p>这里出现了第一个关键量：</p>

<blockquote>
  <p><strong>状态分布偏移</strong> ⟦INLMATH80MATHEND⟧，也就是“新策略和行为策略看到的世界，到底差了多少”。</p>
</blockquote>

<p>我们通常不会直接对 ⟦INLMATH81MATHEND⟧ 施加约束，反而是对“每一步 action 分布”的差异施加约束，比如 trust region、KL、clip 等。</p>

<p>记总变差距离（total variation）：</p>

<p>⟦DISPMATH17MATHEND⟧</p>

<p>假设存在常数 ⟦INLMATH82MATHEND⟧，使得</p>

<blockquote>
  <p>对所有 ⟦INLMATH83MATHEND⟧，行为策略和目标策略之间的 TV 被 ⟦INLMATH84MATHEND⟧ 上界：</p>

  <p>⟦DISPMATH3MATHEND⟧</p>
</blockquote>

<p>直观含义：在任意状态里，“新策略”和“生成数据的策略”选动作的分布都不会离太远。</p>

<p>一个经典结果（可以用 coupling 证明）是：</p>

<blockquote>
  <p><strong>Lemma 2</strong>
在上述条件下有</p>

  <p>⟦DISPMATH4MATHEND⟧</p>
</blockquote>

<p>把它和 Lemma 1 结合：</p>

<p>⟦DISPMATH18MATHEND⟧</p>

<p>于是我们得到一个形式上相当简洁的<strong>两策略 TRPO 下界（基准为行为策略）</strong>：</p>

<blockquote>
  <p><strong>Theorem 1（两策略 TRPO）</strong></p>

  <p>⟦DISPMATH5MATHEND⟧</p>
</blockquote>

<p>这说明：</p>

<ul>
  <li><strong>真正决定“替代目标 ⟦INLMATH85MATHEND⟧ 靠不靠谱”的，是行为策略 ⟦INLMATH86MATHEND⟧ 和目标策略 ⟦INLMATH87MATHEND⟧ 的差异：</strong>
⟦DISPMATH19MATHEND⟧</li>
</ul>

<p>如果你能直接约束住这个 ⟦INLMATH88MATHEND⟧，就能直接把 TRPO 的单调性保证搬到行为策略视角下。</p>

<h3 id="三策略-trpo">三策略 TRPO</h3>

<p>现实问题在于：<strong>大模型强化学习训练里我们可能无法直接控制 ⟦INLMATH89MATHEND⟧ 本身。</strong></p>

<p>在大部分 PPO / GRPO / GSPO / 现有 RLHF 框架里，实际发生的是：</p>

<ul>
  <li>rollout 数据是由某个<strong>行为策略</strong> ⟦INLMATH90MATHEND⟧ 产生的（推理引擎里的“那一版参数” + 若干系统细节）；</li>
  <li>更新时，我们希望利用<strong>参考策略</strong> ⟦INLMATH91MATHEND⟧ 来限制<strong>目标策略</strong> ⟦INLMATH92MATHEND⟧ 的更新幅度。</li>
</ul>

<p>也就是说，实际可以“动手”的是两个量：</p>

<ol>
  <li><strong>参考 vs 目标</strong>：我们可以通过 KL / clip 等手段控制
⟦DISPMATH20MATHEND⟧</li>
  <li><strong>行为 vs 参考</strong>：我们希望<strong>间接</strong>控制
⟦DISPMATH21MATHEND⟧</li>
</ol>

<p>于是自然就定义两个“proxy 差异”：</p>

<ul>
  <li><strong>约束 1：参考 vs 目标</strong>
⟦DISPMATH22MATHEND⟧</li>
  <li><strong>约束 2：行为 vs 参考</strong>
⟦DISPMATH23MATHEND⟧</li>
</ul>

<p>直觉上：</p>

<ul>
  <li>⟦INLMATH93MATHEND⟧：新策略到底离“你宣称的那份旧策略”有多远——这就是 trust region 控制的那部分；</li>
  <li>⟦INLMATH94MATHEND⟧：你用来训练的参考策略，到底跟真实采样时的行为策略差了多少——这就是训推不一致或异步的影子。</li>
</ul>

<p>现在，可以把这两个量塞回 TRPO 的下界里。</p>

<p>对任意状态 ⟦INLMATH95MATHEND⟧，有</p>

<p>⟦DISPMATH24MATHEND⟧</p>

<p>对 ⟦INLMATH96MATHEND⟧ 取上确界：</p>

<p>⟦DISPMATH25MATHEND⟧</p>

<p>把这个不等式塞回两策略 TRPO 的结论（Theorem 1）里，记</p>

<p>⟦DISPMATH26MATHEND⟧</p>

<p>即得到：</p>

<p>⟦DISPMATH27MATHEND⟧</p>

<p>于是，我们得到一个非常直接的<strong>三策略 TRPO 下界</strong>：</p>

<blockquote>
  <p><strong>Theorem 2（三策略 TRPO）</strong>
记</p>

  <p>⟦DISPMATH6MATHEND⟧</p>

  <p>以及</p>

  <p>⟦DISPMATH7MATHEND⟧</p>

  <p>则对任意目标策略 ⟦INLMATH97MATHEND⟧ 有</p>

  <p>⟦DISPMATH8MATHEND⟧</p>

  <p>其中</p>

  <p>⟦DISPMATH9MATHEND⟧</p>
</blockquote>

<p>这个结论的含义其实很直接：</p>

<ul>
  <li><strong>替代目标 ⟦INLMATH98MATHEND⟧ 与真实性能 ⟦INLMATH99MATHEND⟧ 之间的 gap，可以拆成两部分：</strong>
    <ul>
      <li>参考 vs 目标的偏移 ⟦INLMATH100MATHEND⟧；</li>
      <li>行为 vs 参考的偏移 ⟦INLMATH101MATHEND⟧。</li>
    </ul>
  </li>
</ul>

<p>只要这两个量都小，<strong>优化 ⟦INLMATH102MATHEND⟧ 就有希望有效提升 ⟦INLMATH103MATHEND⟧</strong>。</p>

<h3 id="这两个差异各自怎么约束">这两个差异各自怎么约束？</h3>

<p>现在，我们可以从 Theorem 2 回头看各种实际方法：</p>

<ul>
  <li>绝大多数 “PPO / GRPO / GSPO” 类工作，其实是在控制 <strong>约束 1：⟦INLMATH104MATHEND⟧</strong>；</li>
  <li>绝大多数 “TIS / IcePop / MIS” 类工作，在本文的统一视角下，可以理解为主要是在控制 <strong>约束 2：⟦INLMATH105MATHEND⟧</strong>。</li>
</ul>

<p>本文下面只讨论 <strong>约束 2</strong>。</p>

<p>约束 2 的目标是：<strong>保证用来训练的数据，尽可能来自“接近参考策略”的行为策略。</strong></p>

<p>这里通常既有<strong>系统层</strong>的机制，也有<strong>算法层（importance sampling）</strong>的机制。</p>

<ol>
  <li><strong>系统层：让行为策略别飘太远</strong>
    <ul>
      <li>异步框架：给每个样本打上策略版本号，只能用与 ⟦INLMATH106MATHEND⟧ 相差不大的参数版本采样的数据；</li>
      <li>训推对齐：强调训练框架和推理框架用相同精度、相同算子、相近的内核 / kernel 行为。</li>
    </ul>

    <p>这些机制的目标是：从“算法外部”让 ⟦INLMATH107MATHEND⟧ 和 ⟦INLMATH108MATHEND⟧ 靠近，从而压缩 ⟦INLMATH109MATHEND⟧。</p>
  </li>
  <li>
    <p><strong>算法层：样本修正</strong></p>

    <p>在算法层，我们不再试图“纠正整个行为策略”，而是用重要性采样比率在<strong>样本层面</strong>做筛选和重加权，让“真正参与训练的样本子集”上的行为策略尽量接近参考策略，或者减小差异较大的样本在训练上的权重。</p>

    <p>具体来说，就是下面这些方法，它们本质上都可以看作是“实现约束 2 的不同方式”。</p>
  </li>
</ol>

<h2 id="重要性采样与掩码四种约束-2-实现">重要性采样与掩码：四种约束 2 实现</h2>

<p>下面延续前文的记号体系来写这三种方法的目标函数，只聚焦在“行为策略 vs 参考策略”这一维的设计。记 token 级的 PPO / GRPO 风格更新项为</p>

<p>⟦DISPMATH28MATHEND⟧</p>

<p>其中</p>

<p>⟦DISPMATH29MATHEND⟧</p>

<p>也就是说：</p>

<ul>
  <li>⟦INLMATH110MATHEND⟧ 是 <strong>目标 vs 参考</strong> 的比率（对应约束 1）；</li>
  <li>⟦INLMATH111MATHEND⟧ 基于行为策略采样的数据，是我们能估到的优势函数。</li>
</ul>

<p>为了把 token 级的 ⟦INLMATH112MATHEND⟧ 与序列级的 ⟦INLMATH113MATHEND⟧ 记号打通，在以 RLHF（reinforcement learning from human feedback，人类反馈强化学习）为代表的 LLM-RL 设定中，我们约定：</p>

<ul>
  <li>prompt 记为 ⟦INLMATH114MATHEND⟧；回复记为 ⟦INLMATH115MATHEND⟧；</li>
  <li>token 级状态 ⟦INLMATH116MATHEND⟧，动作 ⟦INLMATH117MATHEND⟧；</li>
  <li>因此行为策略和参考策略在序列上的分布可写成
⟦DISPMATH30MATHEND⟧</li>
</ul>

<p>此外，为了描述“参考 vs 行为”的偏移，统一定义 token 级重要性比率</p>

<p>⟦DISPMATH31MATHEND⟧</p>

<p>以及其对应的序列级版本</p>

<p>⟦DISPMATH32MATHEND⟧</p>

<p>接下来，TIS / IcePop / MIS 的区别，就体现在“如何利用这些 ⟦INLMATH118MATHEND⟧ 来实现约束 2”。</p>

<h3 id="1-tistoken-level-截断-is">1. TIS：token-level 截断 IS</h3>

<p>TIS 直接对上述 ⟦INLMATH119MATHEND⟧ 做截断，记</p>

<p>⟦DISPMATH33MATHEND⟧</p>

<p>更新目标写成</p>

<p>⟦DISPMATH34MATHEND⟧</p>

<ul>
  <li>蓝色的 ⟦INLMATH120MATHEND⟧ 是被截断的 IS 权重：极端大的比率被压到常数 ⟦INLMATH121MATHEND⟧。</li>
  <li>从三策略 TRPO 的角度看，这相当于在 <strong>token 分布</strong> 上“软削弱”行为策略和参考策略严重不一致的样本，从而在梯度中有效减小那部分样本对 ⟦INLMATH122MATHEND⟧ 的贡献。</li>
</ul>

<h3 id="2-icepopmoe-场景下的-token-level-双侧-mask">2. IcePop：MoE 场景下的 token-level 双侧 Mask</h3>

<p>IcePop 同样以 ⟦INLMATH123MATHEND⟧ 为度量，但采用 <strong>双侧掩码</strong>：</p>

<p>⟦DISPMATH35MATHEND⟧</p>

<p>更新目标写成</p>

<p>⟦DISPMATH36MATHEND⟧</p>

<ul>
  <li>蓝色的 ⟦INLMATH124MATHEND⟧ 决定某个 token 是否参与更新：比率太大或太小的 token 直接被丢弃。</li>
  <li>这相当于硬性裁掉“行为策略和参考策略极度不一致”的 token，只在 ⟦INLMATH125MATHEND⟧ 适中的区域上优化，从样本集合层面实施更强的“约束 2”。</li>
</ul>

<h3 id="3-sequence-level-mis按整条序列-mask-的重要性采样">3. sequence-level MIS：按整条序列 Mask 的重要性采样</h3>

<p>MIS 的核心操作是：<strong>只保留 IS 比率不超过阈值 ⟦INLMATH126MATHEND⟧ 的序列，其余序列的损失直接置零</strong>。写成</p>

<p>⟦DISPMATH37MATHEND⟧</p>

<p>在统一的损失形式下，可以写成</p>

<p>⟦DISPMATH38MATHEND⟧</p>

<p>简而言之：</p>

<ul>
  <li>对于 <strong>IS 比率较小的序列</strong>：保留完整的 ⟦INLMATH127MATHEND⟧ 权重，正常做 off-policy 修正；</li>
  <li>对于 <strong>IS 比率超过阈值 ⟦INLMATH128MATHEND⟧ 的序列</strong>：整个序列的 policy loss 被 mask 掉（权重变成 ⟦INLMATH129MATHEND⟧）。</li>
</ul>

<p>从三策略 TRPO 的角度看，MIS 不再在 token 上做截断，而是直接在<strong>序列级</strong>筛掉“行为策略和参考策略严重不一致”的轨迹，只在 ⟦INLMATH130MATHEND⟧ 的子分布上优化，从而在 trajectory 粒度上实现对“约束 2”（⟦INLMATH131MATHEND⟧ vs ⟦INLMATH132MATHEND⟧ 偏移）的控制。</p>

<h3 id="4-worst-token-reject-sampling按最差-token-拒绝整条序列">4. Worst Token Reject Sampling：按最差 token 拒绝整条序列</h3>

<p>verl 中的 veto 机制 与 INTELLECT-3 分别在各自的训练框架中采用了一种可统称为 <strong>Worst Token Reject Sampling（WTRS）</strong> 的拒绝采样策略：</p>

<ul>
  <li>
    <p><strong>verl Token Veto</strong>：在其 rollout correction 模块中，若轨迹中存在任意 token 使得 ⟦INLMATH133MATHEND⟧，则通过 response*mask 将整条序列剔除。阈值 ⟦INLMATH134MATHEND⟧ 可由用户配置。</p>
  </li>
  <li>
    <p><strong>INTELLECT-3 Token Masking</strong>：在其异步分布式 RL 框架中，若任意 token 的比率低于 ⟦INLMATH135MATHEND⟧，则对整条轨迹进行 masking。</p>
  </li>
</ul>

<p>二者的核心操作一致：<strong>若轨迹中存在任意 token 的 IS 比率低于阈值 ⟦INLMATH136MATHEND⟧，则将整条序列从训练中剔除</strong>。写成</p>

<p>⟦DISPMATH39MATHEND⟧</p>

<p>在统一的损失形式下，可以写成</p>

<p>⟦DISPMATH40MATHEND⟧</p>

<p>简而言之：</p>

<ul>
  <li>对于 <strong>所有 token 的 IS 比率均不低于 ⟦INLMATH137MATHEND⟧ 的序列</strong>：正常参与训练；</li>
  <li>对于 <strong>存在任意 token 的 IS 比率低于 ⟦INLMATH138MATHEND⟧ 的序列</strong>：整条序列的 policy loss 被 mask 掉。</li>
</ul>

<p>从三策略 TRPO 的角度看，WTRS 采用了”token 粒度检测、sequence 粒度否决”的混合策略：在 <strong>token-level</strong> 检测极端不一致的信号，一旦发现则在 <strong>sequence-level</strong> 执行拒绝。这种”一票否决”的设计体现了一种保守思路——当轨迹中存在”行为策略生成但参考策略几乎不可能生成”的 token 时，<strong>整条轨迹的可信度都将受到质疑</strong>，从而在 trajectory 粒度上实现对”约束 2”（⟦INLMATH139MATHEND⟧ vs ⟦INLMATH140MATHEND⟧ 偏移）的控制。</p>

<h2 id="moe-路由回放它在三策略-trpo-中到底做了什么">MoE 路由回放：它在三策略 TRPO 中到底做了什么？</h2>

<p>在 MoE（Mixture-of-Experts）模型上，训推不一致往往首先表现为<strong>路由不一致（routing inconsistency）</strong>：即便参数相同，推理端与训练端也可能因为算子、并行或数值细节的微小差异而路由到不同专家。一个很自然的工程应对是<strong>路由回放（routing replay）</strong>：在 rollout（推理）时记录实际命中的专家路径，训练时强制复用这些路由决策。</p>

<p>这类方法经常被直觉性地理解为“在实现约束 2、压小 ⟦INLMATH141MATHEND⟧”。但从三策略 TRPO 的视角看，更准确的说法是：</p>

<blockquote>
  <p><strong>路由回放并不是在原 surrogate objective 上收紧约束，而是在把 surrogate objective 改写成另一个“带路由条件/替换”的目标。</strong>
它让路由不一致在 loss 里“不可见”，但并没有让真实策略距离里的 ⟦INLMATH142MATHEND⟧ 或 ⟦INLMATH143MATHEND⟧ 变小。</p>
</blockquote>

<p>下面用一个<strong>尽量简单</strong>但足够说明问题的建模来把这件事写清楚。</p>

<h3 id="moe-下的-surrogate-objective把路由和token-生成拆开">MoE 下的 surrogate objective：把“路由”和“token 生成”拆开</h3>

<p>把 MoE 抽象成两阶段随机决策：“先选专家 ⟦INLMATH144MATHEND⟧，再在该专家条件下生成 token ⟦INLMATH145MATHEND⟧”。
因此目标策略可以分解为</p>

<p>⟦DISPMATH41MATHEND⟧</p>

<p>其中：</p>

<ul>
  <li>⟦INLMATH146MATHEND⟧ 是路由器（router）的分布；</li>
  <li>⟦INLMATH147MATHEND⟧ 是在专家 ⟦INLMATH148MATHEND⟧ 条件下的 token 分布。</li>
</ul>

<p>在三策略 TRPO 中，我们真正想优化的 surrogate objective 为</p>

<p>⟦DISPMATH42MATHEND⟧</p>

<p>其中我把专家层的优势聚合写成</p>

<p>⟦DISPMATH43MATHEND⟧</p>

<p>关键点：<strong>在原始的 ⟦INLMATH149MATHEND⟧ 里，路由分布是当前要更新的 ⟦INLMATH150MATHEND⟧</strong>。也就是说，MoE 的 RL 训练不仅在更新 token 生成分布，也在更新路由器本身。</p>

<h3 id="1回放行为策略的路由behavior-router-replay--r3-类">1）回放行为策略的路由（behavior-router replay / R3 类）</h3>

<p>R3 的做法是：rollout 时记录推理端实际命中的专家集合 ⟦INLMATH151MATHEND⟧，训练时强制当前策略<strong>只在该集合内路由</strong>。可以把它写成对路由分布的“条件化投影”：</p>

<p>⟦DISPMATH44MATHEND⟧</p>

<p>从而训练时实际优化的 surrogate objective 变为</p>

<p>⟦DISPMATH45MATHEND⟧</p>

<p>和原始 ⟦INLMATH152MATHEND⟧ 对比可以看到，R3 并没有让 ⟦INLMATH153MATHEND⟧ 逼近 ⟦INLMATH154MATHEND⟧ 或 ⟦INLMATH155MATHEND⟧；它做的是：</p>

<ul>
  <li><strong>把对 ⟦INLMATH156MATHEND⟧ 的期望，改成了对 ⟦INLMATH157MATHEND⟧ 的条件期望</strong>；</li>
  <li>等价地说，把路由的可行 support 缩到了 ⟦INLMATH158MATHEND⟧。</li>
</ul>

<p>因此 R3 训练的是一个“被行为路由集合条件化后的 surrogate objective”，而不是原来的 ⟦INLMATH159MATHEND⟧。
好处是显著降方差、提升稳定性；代价是<strong>在每个状态上都收缩了路由器探索 / 更新的自由度</strong>。</p>

<h3 id="2回放参考策略的路由reference-router-replay">2）回放参考策略的路由（reference-router replay）</h3>

<p>另一类 routing replay 复用的是参考策略（old policy）的路由器 ⟦INLMATH160MATHEND⟧。这等价于训练一个混合策略</p>

<p>⟦DISPMATH46MATHEND⟧</p>

<p>对应 surrogate objective 为</p>

<p>⟦DISPMATH47MATHEND⟧</p>

<p>这意味着：</p>

<ul>
  <li>在 surrogate objective 中，路由器被<strong>固定为旧路由器</strong>，路由相关的“参考 vs 目标”差异在 loss 里被直接抹掉；</li>
  <li>训练对“新路由器 ⟦INLMATH161MATHEND⟧ 是否偏离 ⟦INLMATH162MATHEND⟧”不再敏感，于是路由不一致导致的不稳定被绕开。</li>
</ul>

<p>但注意这同样是<strong>换目标</strong>：</p>

<ul>
  <li>真实策略空间里的 ⟦INLMATH163MATHEND⟧ 并没有因此变小，只是被“用旧路由器重定义目标”而在 loss 中不可见；</li>
  <li>路由器的学习被强行冻结或极度削弱。</li>
</ul>

<h3 id="路由回放只是在改写-surrogate-objective">路由回放只是在改写 surrogate objective</h3>

<p>把两类 replay 放在一起看，它们的共同点是：</p>

<ol>
  <li><strong>优化的都不是原始的 ⟦INLMATH164MATHEND⟧</strong>，而是某个“路由被条件化 / 替换后的 surrogate objective”。</li>
  <li><strong>它们没有直接收缩三策略 TRPO 下界里的 ⟦INLMATH165MATHEND⟧</strong>。replay 让路由不匹配不再显式出现在 loss 中，但不匹配在真实策略距离里仍然存在。</li>
  <li><strong>实践上是在“用偏差换方差”</strong>：回放往往显著降低方差、提升稳定性，但也可能限制了 MoE 在 RL 目标下学到更优的路由模式。</li>
</ol>

<p>所以，从三策略 TRPO 的视角，更准确的理解是：</p>

<blockquote>
  <p><strong>routing replay 是一种 surrogate objective 的改写，而不是对 ⟦INLMATH166MATHEND⟧ 或 ⟦INLMATH167MATHEND⟧ 的直接实现。</strong></p>
</blockquote>

<h2 id="小结">小结</h2>

<p>如果把这篇文章压缩成一句话，就是：</p>

<blockquote>
  <p><strong>许多“大模型 RL 训推不一致”和“异步训练”问题，在本文的视角下，其实都可以理解为：在 TRPO 框架下，当行为策略 ⟦INLMATH168MATHEND⟧ 和参考策略 ⟦INLMATH169MATHEND⟧ 不一致时，二者之间的偏移（⟦INLMATH170MATHEND⟧）被严重低估了。</strong></p>
</blockquote>

<p>从两策略到三策略，我们做的事情其实很简单：</p>

<ul>
  <li>把 TRPO 的下界从“旧策略 vs 新策略”的叙述，改写成“<strong>行为策略 – 参考策略 – 目标策略</strong>”三者的关系；</li>
  <li>显式地拆出了两个 TV 距离：
    <ul>
      <li><strong>约束 1：参考 vs 目标</strong> ⟦INLMATH171MATHEND⟧，对应 PPO / GRPO / GSPO 等工作里最常见的 KL / clip / trust region；</li>
      <li><strong>约束 2：行为 vs 参考</strong> ⟦INLMATH172MATHEND⟧，对应异步框架、训推差异、MoE 路由、kernel 非确定性等现实因素；</li>
    </ul>
  </li>
  <li>得到了一个非常直接的结论：
替代目标 ⟦INLMATH173MATHEND⟧ 和真实性能 ⟦INLMATH174MATHEND⟧ 的 gap 正比于 ⟦INLMATH175MATHEND⟧。</li>
</ul>

<p>在这个视角下（当然这只是众多可能视角之一）：</p>

<ul>
  <li>Decoupled PPO / AReaL 可以被看作是在<strong>形式上承认“三策略存在”</strong>，并尝试在目标函数上将“行为分布”和“参考策略”解耦；</li>
  <li>TIS、IcePop、MIS、WTRS 则是通过 IS 或者掩码机制在样本层面实施”约束 2”：
    <ul>
      <li>TIS：用 token-level 截断权重削弱比率过大样本的影响；</li>
      <li>IcePop：在 MoE 场景下用 token-level 双侧掩码硬性丢弃”极端不一致”的 token；</li>
      <li>MIS：在 sequence-level 直接屏蔽整条”比率过大”的轨迹；</li>
      <li>WTRS：在 token-level 检测比率过小的信号，一旦发现则在 sequence-level 拒绝整条轨迹；</li>
    </ul>
  </li>
  <li><strong>routing replay（路由回放）在三策略 TRPO 的视角下更像是“改写 surrogate objective”而非“直接实现约束”</strong>：无论回放行为路由（R3 类）还是回放参考路由，它们都把原本的 ⟦INLMATH176MATHEND⟧ 改成了一个路由被条件化/替换后的 surrogate objective，用<strong>一定的目标偏差与路由学习自由度的收缩</strong>换取<strong>降低方差与提升稳定性</strong>。因此它并不会真正收缩 ⟦INLMATH177MATHEND⟧ 或 ⟦INLMATH178MATHEND⟧，而是让路由不一致在 loss 中“不可见”；</li>
  <li>《RL 老训崩？训推差异是基石》、以及前文提到的 <em>Defeating Nondeterminism in LLM Inference</em> 等工程经验，则可以理解为在<strong>系统侧和数值实现侧</strong>，尽可能把 ⟦INLMATH179MATHEND⟧ 压低，让算法层的假设不至于完全失效。</li>
</ul>

<p>从这个统一视角出发，也许有助于回答几个实际问题（这里只是抛几个开放性问题）：</p>

<ul>
  <li>在什么条件下，我们还能把“大模型 RL 训练”理解成某种意义上的“近似 TRPO / PPO”？</li>
  <li>对一个具体的 RL 系统，我们究竟应该把主要精力花在：
    <ul>
      <li>收紧 ⟦INLMATH180MATHEND⟧（更强的 KL / 更稳的 sequence-level 目标），还是</li>
      <li>压低 ⟦INLMATH181MATHEND⟧（更一致的训推框架、更激进的 MIS / TIS / IcePop）？</li>
    </ul>
  </li>
  <li>在 MoE、异步采样、复杂 agent workflow 这些现实设定下，我们还能安全地假装“⟦INLMATH182MATHEND⟧”多久？</li>
</ul>

<p>本文只是在 TRPO 这个老框架上做了一个非常“<strong>最小化</strong>”的延展，把“三策略”显式写出来，并用它来整理现有的一些工作。难免有理解偏差或遗漏之处，如果你也关注实际大模型 RL 训练的情况，欢迎把你自己的设定抽象成“⟦INLMATH183MATHEND⟧ 三者的关系”，再回头看看 Theorem 2 里的那条不等式，或许会有不一样的直观感受。</p>

<div class="language-bibtex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">@misc</span><span class="p">{</span><span class="nl">WangZhang2025ThreePolicyTRPO</span><span class="p">,</span>
  <span class="na">author</span>       <span class="p">=</span> <span class="s">{Wang, Xihuai and Zhang, Shao}</span><span class="p">,</span>
  <span class="na">title</span>        <span class="p">=</span> <span class="s">{From Two Policies to Three: Extending TRPO under Behavior-Reference Policy Mismatch in LLM RL}</span><span class="p">,</span>
  <span class="na">year</span>         <span class="p">=</span> <span class="s">{2025}</span><span class="p">,</span>
  <span class="na">month</span>        <span class="p">=</span> <span class="nv">nov</span><span class="p">,</span>
  <span class="na">day</span>          <span class="p">=</span> <span class="s">{15}</span><span class="p">,</span>
  <span class="na">url</span>          <span class="p">=</span> <span class="s">{https://xihuai18.github.io/reinforcement-learning/2025/11/15/three-policy-en.html}</span><span class="p">,</span>
  <span class="na">urldate</span>      <span class="p">=</span> <span class="s">{2025-11-23}</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="reinforcement-learning" /><summary type="html"><![CDATA[现代 LLM RL 流程常常在"旧策略"悄然偏离实际生成 rollout 的行为策略时进行训练，破坏了通常的同策略假设。本文将经典的 TRPO 下界改写为三策略形式——行为策略、参考策略和目标策略——使得性能差距可以分解为两个可以推理和控制的 TV 距离。在这一视角下，Decoupled PPO、AReaL、TIS、IcePop、sequence-level MIS、最坏 Token 拒绝采样 (WTRS)、MoE 路由回放等方法，以及常见的训推对齐工程技巧，都可以看作是缩小这两个偏差的不同方式。]]></summary></entry></feed>