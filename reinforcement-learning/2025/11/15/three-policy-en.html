<!DOCTYPE html><html lang="en">

  <!-- Head -->
  <head>    <!-- Metadata, OpenGraph and Schema.org -->
    

    <!-- Standard metadata -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>From Two Policies to Three: Extending TRPO under Behavior‚ÄìReference Policy Mismatch in LLM RL | Xihuai Wang's Page</title>
    <meta name="author" content="Xihuai Leo Wang" />
    <meta name="description" content="Modern LLM RL pipelines often train under an "old policy" that silently drifts away from the behavior policy that actually generates rollouts, breaking the usual on-policy assumptions. This post rewrites the classic TRPO lower bound in a three-policy form ‚Äî behavior, reference, and target ‚Äî so that the performance gap cleanly decomposes into two TV distances that we can reason about and control. Seen through this lens, methods like Decoupled PPO, AReaL, TIS, IcePop, sequence-level MIS, Worst Token Reject Sampling (WTRS), MoE routing replay, and common engineering tricks for training‚Äìinference alignment all become different ways of shrinking these two deviations." />
    <meta name="keywords" content="Reinforcement Learning, Multi-agent System, Language Model" />

    <!-- OpenGraph -->
    <meta property="og:site_name" content="Xihuai Wang's Page" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Xihuai Wang's Page | From Two Policies to Three: Extending TRPO under Behavior‚ÄìReference Policy Mismatch in LLM RL" />
    <meta property="og:url" content="https://xihuai18.github.io/reinforcement-learning/2025/11/15/three-policy-en.html" />
    <meta property="og:description" content="Modern LLM RL pipelines often train under an "old policy" that silently drifts away from the behavior policy that actually generates rollouts, breaking the usual on-policy assumptions. This post rewrites the classic TRPO lower bound in a three-policy form ‚Äî behavior, reference, and target ‚Äî so that the performance gap cleanly decomposes into two TV distances that we can reason about and control. Seen through this lens, methods like Decoupled PPO, AReaL, TIS, IcePop, sequence-level MIS, Worst Token Reject Sampling (WTRS), MoE routing replay, and common engineering tricks for training‚Äìinference alignment all become different ways of shrinking these two deviations." />
    <meta property="og:locale" content="en_US" />

    <!-- Twitter card -->
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:title" content="From Two Policies to Three: Extending TRPO under Behavior‚ÄìReference Policy Mismatch in LLM RL" />
    <meta name="twitter:description" content="Modern LLM RL pipelines often train under an "old policy" that silently drifts away from the behavior policy that actually generates rollouts, breaking the usual on-policy assumptions. This post rewrites the classic TRPO lower bound in a three-policy form ‚Äî behavior, reference, and target ‚Äî so that the performance gap cleanly decomposes into two TV distances that we can reason about and control. Seen through this lens, methods like Decoupled PPO, AReaL, TIS, IcePop, sequence-level MIS, Worst Token Reject Sampling (WTRS), MoE routing replay, and common engineering tricks for training‚Äìinference alignment all become different ways of shrinking these two deviations." />
    
    

    <!-- Schema.org -->
    <script type="application/ld+json">
      {
        "author":
        {
          "@type": "Person",
          "name": "Xihuai Leo Wang"
        },
        "url": "https://xihuai18.github.io/reinforcement-learning/2025/11/15/three-policy-en.html",
        "@type": "WebSite",
        "description": "Modern LLM RL pipelines often train under an "old policy" that silently drifts away from the behavior policy that actually generates rollouts, breaking the usual on-policy assumptions. This post rewrites the classic TRPO lower bound in a three-policy form ‚Äî behavior, reference, and target ‚Äî so that the performance gap cleanly decomposes into two TV distances that we can reason about and control. Seen through this lens, methods like Decoupled PPO, AReaL, TIS, IcePop, sequence-level MIS, Worst Token Reject Sampling (WTRS), MoE routing replay, and common engineering tricks for training‚Äìinference alignment all become different ways of shrinking these two deviations.",
        "headline": "From Two Policies to Three: Extending TRPO under Behavior‚ÄìReference Policy Mismatch in LLM RL",
        "sameAs": ["https://scholar.google.com/citations?user=hy6v3qUAAAAJ", "https://github.com/xihuai18"],
        "name": "Xihuai Leo Wang",
        "@context": "https://schema.org"
      }
    </script>


    <!-- DNS Prefetch & Preconnect for faster external resource loading -->
    <link rel="dns-prefetch" href="https://cdn.jsdelivr.net">
    <link rel="dns-prefetch" href="https://fonts.googleapis.com">
    <link rel="dns-prefetch" href="https://fonts.gstatic.com">
    <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
    <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    <!-- Bootstrap & MDB -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous" />

    <!-- Fonts & Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&display=swap">

    <!-- Code Syntax Highlighting -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light" /><!-- Pseudocode -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pseudocode@2.4.1/build/pseudocode.min.css" integrity="sha256-VwMV//xgBPDyRFVSOshhRhzJRDyBmIACniLPpeXNUdc=" crossorigin="anonymous"><!-- Styles -->
    
    <link rel="shortcut icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ü§ñ</text></svg>">
    
    <link rel="stylesheet" href="/assets/css/main.css">
    <link rel="canonical" href="https://xihuai18.github.io/reinforcement-learning/2025/11/15/three-policy-en.html">

    <!-- Dark Mode -->
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/monokai.css" media="none" id="highlight_theme_dark" />

    <script src="/assets/js/theme.js"></script>
    <script src="/assets/js/dark_mode.js"></script>
    

    <!-- Prefetch/Preload for faster navigation -->
    <link rel="prefetch" href="/" as="document">
    <link rel="prefetch" href="/blog/" as="document">
    <link rel="prefetch" href="/publications/" as="document">
    <link rel="prefetch" href="/cv/" as="document">
    
    <!-- Instant.page for instant page loads on hover -->
    <script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module" defer></script>

  </head>

  <!-- Body -->
  <body class="fixed-top-nav ">

    <!-- Header --><header>

  <!-- Nav Bar -->
  <nav id="navbar"
    class="navbar navbar-light navbar-expand-sm fixed-top">
    <div class="container">
      <a class="navbar-brand title font-weight-lighter" href="/">Xihuai Wang's Page</a>
      <!-- Navbar Toggle -->
      <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav"
        aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar top-bar"></span>
        <span class="icon-bar middle-bar"></span>
        <span class="icon-bar bottom-bar"></span>
      </button>

      <div class="collapse navbar-collapse text-right" id="navbarNav">
        <ul class="navbar-nav ml-auto flex-nowrap">

          <!-- About -->
          <li class="nav-item ">
            <a class="nav-link" href="/">About</a>
          </li>
          
          <!-- Blog -->
          <li class="nav-item ">
            <a class="nav-link" href="/blog/">Blog</a>
          </li>

          <!-- CV -->
          <!-- 
          <li class="nav-item ">
            <a class="nav-link" href="/assets/pdf/" target="_blank"
              rel="noopener noreferrer">cv</a>
          </li> -->
          <!-- Other pages -->
          <li class="nav-item ">
            <a class="nav-link" href="/publications/">Publications</a>
          </li>
          <li class="nav-item ">
            <a class="nav-link" href="/cv/">CV</a>
          </li>
          <!-- Toggle theme mode -->
          <li class="nav-item toggle-container">
            <button id="light-toggle" class="nav-link" title="Change theme">
              <i class="fas fa-moon"></i>
              <i class="fas fa-sun"></i>
            </button>
          </li>
        </ul>
      </div>
    </div>
  </nav>
  
  <!-- Scrolling Progress Bar -->
  <progress id="progress" value="0">
    <div class="progress-container">
      <span class="progress-bar"></span>
    </div>
  </progress>
</header>


    <!-- Content -->
    <div class="container mt-5">
      <!-- _layouts/post.html -->

<div class="post toc-layout">
  <header class="post-header">
    <h1 class="post-title">From Two Policies to Three: Extending TRPO under Behavior‚ÄìReference Policy Mismatch in LLM RL</h1>
    <div class="post-meta-container">
      <div class="post-meta-row">
        <span class="post-date">
          <i class="far fa-calendar-alt"></i>
          November 15, 2025
        </span></div>
      <div class="post-tags-row">
        <a href="/blog/?year=2025" data-filter-link data-filter-type="year" data-filter-value="2025">
          üìÖ 2025
        </a>
          &nbsp; &middot; &nbsp;
          
            <a href="/blog/?category=reinforcement-learning" data-filter-link data-filter-type="category" data-filter-value="reinforcement-learning">
              üè∑Ô∏è reinforcement-learning
            </a>
            
          
      </div>
    </div>
  </header>

  <div class="post-links">
  

  <!-- Bilingual Links -->
  

  

  <!-- External Platform Links -->
  

  

  <!-- External Source (from plugin) -->
  

  <!-- Output links -->
  
    <a href="/reinforcement-learning/2025/11/15/three-policy-zh.html">‰∏≠ÊñáÁâàÊú¨</a>
  
    <a href="https://zhuanlan.zhihu.com/p/1973206684907365344" target="_blank">Áü•‰πé <img src="/assets/img/icons/zhihu.ico" style="height: 1em; vertical-align: middle;"></a>
  
    <a href="https://mp.weixin.qq.com/s/Gkjk_Fy8qWLkkdWAIuy9og" target="_blank">ÂæÆ‰ø°ÂÖ¨‰ºóÂè∑ <img src="/assets/img/icons/wechat.png" style="height: 1em; vertical-align: middle;"></a>
  
</div>


  <div class="row">
    
      <div class="col-lg toc-content">
    

      <article class="post-content">
        <p><img src="/assets/img/three-policy/three-policy-mini-class-en.png" alt="Mini-class" style="display:block;margin:0 auto;width:95%;max-width:100%;" /></p>

<h2 id="traininginference-mismatch-and-asynchronous-frameworks">Training‚ÄìInference Mismatch and Asynchronous Frameworks</h2>

<p>Recently I‚Äôve seen quite a lot of discussion around <em>training‚Äìinference mismatch</em> and <em>asynchronous RL frameworks</em> for large language models. My intuition is that many of these seemingly diverse and complicated issues are, in fact, manifestations of a more fundamental tension: a mismatch between the <strong>behavior policy</strong> and the <strong>reference policy</strong>.</p>

<p>In this post, I‚Äôll first briefly summarize the related work I‚Äôve come across, and then try to connect them through the lens of ‚Äúbehavior policy vs. reference policy,‚Äù as a complementary way to look at the problem.</p>

<p>Throughout the post I‚Äôll use:</p>

<ul>
  <li>
    <p><strong>Behavior policy</strong> $\mu$: the policy that <em>actually</em> generates rollouts, i.e., ‚Äúunder which distribution your data are sampled.‚Äù In modern LLM RL systems this typically corresponds to the implementation inside the inference engine (vLLM, SGLang, etc.), and under asynchronous frameworks it is often a <strong>mixture distribution over multiple worker policies</strong>.</p>
  </li>
  <li>
    <p><strong>Reference policy</strong> $\pi_{\theta_{\text{old}}}$: the policy used in the training objective for importance sampling, clipping, or KL constraints ‚Äî typically the ‚Äúold policy‚Äù in PPO / GRPO.</p>
  </li>
  <li>
    <p><strong>Target policy</strong> $\pi_\theta$: the policy we optimize in the training objective, i.e., ‚Äúwhat we want the model to become‚Äù ‚Äî typically the ‚Äúnew policy‚Äù in PPO / GRPO.</p>
  </li>
</ul>

<p>In the classical idealized setup, we usually <strong>implicitly assume</strong> $\mu = \pi_{\theta_{\text{old}}}$. In real systems, however, asynchronous updates, different inference / training backends, MoE routing fluctuations, and even hardware-level numerical differences cause these two policies to deviate to varying degrees.</p>

<h2 id="related-work">Related Work</h2>

<p>Below is a rough timeline of the works that left a strong impression on me (this is only a partial and biased subset of the literature I‚Äôve seen):</p>

<ul>
  <li><a href="https://arxiv.org/pdf/2110.00641">Decoupled PPO</a> was among the first to point out that in trust-region policy optimization methods (TRPO and PPO), the ‚Äúold policy‚Äù actually plays two distinct roles:
    <ol>
      <li>
        <p>It is used for importance sampling to perform off-policy correction. In this sense, the ‚Äúold policy‚Äù is meant to represent the <strong>behavior policy</strong> that generated the training data.</p>
      </li>
      <li>
        <p>It is also used to limit the update step size of the new policy. In this sense, the ‚Äúold policy‚Äù acts as a baseline to measure how much the new and old policies differ, i.e., a <strong>proximal policy</strong> (what I call the reference policy here).</p>
      </li>
    </ol>

    <p>The paper points out that these two roles do <em>not</em> have to be played by the same policy, and proposes the Decoupled PPO objective, which explicitly decouples ‚Äúwho generates the data‚Äù from ‚Äúwho defines the trust region‚Äù at the level of the optimization objective.</p>
  </li>
  <li>
    <p><a href="https://arxiv.org/abs/2505.24298">AReaL</a> focuses on the mismatch between behavior and reference policies under asynchronous training frameworks: rollouts are often generated by <strong>stale parameter versions</strong> or <strong>different workers</strong>. The paper adopts a Decoupled-PPO-style objective in the asynchronous setting, explicitly separating the behavior distribution from the reference policy, while still maintaining PPO-like optimization properties in this asynchronous regime.</p>
  </li>
  <li>
    <p><a href="https://arxiv.org/abs/2507.18071">GSPO</a> starts from stability issues of GRPO on long sequences and MoE models. It shows that token-level PPO / GRPO can become highly unstable when MoE expert routing is extremely volatile (especially when routing differs significantly between old and new policies), leading to large variance and training collapse. GSPO proposes a <strong>sequence-level</strong> PPO-style objective and ratio constraint, using the ratio over entire sequences to control updates. This substantially mitigates training collapse in MoE scenarios caused by routing instability and token-level noise.</p>
  </li>
  <li>
    <p><a href="https://fengyao.notion.site/off-policy-rl#28b721e3f6c480c3a756f8fb319e860d">Your Efficient RL Framework Secretly Brings You Off-Policy RL Training</a> observes that in existing LLM RL frameworks (such as VeRL), the inference stack and the training stack often differ across multiple functional modules (e.g., vLLM vs. FSDP / Megatron kernels and operators). This makes the behavior policy $\mu$ differ from the reference policy $\pi_{\theta_{\text{old}}}$, so what is <em>assumed</em> to be on-policy training actually becomes off-policy training with nontrivial bias. The article summarizes two existing ways to handle this: PPO-IS and vanilla-IS, and further proposes <strong>token-level truncated importance sampling (TIS)</strong> to downweight samples with severe training‚Äìinference mismatch. The author also wrote two more foundational notes analyzing training‚Äìinference mismatch from basic principles: <a href="https://fengyao.notion.site/pg-seq-token-part1-basics">Part I</a> and <a href="https://fengyao.notion.site/pg-seq-token-part2-mismatch">Part II</a>.</p>
  </li>
  <li>
    <p><a href="https://thinkingmachines.ai/blog/defeating-nondeterminism-in-llm-inference">Defeating Nondeterminism in LLM Inference</a> points out that the lack of <strong>batch-size invariance</strong> is a core source of randomness in LLM inference: the same input can yield noticeably different probability distributions under different batch compositions and kernel paths. This means that even when you ‚Äúnominally‚Äù have a single set of parameters, the <strong>behavior policy</strong> $\mu$ realized in practice can fluctuate with system load and scheduling, further exacerbating training‚Äìinference mismatch.</p>
  </li>
  <li>
    <p><a href="https://ringtech.notion.site/icepop">Small Leak Can Sink a Great Ship‚ÄîBoost RL Training on MoE with ùë∞ùíÑùíÜùë∑ùíêùíë!</a> observes that the above mismatch issues are further amplified in MoE models: routing itself is highly sensitive to small perturbations, and stacked with inference / training implementation differences and asynchronous sampling, it is easy to magnify bias and instability. The paper proposes IcePop: at the <strong>token level</strong>, it computes importance sampling ratios and applies <strong>two-sided masking</strong> to discard tokens whose ratios are either too large or too small. This removes ‚Äúvery noisy‚Äù data from the gradient, stabilizing RL training on MoE models.</p>
  </li>
  <li>
    <p><a href="https://yingru.notion.site/When-Speed-Kills-Stability-Demystifying-RL-Collapse-from-the-Training-Inference-Mismatch-271211a558b7808d8b12d403fd15edda">When Speed Kills Stability: Demystifying RL Collapse from the Training-Inference Mismatch</a> gives a systematic analysis of the causes of training‚Äìinference mismatch, including large amounts of out-of-distribution and low-probability content introduced by agent workflows, hardware and kernel-level numerical uncertainty, and how <strong>token-level</strong> importance sampling can introduce severe bias on long sequences. It further proposes <strong>sequence-level</strong> masked importance sampling (sequence-level MIS): compute an IS ratio at the sequence level and discard only those sequences whose overall ratio is too large, thereby controlling bias while strongly suppressing training collapse caused by extreme samples. The paper provides reasonably complete theoretical derivations and extensive experimental evidence.</p>
  </li>
  <li>
    <p><a href="https://arxiv.org/abs/2510.11370">Stabilizing MoE Reinforcement Learning by Aligning Training and Inference Routers</a> focuses on the MoE-specific problem of <strong>routing inconsistency</strong>. The paper finds that even for identical inputs, inference and training can route tokens to different experts due to small differences in operator implementations or parallelism. This ‚Äúphysical-path‚Äù mismatch makes the gap between the behavior policy $\mu$ and the reference policy $\pi_{\theta_{\text{old}}}$ much larger than expected and can easily cause training collapse. To address this, the paper proposes <strong>Rollout Routing Replay (R3)</strong>: during rollout it records, for each token, the actual expert indices selected by the inference router, and during training it <strong>replays</strong> these routing decisions instead of recomputing them. In effect, R3 forces the training and inference stacks to share the same routing paths in the MoE topology, aligning the two sides at the level of the computation graph.</p>
  </li>
  <li>
    <p><a href="https://zhuanlan.zhihu.com/p/1959976628290590602">RL ËÄÅËÆ≠Â¥©ÔºüËÆ≠Êé®Â∑ÆÂºÇÊòØÂü∫Áü≥</a> approaches the problem more from a practical perspective, sharing experience on how to engineer for near training‚Äìinference consistency: choosing consistent operators and precision settings, monitoring and constraining the log-prob gap between training and inference, etc. The focus is on framework-level engineering practices that can mitigate training‚Äìinference difference at the root.</p>
  </li>
  <li>
    <p><a href="https://verl.readthedocs.io/en/latest/algo/rollout_corr.html">verl Rollout Importance Sampling</a> introduces a <strong>Token Veto</strong> mechanism in its rollout correction module: it computes <strong>token-level</strong> importance ratios $\rho_t^{(\text{ref}\leftarrow\text{beh})}$, and if any token in a trajectory satisfies $\min_t \rho_t < \tau_{\text{veto}}$, the entire sequence is discarded from training. This ‚Äútoken-level detection, sequence-level veto‚Äù design embodies a conservative ‚Äúone-vote veto‚Äù strategy.</p>
  </li>
  <li><a href="https://storage.googleapis.com/intellect-3-paper/INTELLECT_3_Technical_Report.pdf">INTELLECT-3 Technical Report</a> adopts a similar rejection sampling strategy in its asynchronous distributed RL training framework. INTELLECT-3 computes <strong>token-level</strong> importance ratios for each rollout; if any token‚Äôs ratio falls below a threshold ($10^{-5}$ in the paper), the entire trajectory is masked.</li>
</ul>

<h2 id="a-minimally-unified-view-from-a-three-policy-trpo-perspective">A Minimally Unified View from a Three-Policy TRPO Perspective</h2>

<p>At first glance, the works listed above seem to tackle different aspects:</p>

<ul>
  <li><strong>Algorithmic level</strong>: how to formulate PPO / GRPO objectives, token-level vs. sequence-level, clip vs. mask, etc.</li>
  <li><strong>Systems level</strong>: how to align inference and training stacks.</li>
  <li><strong>Model level</strong>: how MoE routing amplifies instability, and so on.</li>
</ul>

<p>However, if we align everything along a single axis ‚Äî <strong>behavior policy vs. reference policy</strong> ‚Äî a large fraction of these issues can be placed in a relatively simple theoretical framework: a <strong>three-policy TRPO</strong>.</p>

<p>In the next section I‚Äôll unpack this three-policy TRPO in as simple math as I can. You can think of it as ‚ÄúTRPO + triangle inequality‚Äù ‚Äî a very small extension conceptually, but surprisingly handy when analyzing training‚Äìinference mismatch in LLM RL:</p>

<ul>
  <li>On the one hand, it helps us understand what exactly ‚Äútraining‚Äìinference mismatch‚Äù and ‚Äúasynchronous training frameworks‚Äù are harming within the TRPO view.</li>
  <li>On the other hand, it offers a unifying way to interpret TIS, IcePop, sequence-level MIS, etc. In the view of this post, they can all be seen as different incarnations of <strong>Constraint 2</strong> introduced below.</li>
</ul>

<h3 id="three-policies">Three Policies</h3>

<p>We stick to the notation from above and consider a discounted MDP with discount factor $\gamma \in (0,1)$:</p>

<ul>
  <li>States $s \in \mathcal{S}$, actions $a \in \mathcal{A}$.</li>
  <li>Policy $\pi(a \mid s)$.</li>
  <li>Discounted state distribution:
$$
  d_\pi(s) := (1-\gamma)\sum_{t=0}^\infty \gamma^t \Pr_\pi(s_t = s).
  $$</li>
  <li>Return (episodic view):
$$
  \mathcal{J}(\pi) := \mathbb{E}_\pi\Big[\sum_{t=0}^\infty \gamma^t r_t\Big].
  $$</li>
  <li>Value / Q / advantage functions:
$$
  V_\pi(s),\quad Q_\pi(s,a),\quad A_\pi(s,a) := Q_\pi(s,a) - V_\pi(s).
  $$</li>
</ul>

<p>It‚Äôs worth spelling out that in the three-policy setup we have:</p>

<ul>
  <li>
    <p><strong>Behavior policy</strong> $\mu$: the policy that actually generates rollouts. Data $(s,a,r,\dots)$ are sampled from it.</p>
  </li>
  <li>
    <p><strong>Reference policy</strong> $\pi_{\theta_{\text{old}}}$: the ‚Äúold policy‚Äù used in the optimization objective for importance sampling ratios, clipping, or KL constraints.</p>
  </li>
  <li>
    <p><strong>Target policy</strong> $\pi_\theta$: the policy we are optimizing in this update.</p>
  </li>
</ul>

<p>In the ideal setup we assume $\mu = \pi_{\theta_{\text{old}}}$; in real systems they are often unequal. This is the mathematical shadow of ‚Äútraining‚Äìinference mismatch.‚Äù</p>

<h3 id="two-policy-trpo">Two-Policy TRPO</h3>

<blockquote>
  <p>If you‚Äôre already familiar with TRPO, feel free to skip ahead to the ‚ÄúThree-Policy TRPO‚Äù subsection.</p>
</blockquote>

<p>All the theoretical guarantees in TRPO are stated <strong>with respect to the advantage function of some baseline policy</strong>. Since the only advantage we can estimate reliably in practice is $A_\mu$ (data are sampled under $\mu$), we may as well treat $\mu$ as the baseline policy.</p>

<p>A classical result is the <strong>Performance Difference Lemma</strong>:</p>

<blockquote>
  <p>For any two policies $\mu$ and $\pi_\theta$, we have</p>

  <p>$$
\mathcal{J}(\pi_\theta) - \mathcal{J}(\mu)
= \frac{1}{1-\gamma}\;
\mathbb{E}_{s\sim d_{\pi_\theta},\, a\sim\pi_\theta}[A_\mu(s,a)].
$$</p>
</blockquote>

<p>The intuition is simple:</p>

<ul>
  <li>$A_\mu(s,a)$ says: ‚Äúif I deviate from what $\mu$ would do at state $s$ and instead take action $a$, how much will the long-term return change?‚Äù</li>
  <li>Summing that ‚Äúgain‚Äù across all time steps, states, and actions gives the total improvement of the new policy over the behavior policy.</li>
</ul>

<p>The challenge in TRPO is that we cannot compute</p>

<p>$$
\mathbb{E}_{s\sim d_{\pi_\theta}, a\sim\pi_\theta}[A_\mu(s,a)]
$$</p>

<p>exactly, because $d_{\pi_\theta}$ is the state distribution of the <em>new</em> policy, under which we do not have samples.</p>

<p>So TRPO introduces a surrogate objective by replacing the state distribution with that of the behavior policy:</p>

<p>$$
L_\mu(\pi_\theta)
:= \mathcal{J}(\mu) + \frac{1}{1-\gamma}\mathbb{E}_{s\sim d_\mu,\,a\sim \pi_\theta}[A_\mu(s,a)].
$$</p>

<p>Intuitively, $L_\mu$ asks the following question: ‚ÄúUnder the states visited by the behavior policy, how good is the new policy if we just let it pick the actions?‚Äù</p>

<p>Starting from the Performance Difference Lemma, the difference between the true objective and the surrogate is:</p>

<p>$$
\mathcal{J}(\pi_\theta) - L_\mu(\pi_\theta)
= \frac{1}{1-\gamma}\;
  \sum_s \big(d_{\pi_\theta}(s) - d_\mu(s)\big)
  \,\mathbb{E}_{a\sim\pi_\theta(\cdot\mid s)}[A_\mu(s,a)].
$$</p>

<p>If we define</p>

<p>$$
\epsilon_\mu := \max_{s,a} |A_\mu(s,a)|,
$$</p>

<p>we immediately get the following upper bound:</p>

<blockquote>
  <p><strong>Lemma 1</strong></p>

  <p>$$
|\mathcal{J}(\pi_\theta) - L_\mu(\pi_\theta)|
\le \frac{\epsilon_\mu}{1-\gamma}\;
    \|d_{\pi_\theta} - d_\mu\|_1.
$$</p>
</blockquote>

<p>This reveals the first key quantity:</p>

<blockquote>
  <p><strong>State distribution shift</strong> $\|d_{\pi_\theta} - d_\mu\|_1$, i.e., ‚Äúhow differently the new policy sees the world, compared to the behavior policy.‚Äù</p>
</blockquote>

<p>We usually do <em>not</em> directly impose constraints on $\|d_{\pi_\theta} - d_\mu\|_1$. Instead, we constrain the per-timestep action distribution difference ‚Äî via trust regions, KL penalties, clipping, etc.</p>

<p>Define the total variation (TV) distance:</p>

<p>$$
D_{\mathrm{TV}}(p,q) := \frac{1}{2}\|p-q\|_1.
$$</p>

<p>Assume there is a constant $\beta$ such that</p>

<blockquote>
  <p>For all $s$, the TV distance between the behavior and target policies is bounded:</p>

  <p>$$
D_{\mathrm{TV}}\big(\mu(\cdot\mid s), \pi_\theta(\cdot\mid s)\big) \le \beta.
$$</p>
</blockquote>

<p>Intuitively: in any state, the action distribution of the ‚Äúnew policy‚Äù cannot deviate too much from that of the policy that generated the data.</p>

<p>A standard result (provable via coupling) is:</p>

<blockquote>
  <p><strong>Lemma 2</strong>
Under the assumption above,</p>

  <p>$$
\|d_{\pi_\theta} - d_\mu\|_1
\le \frac{2\gamma}{1-\gamma}\,\beta.
$$</p>
</blockquote>

<p>Combining Lemma 1 and Lemma 2, we obtain</p>

<p>$$
|\mathcal{J}(\pi_\theta) - L_\mu(\pi_\theta)|
\le \frac{\epsilon_\mu}{1-\gamma}\; \frac{2\gamma}{1-\gamma}\,\beta
= \frac{2\epsilon_\mu\gamma}{(1-\gamma)^2}\,\beta.
$$</p>

<p>This gives a compact <strong>two-policy TRPO lower bound (baseline = behavior policy)</strong>:</p>

<blockquote>
  <p><strong>Theorem 1 (Two-Policy TRPO)</strong></p>

  <p>$$
\mathcal{J}(\pi_\theta)
\;\ge\;
L_\mu(\pi_\theta)
\;-\;
\frac{2\epsilon_\mu\gamma}{(1-\gamma)^2}\,\beta.
$$</p>
</blockquote>

<p>This suggests:</p>

<ul>
  <li><strong>What really matters for the tightness of $L_\mu(\pi_\theta)$ as a surrogate for $\mathcal{J}(\pi_\theta)$ is how far the behavior policy $\mu$ and the target policy $\pi_\theta$ drift apart:</strong>
$$
  \beta = \max_s D_{\mathrm{TV}}\big(\mu(\cdot\mid s), \pi_\theta(\cdot\mid s)\big).
  $$</li>
</ul>

<p>If you can directly control this $\beta$, you can essentially port TRPO‚Äôs monotonic improvement guarantees to the behavior-policy view.</p>

<h3 id="three-policy-trpo">Three-Policy TRPO</h3>

<p>In practice, especially in large-scale LLM RL, <strong>we often cannot directly control $\beta$ itself.</strong></p>

<p>In most PPO / GRPO / GSPO / RLHF-style frameworks, the actual situation is:</p>

<ul>
  <li>Rollout data are generated by some <strong>behavior policy</strong> $\mu$ (some particular parameter version plus system details inside the inference engine).</li>
  <li>During updates, we would like to leverage a <strong>reference policy</strong> $\pi_{\theta_{\text{old}}}$ to limit the update of the <strong>target policy</strong> $\pi_\theta$.</li>
</ul>

<p>In other words, what we can actually touch and control are two quantities:</p>

<ol>
  <li>
    <p><strong>Reference vs. target</strong>: via KL penalties, clipping, etc., we constrain</p>

    <p>$$
   D_{\mathrm{TV}}\big(\pi_{\theta_{\text{old}}}(\cdot\mid s),\pi_\theta(\cdot\mid s)\big).
   $$</p>
  </li>
  <li>
    <p><strong>Behavior vs. reference</strong>: we would <em>like</em> to keep
$$
   D_{\mathrm{TV}}\big(\mu(\cdot\mid s),\pi_{\theta_{\text{old}}}(\cdot\mid s)\big)
   $$
small as well ‚Äî this is where training‚Äìinference mismatch and asynchronous execution come in.</p>
  </li>
</ol>

<p>This motivates defining two ‚Äúproxy gaps‚Äù:</p>

<ul>
  <li>
    <p><strong>Constraint 1: reference vs. target</strong></p>

    <p>$$
  \alpha_0
  := \max_s D_{\mathrm{TV}}\big(\pi_{\theta_{\text{old}}}(\cdot\mid s),
                                \pi_\theta(\cdot\mid s)\big);
  $$</p>
  </li>
  <li>
    <p><strong>Constraint 2: behavior vs. reference</strong>
$$
  \alpha_1
  := \max_s D_{\mathrm{TV}}\big(\mu(\cdot\mid s),
                                \pi_{\theta_{\text{old}}}(\cdot\mid s)\big).
  $$</p>
  </li>
</ul>

<p>Intuitively:</p>

<ul>
  <li>$\alpha_0$: how far the new policy is from the ‚Äúold policy‚Äù you are using in the loss ‚Äî this is the trust-region part.</li>
  <li>$\alpha_1$: how far the reference policy used in training is from the <em>actual</em> behavior policy that generated the data ‚Äî this is the footprint of training‚Äìinference mismatch and asynchrony.</li>
</ul>

<p>Now we can plug these two quantities back into the TRPO lower bound.</p>

<p>For any state $s$, by the triangle inequality we have</p>

<p>$$
\begin{aligned}
D_{\mathrm{TV}}\big(\mu(\cdot\mid s),\pi_\theta(\cdot\mid s)\big)
&\le
D_{\mathrm{TV}}\big(\mu(\cdot\mid s),\pi_{\theta_{\text{old}}}(\cdot\mid s)\big)
\\
&\quad +
D_{\mathrm{TV}}\big(\pi_{\theta_{\text{old}}}(\cdot\mid s),\pi_\theta(\cdot\mid s)\big).
\end{aligned}
$$</p>

<p>Taking the supremum over $s$ gives</p>

<p>$$
\beta
:= \max_s D_{\mathrm{TV}}\big(\mu(\cdot\mid s),\pi_\theta(\cdot\mid s)\big)
\;\le\;
\alpha_1 + \alpha_0.
$$</p>

<p>Plugging this inequality into the two-policy TRPO bound (Theorem 1), and denoting</p>

<p>$$
C := \frac{2\epsilon_\mu\gamma}{(1-\gamma)^2},
$$</p>

<p>we obtain</p>

<p>$$
\mathcal{J}(\pi_\theta)
\;\ge\;
L_\mu(\pi_\theta)
\;-\;
C\,\beta
\;\ge\;
L_\mu(\pi_\theta)
\;-\;
C\,(\alpha_0 + \alpha_1).
$$</p>

<p>This yields a very direct <strong>three-policy TRPO lower bound</strong>:</p>

<blockquote>
  <p><strong>Theorem 2 (Three-Policy TRPO)</strong>
Let</p>

  <p>$$
\epsilon_\mu := \max_{s,a} |A_\mu(s,a)|,\quad
C := \frac{2\epsilon_\mu\gamma}{(1-\gamma)^2},
$$</p>

  <p>and</p>

  <p>$$
\alpha_0
:= \max_s D_{\mathrm{TV}}\big(\pi_{\theta_{\text{old}}}(\cdot\mid s),
                              \pi_\theta(\cdot\mid s)\big),
\quad
\alpha_1
:= \max_s D_{\mathrm{TV}}\big(\mu(\cdot\mid s),
                              \pi_{\theta_{\text{old}}}(\cdot\mid s)\big).
$$</p>

  <p>Then for any target policy $\pi_\theta$,</p>

  <p>$$
\boxed{
\mathcal{J}(\pi_\theta)
\;\ge\;
L_\mu(\pi_\theta)
\;-\; C\,(\alpha_0 + \alpha_1)
}
$$</p>

  <p>where</p>

  <p>$$
L_\mu(\pi_\theta)
:=
\mathcal{J}(\mu) + \frac{1}{1-\gamma}
  \mathbb{E}_{s\sim d_\mu,a\sim\pi_\theta}[A_\mu(s,a)].
$$</p>
</blockquote>

<p>The meaning of this bound is quite straightforward:</p>

<ul>
  <li><strong>The gap between the surrogate objective $L_\mu(\pi_\theta)$ and the true performance $\mathcal{J}(\pi_\theta)$ decomposes into two pieces:</strong>
    <ul>
      <li>The deviation between reference and target policies, $\alpha_0$.</li>
      <li>The deviation between behavior and reference policies, $\alpha_1$.</li>
    </ul>
  </li>
</ul>

<p>As long as both terms are small, <strong>optimizing $L_\mu$ is likely to improve $\mathcal{J}$</strong>.</p>

<h3 id="how-to-control-these-two-deviations-in-practice">How to Control These Two Deviations in Practice?</h3>

<p>We can now revisit various practical methods through the lens of Theorem 2:</p>

<ul>
  <li>Most PPO / GRPO / GSPO-style work focuses on controlling <strong>Constraint 1: $\alpha_0$</strong>.</li>
  <li>Most TIS / IcePop / MIS-style work, in the view of this post, can be understood as primarily targeting <strong>Constraint 2: $\alpha_1$</strong>.</li>
</ul>

<p>In the remainder of this post I will focus on <strong>Constraint 2</strong>.</p>

<p>The goal of Constraint 2 is: <strong>ensure that the data used in training come (effectively) from a behavior policy that is close to the reference policy.</strong></p>

<p>In practice, this usually involves both <strong>system-level mechanisms</strong> and <strong>algorithmic mechanisms (importance sampling)</strong>.</p>

<ol>
  <li><strong>System level: keep the behavior policy from drifting too far</strong>
    <ul>
      <li>
        <p>Asynchronous frameworks:
Tag each sample with a policy version, and only use data generated by parameter versions that are close enough to $\pi_{\theta_{\text{old}}}$.</p>
      </li>
      <li>
        <p>Training‚Äìinference alignment:
Use consistent precision, operators, and similar kernel behavior between the training and inference stacks.</p>
      </li>
    </ul>

    <p>These mechanisms act ‚Äúoutside‚Äù the algorithm to make $\mu$ closer to $\pi_{\theta_{\text{old}}}$, thereby shrinking $\alpha_1$.</p>
  </li>
  <li>
    <p><strong>Algorithmic level: sample-wise correction</strong></p>

    <p>At the algorithmic level, we no longer attempt to ‚Äúfix‚Äù the entire behavior policy. Instead, we use importance sampling ratios to correct at the <strong>sample level</strong>: we filter or reweight samples so that the behavior policy is close to the reference policy <em>on the subset of data that actually participates in training</em>, or at least reduce the influence of samples with large mismatch.</p>

    <p>Concretely, this gives rise to methods like TIS, IcePop, and MIS, which can be seen as different ways of implementing Constraint 2 at the sample level.</p>
  </li>
</ol>

<h2 id="importance-sampling-and-masking-four-implementations-of-constraint-2">Importance Sampling and Masking: Four Implementations of Constraint 2</h2>

<p>In this section I‚Äôll reuse the notation introduced above to write down the objectives of these three methods, focusing only on the design choices related to ‚Äúbehavior vs. reference policy.‚Äù Let the token-level PPO / GRPO-style update term be</p>

<p>$$
g_\theta(t)
= \min\big(r_t(\theta) A_t,\ \text{clip}(r_t(\theta),1-\epsilon,1+\epsilon) A_t\big),
$$</p>

<p>where</p>

<p>$$
r_t(\theta) = \frac{\pi_\theta(a_t\mid s_t)}{\pi_{\theta_{\text{old}}}(a_t\mid s_t)},
\quad (s_t,a_t)\sim\mu,\quad A_t := A_\mu(s_t,a_t).
$$</p>

<p>Here:</p>

<ul>
  <li>$r_t(\theta)$ is the <strong>target vs. reference</strong> ratio (corresponding to Constraint 1).</li>
  <li>$A_t$ is the advantage estimated from data sampled under the behavior policy.</li>
</ul>

<p>To connect token-level $(s_t,a_t)$ with sequence-level $(x,y)$ notation, consider the RLHF setting (reinforcement learning from human feedback) for LLMs:</p>

<ul>
  <li>Prompts are denoted by $x$, and responses by $y = (y_1,\dots,y_{|y|})$.</li>
  <li>Token-level states and actions are defined as $s_t := (x,y_{<t})$, $a_t := y_t$.</li>
  <li>The behavior and reference policies on sequences can then be written as
$$
  \mu(y\mid x) = \prod_{t=1}^{|y|}\mu(a_t=y_t\mid s_t),\quad
  \pi_{\theta_{\text{old}}}(y\mid x) = \prod_{t=1}^{|y|}\pi_{\theta_{\text{old}}}(a_t=y_t\mid s_t).
  $$</li>
</ul>

<p>To quantify the deviation between reference and behavior policies, we can define the token-level importance ratio:</p>

<p>$$
\rho_t^{(\text{ref}\leftarrow\text{beh})} :=
\frac{\pi_{\theta_{\text{old}}}(a_t\mid s_t)}{\mu(a_t\mid s_t)},
$$</p>

<p>and its sequence-level counterpart:</p>

<p>$$
\rho(y\mid x) := \frac{\pi_{\theta_{\text{old}}}(y\mid x)}{\mu(y\mid x)}
= \prod_{t=1}^{|y|} \rho_t^{(\text{ref}\leftarrow\text{beh})}.
$$</p>

<p>The difference between TIS, IcePop, and MIS lies in <strong>how they use $\rho$ to implement Constraint 2</strong>.</p>

<h3 id="1-tis-token-level-truncated-importance-sampling">1. TIS: Token-Level Truncated Importance Sampling</h3>

<p>TIS directly truncates the token-level ratio $\rho_t^{(\text{ref}\leftarrow\text{beh})}$; define</p>

<p>$$
\color{blue}{w_t = \min\big(\rho_t^{(\text{ref}\leftarrow\text{beh})},\ C_{\text{IS}}\big)}.
$$</p>

<p>The update objective becomes</p>

<p>$$
L_{\text{TIS}}(\theta)
= - \mathbb{E}_{(s_t,a_t)\sim\mu}\big[\,\color{blue}{w_t}\; g_\theta(t)\big].
$$</p>

<ul>
  <li>The blue $\color{blue}{w_t}$ is the truncated IS weight: extremely large ratios are capped at a constant $C_{\text{IS}}$.</li>
  <li>From the three-policy TRPO perspective, this is a <em>soft</em> way to downweight tokens where behavior and reference policies differ significantly, effectively reducing their contribution to $\alpha_1$ in the gradient.</li>
</ul>

<h3 id="2-icepop-token-level-two-sided-masking-in-moe">2. IcePop: Token-Level Two-Sided Masking in MoE</h3>

<p>IcePop also uses $\rho_t^{(\text{ref}\leftarrow\text{beh})}$ as a discrepancy measure, but opts for <strong>two-sided masking</strong>:</p>

<p>$$
\color{blue}{m_t = \mathbf{1}\big[C_{\text{low}} \le \rho_t^{(\text{ref}\leftarrow\text{beh})} \le C_{\text{high}}\big]}.
$$</p>

<p>The update objective becomes</p>

<p>$$
L_{\text{IcePop}}(\theta)
= - \mathbb{E}_{(s_t,a_t)\sim\mu}\big[\,\color{blue}{m_t}\; g_\theta(t)\big].
$$</p>

<ul>
  <li>The blue $\color{blue}{m_t}$ decides whether a token participates in the update: tokens with ratios that are too large or too small are dropped entirely.</li>
  <li>This is a <em>hard</em> sample selection scheme: only tokens where behavior and reference policies are reasonably aligned (ratios within $[C_{\text{low}}, C_{\text{high}}]$) are kept, implementing a stricter version of Constraint 2 at the token level.</li>
</ul>

<h3 id="3-sequence-level-mis-masked-importance-sampling-over-entire-sequences">3. Sequence-Level MIS: Masked Importance Sampling Over Entire Sequences</h3>

<p>The core operation in sequence-level MIS is to <strong>retain only sequences whose sequence-level IS ratio is below a threshold $C$</strong>, zeroing out the loss for all other sequences:</p>

<p>$$
\color{blue}{
\rho(y\mid x)
\leftarrow
\rho(y\mid x)\,\mathbf{1}\{\rho(y\mid x)\le C\}
}
$$</p>

<p>In a unified loss form, this can be written as</p>

<p>$$
L_{\text{MIS}}(\theta)
=-\,\mathbb{E}_{(x,y)\sim\mu}
\Big[
\color{blue}{\rho(y\mid x)\,\mathbf{1}\{\rho(y\mid x)\le C\}}
\;\cdot\; \sum_{t=1}^{|y|}g_\theta(t)
\Big].
$$</p>

<p>In words:</p>

<ul>
  <li>For <strong>sequences with small IS ratios</strong>, the full weight $\rho(y\mid x)$ is retained for off-policy correction.</li>
  <li>For <strong>sequences whose ratios exceed the threshold $C$</strong>, the entire policy loss is masked out (weight set to $0$).</li>
</ul>

<p>From the three-policy TRPO viewpoint, sequence-level MIS no longer truncates at the token level. Instead, it performs <strong>trajectory-level</strong> filtering: it drops trajectories where behavior and reference policies diverge too much, and only optimizes on the subset with $\rho(y\mid x)\le C$. This implements Constraint 2 at the sequence level.</p>

<h3 id="4-worst-token-reject-sampling-rejecting-entire-sequences-based-on-the-worst-token">4. Worst Token Reject Sampling: Rejecting Entire Sequences Based on the Worst Token</h3>

<p>The verl Token Veto mechanism and INTELLECT-3 both adopt a rejection sampling strategy that can be collectively called <strong>Worst Token Reject Sampling (WTRS)</strong>:</p>

<ul>
  <li>
    <p><strong>verl Token Veto</strong>: In its rollout correction module, if any token in a trajectory has $\min_t \rho_t < \tau_{\text{veto}}$, the entire sequence is discarded via response*mask. The threshold $\tau*{\text{veto}}$ is user-configurable.</p>
  </li>
  <li>
    <p><strong>INTELLECT-3 Token Masking</strong>: In its asynchronous distributed RL framework, if any token‚Äôs ratio is below $10^{-5}$, the entire trajectory is masked.</p>
  </li>
</ul>

<p>The core operation is identical: <strong>if any token in a trajectory has an IS ratio below a threshold $\tau$, the entire sequence is rejected from training.</strong> This can be written as:</p>

<p>$$
\color{blue}{
m(y\mid x) = \mathbf{1}\Big\{\min_{t=1}^{|y|} \rho_t^{(\text{ref}\leftarrow\text{beh})} \ge \tau\Big\}
}
$$</p>

<p>In a unified loss form:</p>

<p>$$
L_{\text{WTRS}}(\theta)
=-\,\mathbb{E}_{(x,y)\sim\mu}
\Big[
\color{blue}{m(y\mid x)}
\;\cdot\; \sum_{t=1}^{|y|}g_\theta(t)
\Big].
$$</p>

<p>In words:</p>

<ul>
  <li>For <strong>sequences where all tokens have IS ratios $\ge \tau$</strong>: participate in training normally.</li>
  <li>For <strong>sequences where any token has an IS ratio $< \tau$</strong>: the entire sequence‚Äôs policy loss is masked out.</li>
</ul>

<p>From the three-policy TRPO perspective, WTRS adopts a hybrid ‚Äútoken-level detection, sequence-level veto‚Äù strategy: it detects extreme mismatch signals at the <strong>token level</strong>, and once detected, rejects at the <strong>sequence level</strong>. This ‚Äúone-vote veto‚Äù design reflects a conservative philosophy ‚Äî when a trajectory contains a token that ‚Äúthe behavior policy generated but the reference policy would almost never generate,‚Äù <strong>the credibility of the entire trajectory is called into question</strong>, thereby implementing control over Constraint 2 ($\mu$ vs. $\pi_{\theta_{\text{old}}}$ deviation) at the trajectory granularity.</p>

<h2 id="moe-routing-replay-what-does-it-actually-do-in-three-policy-trpo">MoE Routing Replay: What Does It Actually Do in Three-Policy TRPO?</h2>

<p>In MoE (Mixture-of-Experts) models, training‚Äìinference mismatch often first appears as <strong>routing inconsistency</strong>: even with identical parameters, the inference and training stacks may route tokens to different experts because of small differences in operators, parallelism, or numerics. A natural engineering response is <strong>routing replay</strong>: during rollout (inference), record the actual expert paths, and during training, force the model to reuse these routing decisions.</p>

<p>These methods are often intuitively described as ‚Äúimplementing Constraint 2 and shrinking $\alpha_1$.‚Äù From the three-policy TRPO perspective, a more precise statement is:</p>

<blockquote>
  <p><strong>Routing replay does not tighten the original surrogate objective via a constraint; instead, it rewrites the surrogate objective into one that is conditioned on / replaces the routing.</strong>
It makes routing mismatch invisible in the loss, but it does not actually shrink the true policy distances $\alpha_0$ or $\alpha_1$.</p>
</blockquote>

<p>Below I‚Äôll sketch a <strong>minimal</strong> abstraction that is sufficient to make this concrete.</p>

<h3 id="surrogate-objective-in-moe-separating-routing-and-token-generation">Surrogate Objective in MoE: Separating Routing and Token Generation</h3>

<p>Abstract an MoE model as a two-stage stochastic decision: ‚Äúfirst choose an expert $z$, then generate token $a$ conditioned on that expert.‚Äù The target policy can be factorized as</p>

<p>$$
\pi_\theta(a,z\mid s)=\omega_\theta(z\mid s)\,\pi_\theta(a\mid s,z),
$$</p>

<p>where:</p>

<ul>
  <li>$\omega_\theta(z\mid s)$ is the router distribution.</li>
  <li>$\pi_\theta(a\mid s,z)$ is the token distribution conditioned on expert $z$.</li>
</ul>

<p>In the three-policy TRPO setting, the surrogate objective we actually want to optimize can be written as</p>

<p>$$
L_\mu(\pi_\theta) = \mathcal{J}(\mu) + \frac{1}{1-\gamma}
\mathbb{E}_{s\sim d_\mu}
\bigg[
\sum_z \omega_\theta(z\mid s)\,F_\theta(s,z)
\bigg],
$$</p>

<p>where I use</p>

<p>$$
F_\theta(s,z)
:=
\sum_a \pi_\theta(a\mid s,z)\,A_\mu(s,a,z)
$$</p>

<p>to denote the expert-level aggregation of advantages.</p>

<p>The key point is that <strong>in the original $L_\mu(\pi_\theta)$, the routing distribution is precisely the current router $\omega_\theta$ that we are updating</strong>. In other words, RL on MoE is updating not only the token-generation distribution but also the router itself.</p>

<h3 id="1-replaying-behavior-policy-routing-behavior-router-replay--r3-style">(1) Replaying Behavior-Policy Routing (Behavior-Router Replay / R3-Style)</h3>

<p>R3-style methods record, during rollout, the set of experts $M_\mu(s)$ actually selected by the behavior policy on the inference side, and during training force the current policy to <strong>route only within this set</strong>. This can be written as a ‚Äúconditional projection‚Äù of the routing distribution:</p>

<p>$$
\omega_\theta^{\text{R3}}(z\mid s)
:=
\frac{\omega_\theta(z\mid s)\,\mathbf{1}\{z\in M_\mu(s)\}}
     {\sum_{z'\in M_\mu(s)}\omega_\theta(z'\mid s)} .
$$</p>

<p>The surrogate objective that is actually optimized during training becomes</p>

<p>$$
L_\mu^{\text{R3}}(\pi_\theta) =
\mathcal{J}(\mu) +
\frac{1}{1-\gamma}
\mathbb{E}_{s\sim d_\mu}
\bigg[
\sum_{z\in M_\mu(s)} \omega_\theta^{\text{R3}}(z\mid s)\,F_\theta(s,z)
\bigg].
$$</p>

<p>Compared to the original $L_\mu(\pi_\theta)$, R3 does <em>not</em> push $\omega_\theta$ closer to $\omega_{\text{old}}$ or $\omega_\mu$. Instead, it:</p>

<ul>
  <li><strong>replaces the expectation over $z\sim\omega_\theta$ by a conditional expectation over $z\sim\omega_\theta(\cdot\mid z\in M_\mu(s))$</strong>, and</li>
  <li>equivalently, <strong>shrinks the feasible routing support to $M_\mu(s)$</strong>.</li>
</ul>

<p>So R3 is optimizing a ‚Äúbehavior-routing-conditioned surrogate objective,‚Äù rather than the original $L_\mu(\pi_\theta)$. The benefit is substantially reduced variance and improved stability; the cost is that <strong>the router‚Äôs exploration and update freedom is constrained at every state</strong>.</p>

<h3 id="2-replaying-reference-policy-routing-reference-router-replay">(2) Replaying Reference-Policy Routing (Reference-Router Replay)</h3>

<p>Another class of routing-replay schemes instead reuses the reference policy‚Äôs router $\omega_{\text{old}}$. This is equivalent to training a hybrid policy</p>

<p>$$
\hat\pi_\theta(a,z\mid s)
:=
\omega_{\text{old}}(z\mid s)\,\pi_\theta(a\mid s,z),
$$</p>

<p>with surrogate objective</p>

<p>$$
L_\mu^{\text{ref-replay}}(\pi_\theta) =
\mathcal{J}(\mu) +
\frac{1}{1-\gamma}
\mathbb{E}_{s\sim d_\mu}
\bigg[
\sum_z \omega_{\text{old}}(z\mid s)\,F_\theta(s,z)
\bigg].
$$</p>

<p>This has the effect that:</p>

<ul>
  <li>In the surrogate objective, the router is <strong>frozen to the old router</strong> $\omega_{\text{old}}$, so the ‚Äúreference vs. target‚Äù discrepancy in routing is simply removed from the loss.</li>
  <li>Training becomes insensitive to how far the <em>new</em> router $\omega_\theta$ drifts from $\omega_{\text{old}}$, thereby sidestepping the instabilities caused by routing mismatch.</li>
</ul>

<p>Again, this is fundamentally a <strong>change of objective</strong>:</p>

<ul>
  <li>The deviation $\alpha_0$ in the true policy space is not reduced; it is merely rendered invisible by redefining the surrogate in terms of the old router.</li>
  <li>Learning of the router is effectively frozen or heavily suppressed.</li>
</ul>

<h3 id="routing-replay-as-a-change-of-surrogate-objective">Routing Replay as a Change of Surrogate Objective</h3>

<p>Putting these replay variants side by side, they share several properties:</p>

<ol>
  <li><strong>They optimize not the original $L_\mu(\pi_\theta)$, but a surrogate where routing has been conditioned or replaced.</strong></li>
  <li><strong>They do not directly shrink the three-policy TRPO bound‚Äôs $\alpha_0$ or $\alpha_1$</strong>. Routing mismatch is removed from the loss, but it still exists in the true policy distances.</li>
  <li><strong>In practice they trade bias for variance</strong>: replay typically lowers variance and improves stability, but may also limit the router‚Äôs ability to learn routing patterns that are optimal for the RL objective.</li>
</ol>

<p>So, in the three-policy TRPO view, a more accurate characterization is:</p>

<blockquote>
  <p><strong>Routing replay is best thought of as a rewrite of the surrogate objective, not as a direct implementation of a constraint on $\alpha_0$ or $\alpha_1$.</strong></p>
</blockquote>

<h2 id="conclusion">Conclusion</h2>

<p>If I had to compress this post into a single sentence, it would be:</p>

<blockquote>
  <p><strong>Many issues around ‚Äútraining‚Äìinference mismatch‚Äù and ‚Äúasynchronous training‚Äù in large-scale LLM RL can be understood, in the TRPO framework, as severely underestimating the deviation between the behavior policy $\mu$ and the reference policy $\pi_{\theta_{\text{old}}}$ ‚Äî i.e., the term $\alpha_1$.</strong></p>
</blockquote>

<p>From two policies to three, what we did is conceptually very small:</p>

<ul>
  <li>
    <p>We rewrote the TRPO lower bound from an ‚Äúold vs. new policy‚Äù narrative into a ‚Äú<strong>behavior‚Äìreference‚Äìtarget</strong>‚Äù three-policy relationship.</p>
  </li>
  <li>We explicitly separated two TV distances:
    <ul>
      <li><strong>Constraint 1: reference vs. target</strong>, $\alpha_0$, corresponding to the KL / clip / trust-region style constraints in PPO / GRPO / GSPO.</li>
      <li><strong>Constraint 2: behavior vs. reference</strong>, $\alpha_1$, capturing real-world factors like asynchronous frameworks, training‚Äìinference mismatch, MoE routing volatility, kernel-level nondeterminism, etc.</li>
    </ul>
  </li>
  <li>This leads to a simple conclusion:
The gap between the surrogate $L_\mu(\pi_\theta)$ and the true performance $\mathcal{J}(\pi_\theta)$ scales with $\alpha_0 + \alpha_1$.</li>
</ul>

<p>Under this lens (which is of course only one of many possible perspectives):</p>

<ul>
  <li>
    <p>Decoupled PPO / AReaL can be viewed as <strong>formally acknowledging the existence of three policies</strong> and explicitly decoupling the behavior distribution from the reference policy in the objective.</p>
  </li>
  <li>TIS, IcePop, MIS, and WTRS can be seen as different ways of implementing <strong>Constraint 2</strong> using importance sampling truncation / masking:
    <ul>
      <li>TIS: token-level truncation of IS weights to soften the influence of extreme samples.</li>
      <li>IcePop: token-level two-sided masking in MoE to hard-drop tokens with severe mismatch.</li>
      <li>MIS: sequence-level masking to ignore entire trajectories whose behavior‚Äìreference mismatch is too large.</li>
      <li>WTRS: token-level detection of extremely small ratios, rejecting the entire trajectory once such a signal is found.</li>
    </ul>
  </li>
  <li>
    <p><strong>Routing replay</strong> (whether replaying behavior routing in R3-style schemes or replaying reference routing) is better viewed as <strong>changing the surrogate objective</strong> rather than directly implementing a constraint: both variants replace the original $L_\mu(\pi_\theta)$ with a routing-conditioned / routing-frozen surrogate, trading off some objective bias and reduced routing learning freedom for lower variance and greater stability, without actually shrinking $\alpha_0$ or $\alpha_1$‚Äîthey simply make routing mismatch invisible in the loss.</p>
  </li>
  <li>Engineering advice such as in <em>RL ËÄÅËÆ≠Â¥©ÔºüËÆ≠Êé®Â∑ÆÂºÇÊòØÂü∫Áü≥</em> and system-level work like <em>Defeating Nondeterminism in LLM Inference</em> can be interpreted as efforts to <strong>reduce $\alpha_1$ on the systems and numerical side</strong>, so that the assumptions underlying the algorithms do not break too badly.</li>
</ul>

<p>From this unified perspective, it may also be easier to think about the following practical questions (these are completely open and I don‚Äôt have definitive answers):</p>

<ul>
  <li>
    <p>Under what conditions can we still reasonably interpret ‚ÄúLLM RL training‚Äù as some approximate form of TRPO / PPO?</p>
  </li>
  <li>For a concrete RL system, where should we invest more effort:
    <ul>
      <li>tightening $\alpha_0$ (stronger KL control, more stable sequence-level objectives), or</li>
      <li>reducing $\alpha_1$ (better training‚Äìinference alignment, more aggressive MIS / TIS / IcePop)?</li>
    </ul>
  </li>
  <li>In the presence of MoE, asynchronous sampling, and complex agent workflows, how long can we safely pretend that ‚Äú$\mu \approx \pi_{\theta_{\text{old}}}$‚Äù?</li>
</ul>

<p>This post is just a very <strong>minimal</strong> extension of the classic TRPO framework, making the ‚Äúthree policies‚Äù explicit and using them to organize some existing work. There are inevitably misunderstandings and omissions. If you also care about how RL training actually behaves in large LLM systems, I‚Äôd be very interested to see how your own setup can be abstracted into a relationship between $\mu$, $\pi_{\theta_{\text{old}}}$, and $\pi_\theta$, and then re-examined through the inequality in Theorem 2. It might give a slightly different intuitive feel for what your system is really optimizing.</p>

<div class="language-bibtex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">@misc</span><span class="p">{</span><span class="nl">WangZhang2025ThreePolicyTRPO</span><span class="p">,</span>
  <span class="na">author</span>       <span class="p">=</span> <span class="s">{Wang, Xihuai and Zhang, Shao}</span><span class="p">,</span>
  <span class="na">title</span>        <span class="p">=</span> <span class="s">{From Two Policies to Three: Extending TRPO under Behavior-Reference Policy Mismatch in LLM RL}</span><span class="p">,</span>
  <span class="na">year</span>         <span class="p">=</span> <span class="s">{2025}</span><span class="p">,</span>
  <span class="na">month</span>        <span class="p">=</span> <span class="nv">nov</span><span class="p">,</span>
  <span class="na">day</span>          <span class="p">=</span> <span class="s">{15}</span><span class="p">,</span>
  <span class="na">url</span>          <span class="p">=</span> <span class="s">{https://xihuai18.github.io/reinforcement-learning/2025/11/15/three-policy-en.html}</span><span class="p">,</span>
  <span class="na">urldate</span>      <span class="p">=</span> <span class="s">{2025-11-23}</span>
<span class="p">}</span>
</code></pre></div></div>

      </article>

      

      
        
      </div>

    <div class="col-lg-3 d-none d-lg-block toc-sidebar-col">
      <aside class="toc-sidebar" data-toc-sidebar id="toc-sidebar">
  <div class="toc-sidebar__header">
    <div class="toc-sidebar__title">Contents</div>
    <button class="toc-toggle-btn" aria-label="Toggle table of contents" aria-expanded="false" aria-controls="toc-content" data-toc-toggle>
      <i class="fas fa-chevron-right"></i>
    </button>
  </div>
  <nav
    id="toc-content"
    class="toc js-page-toc"
    data-toc
    data-toc-content=".toc-content"
    data-toc-headings="h2,h3"
    data-toc-min-items="2"
    aria-label="Contents"
  ></nav>
</aside>

<!-- Collapsed TOC toggle button (shown when TOC is collapsed) -->
<button class="toc-collapsed-toggle" aria-label="Show table of contents" aria-expanded="false" aria-controls="toc-content" data-toc-expand>
  <i class="fas fa-list"></i>
</button>


    </div>
  </div>
</div>

    </div>

    <!-- Footer -->    
    <footer class="fixed-bottom">
      <div class="container mt-0">
        &copy; Copyright 2026 Xihuai Leo Wang. Last updated: January 16, 2026.
      </div>
    </footer>


    <!-- JavaScripts -->
    <!-- jQuery -->
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>

    <!-- Bootsrap & MDB scripts -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script>

    <!-- Masonry & imagesLoaded -->
  <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
  <script defer src="/assets/js/masonry.js" type="text/javascript"></script>
    
  <!-- Medium Zoom JS -->
  <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script>
  <script defer src="/assets/js/zoom.js"></script><!-- Load Common JS -->
  <script defer src="/assets/js/common.js"></script>
  <script defer src="/assets/js/blog_enhancements.js" type="text/javascript"></script>
  <script defer src="/assets/js/sidenotes.js" type="text/javascript"></script>
  <script defer src="/assets/js/footnote_preview.js" type="text/javascript"></script>
  <script defer src="/assets/js/copy_code.js" type="text/javascript"></script>
  <script defer src="/assets/js/toc.js" type="text/javascript"></script>
  <script defer src="/assets/js/venue_filter.js" type="text/javascript"></script>

    
  <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script>
  <script async src="https://badge.dimensions.ai/badge.js"></script>

    <!-- MathJax 3.x with comprehensive configuration -->
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        tags: 'ams',
        // Support all common math delimiters
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']],
        processEscapes: true,
        processEnvironments: true,
        processRefs: true,
        // Common macros for convenience
        macros: {
          RR: '\\mathbb{R}',
          NN: '\\mathbb{N}',
          ZZ: '\\mathbb{Z}',
          CC: '\\mathbb{C}',
          EE: '\\mathbb{E}',
          PP: '\\mathbb{P}',
          bm: ['\\boldsymbol{#1}', 1],
          argmax: '\\operatorname*{arg\\,max}',
          argmin: '\\operatorname*{arg\\,min}',
          sgn: '\\operatorname{sgn}',
          KL: '\\mathrm{KL}',
          Var: '\\operatorname{Var}',
          Cov: '\\operatorname{Cov}',
          tr: '\\operatorname{tr}',
          diag: '\\operatorname{diag}'
        },
        // AMS packages
        packages: {'[+]': ['ams', 'boldsymbol', 'newcommand']}
      },
      loader: {
        load: ['[tex]/ams', '[tex]/boldsymbol', '[tex]/newcommand']
      },
      options: {
        // Skip math rendering in these HTML elements
        skipHtmlTags: [
          'script', 'noscript', 'style', 'textarea', 'pre', 'code',
          'annotation', 'annotation-xml', 'kbd', 'samp', 'var'
        ],
        // Fix issues with underscores being converted to <em> by HTML
        processHtmlClass: 'mathjax-process',
        ignoreHtmlClass: 'tex2jax_ignore|no-mathjax',
        // Render math even with HTML entities
        renderActions: {
          findScript: [10, function (doc) {
            // Pre-process to fix HTML entity issues in math
            for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            }
          }, '']
        }
      },
      svg: {
        fontCache: 'global',
        scale: 1.0
      },
      chtml: {
        scale: 1.0,
        matchFontHeight: true
      },
      startup: {
        ready: function () {
          MathJax.startup.defaultReady();
          // Fix: restore underscores that might have been converted to <em>
          MathJax.startup.promise.then(() => {
            console.log('MathJax typesetting complete');
          });
        }
      }
    };
  </script>
  <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script>
  
  <!-- Pre-processing script to protect math from Markdown/HTML interference -->
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      // Fix underscores in math that were converted to <em> by Markdown
      function fixMathUnderscores() {
        const mathContainers = document.querySelectorAll('.MathJax, .MathJax_Display, mjx-container');
        // This runs before MathJax, so we need to fix raw content
        const content = document.querySelector('.post-content, article');
        if (!content) return;
        
        // Find math delimiters and restore any <em> or <strong> inside them
        const html = content.innerHTML;
        
        // Pattern to find math blocks and restore underscore formatting
        // This is a fallback; the main protection is in the Jekyll plugin
      }
      
      // Fix HTML entities in display math blocks
      function fixHtmlEntities() {
        document.querySelectorAll('.language-plaintext.highlighter-rouge').forEach(el => {
          // Check if this looks like an HTML figure that wasn't rendered
          const text = el.textContent;
          if (text.includes('<img') || text.includes('<figure') || text.includes('<figcaption')) {
            // This is raw HTML that should be rendered - replace with actual HTML
            const temp = document.createElement('div');
            temp.innerHTML = text;
            el.replaceWith(...temp.childNodes);
          }
        });
      }
      
      fixHtmlEntities();
    });
  </script>

    <!-- Pseudocode -->
  <script defer src="https://cdn.jsdelivr.net/npm/pseudocode@2.4.1/build/pseudocode.min.js" integrity="sha256-aVkDxqyzrB+ExUsOY9PdyelkDhn/DfrjWu08aVpqNlo=" crossorigin="anonymous"></script>
  <script defer src="/assets/js/pseudocode-init.js" type="text/javascript"></script>
    <!-- Mermaid -->
  <script defer src="https://cdn.jsdelivr.net/npm/mermaid@10.9.3/dist/mermaid.min.js"></script>
  <script defer src="/assets/js/mermaid-init.js" type="text/javascript"></script>
    <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-2923RQZBXG"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){ window.dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'G-2923RQZBXG');
  </script>
    

<!-- Scrolling Progress Bar -->
<script type="text/javascript">
  /*
   * This JavaScript code has been adapted from the article
   * https://css-tricks.com/reading-position-indicator/ authored by Pankaj Parashar,
   * published on the website https://css-tricks.com on the 7th of May, 2014.
   * Couple of changes were made to the original code to make it compatible
   * with the `al-foio` theme.
   */
  const progressBar = $("#progress");
  /*
   * We set up the bar after all elements are done loading.
   * In some cases, if the images in the page are larger than the intended
   * size they'll have on the page, they'll be resized via CSS to accomodate
   * the desired size. This mistake, however, breaks the computations as the
   * scroll size is computed as soon as the elements finish loading.
   * To account for this, a minimal delay was introduced before computing the
   * values.
   */
  window.onload = function () {
    setTimeout(progressBarSetup, 50);
  };
  /*
   * We set up the bar according to the browser.
   * If the browser supports the progress element we use that.
   * Otherwise, we resize the bar thru CSS styling
   */
  function progressBarSetup() {
    if ("max" in document.createElement("progress")) {
      initializeProgressElement();
      $(document).on("scroll", function() {
        progressBar.attr({ value: getCurrentScrollPosition() });
      });
      $(window).on("resize", initializeProgressElement);
    } else {
      resizeProgressBar();
      $(document).on("scroll", resizeProgressBar);
      $(window).on("resize", resizeProgressBar);
    }
  }
  /*
   * The vertical scroll position is the same as the number of pixels that
   * are hidden from view above the scrollable area. Thus, a value > 0 is
   * how much the user has scrolled from the top
   */
  function getCurrentScrollPosition() {
    return $(window).scrollTop();
  }

  function initializeProgressElement() {
    // Use the CSS-defined padding-top value to avoid layout shift
    // The navbar height is already handled by CSS: body.fixed-top-nav { padding-top: 50px; }
    let navbarHeight = $("#navbar").outerHeight(true) || 50;
    // Only set progressBar position, don't override body padding to avoid layout shift
    $("progress-container").css({ "padding-top": navbarHeight });
    progressBar.css({ top: navbarHeight });
    progressBar.attr({
      max: getDistanceToScroll(),
      value: getCurrentScrollPosition(),
    });
  }
  /*
   * The offset between the html document height and the browser viewport
   * height will be greater than zero if vertical scroll is possible.
   * This is the distance the user can scroll
   */
  function getDistanceToScroll() {
    return $(document).height() - $(window).height();
  }

  function resizeProgressBar() {
    progressBar.css({ width: getWidthPercentage() + "%" });
  }
  // The scroll ratio equals the percentage to resize the bar
  function getWidthPercentage() {
    return (getCurrentScrollPosition() / getDistanceToScroll()) * 100;
  }
</script>

  </body>
</html>
